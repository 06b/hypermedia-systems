= Hypermedia In Action
:chapter: 6
:sectnums:
:figure-caption: Figure {chapter}.
:listing-caption: Listing {chapter}.
:table-caption: Table {chapter}.
:sectnumoffset: 5
// line above:  :sectnumoffset: 5  (chapter# minus 1)
:leveloffset: 1
:sourcedir: ../code/src
:source-language:

= Client Side Scripting

This chapter covers

* How scripting can be effectively added to a Hypermedia Driven Application
* Adding support for a drop-down in our contacts table
* Adding support for re-ordering contacts
* Adding a javascript-based confirmation for deleting contacts
* Adding a keyboard shortcut for focusing the search input


[partintro]
== Scripting In Hypermedia Driven Applications

"REST allows client functionality to be extended by downloading and executing code in the form of applets or scripts. This simplifies clients by reducing the number of features required to be pre-implemented."
-- Roy Fielding, Architectural Styles and the Design of Network-based Software Architectures

Thus far we have avoided writing any JavaScript for Contact.app, mainly because the functionality we implemented so far does not need it. Contrary to popular belief, hypermedia is not just for "documents" (where a document is considered essentially different to an "app"), and it has many affordances for building interactive experiences. We want to show that it is possible to build sophisticated web applications using the original model of the web without the abstractions provided by JavaScript frameworks. On the other hand, htmx itself is written in JavaScript, and we don't want our message to be interpreted as "JavaScript bad", or, more generally, "Client-side scripting bad."

image::htmx-loves-javascript.png[]

Scripting has been a massive multiplier of the Web's capabilities. Through its use, Web application authors are not only able to enhance their hypertext-based websites, but also create full-fledged client-side applications that can compete with native apps in how they work (although they don't always win when they do).

In other terms, the Web became a distribution medium for non-REST apps in addition to being a RESTful system.

So the question isn't "Should we be scripting for the web?" but rather "How should we be scripting for the web?"

Scripting, when it's used as a replacement for the RESTful architecture provided by the Web, is extremely useful in Hypermedia Driven Applications. We discuss what this means in much greater detail in an appendix, but the practical implications for HDA developers is that if

* The main data format exchanged between server of client is hypermedia, the same as it would be in an application with no scripting
* Client-side state (other than the DOM) is minimized

then you are scripting in a way compatible with HDAs.

This style of scripting requires us to different practices than what is usually recommended for JavaScript, as the most common advice often comes from a server or SPA context. We will see these practices in action in the upcoming chapter.

However, listing "best practices" is rarely convincing or edifying (and often boring). So, we instead frame them around shiny tools that work well for scripting in a HDA. We will use each of these tools to add a feature to ContactApp:

* An overflow menu to hold the _Edit_, _View_ and _Delete_ actions, to clean up visual clutter in our list of contacts
* Reordering contacts by dragging and dropping
* A dialog to confirm the deletion of contacts
* A keyboard shortcut for focusing the search box

The important idea in the implementation of each of these features is that they are entirely client-side and don't exchange information with the server using, for example, JSON. This is what will keep them all within the bounds of a proper Hypermedia Driven Application.

=== Scripting Languages For The Web

The primary scripting language for the web is, of course, JavaScript, which is ubiquitous in web development today. A bit of interesting internet lore, however, is that JavaScript was not always the only built-in option. As the quote from Roy Fielding above indicates, _applets_ written in other languages such as Java were considered part of the scripting infrastructure of the web. In addition, there was a brief period when Internet Explorer supported VBScript, a scripting language based on Visual Basic.

Today, we have a variety of _transcompilers_ (often shortened to _transpiler_)
that convert another language to JavaScript, such as TypeScript, Dart, Kotlin, ClojureScript, F#. There is also the WebAssembly bytecode format, which is supported as a compilation target for C, Rust, and the WASM-specific language AssemblyScript. However, most of these are not geared towards an HDA-compatible style of scripting --- compile-to-JS languages are paired with SPA-oriented libraries, and WASM is mainly geared toward linking to existing C/C++ libraries from JavaScript.

I bring this up because we are going to look at three different mechanisms for adding scripting to our Hypermedia Driven Application:

* VanillaJS, that is, using JavaScript itself, without relying on any library support
* AlpineJS, a javascript library for adding behavior directly in the HTML
* _hyperscript, a non-JavaScript scripting language that we created to complement htmx.  Like AlpineJS, it is embedded
  directly in the HTML.

Let's take a quick look at each of these scripting options so we know what we are dealing with.  As with CSS, we are not going to deep dive into any of these options: we are going to show just enough to give you a flavor of each and, we hope, spark your interest in looking into each of them more extensively.


==== Vanilla JavaScript

[quote]
No code is faster than no code.

Vanilla JavaScript is simply using JavaScript in your application without any intermediate layers. The term came into vogue as a play on the fact that there were so many ".js" frameworks out there to help you write JavaScript. As JavaScript matured as a scripting language, standardized across browsers and provided more and more functionality, the utility of many of these frameworks and libraries has diminished.

****
At the same time, however, SPAs became more popular, requiring better frameworks.
****

A quote from the humorous website http://vanilla-js.com captures the situation well:

[quote, http://vanilla-js.com]
____
Vanilla JS is the lowest-overhead, most comprehensive framework I've ever used.
____

The message of _VanillaJS_ here is that since the browser already has JavaScript baked into it, there isn't any need to download a framework for your application to function. This is often true and especially so in HDAs as hypermedia obviates many features provided by frameworks:

* Client-side routing
* An abstraction over DOM manipulation, i.e.: templates that automatically update when referenced variables change
* Server side rendering (rendering here refers to HTML generation)
  * Attaching dynamic behavior to server-rendered tags on load
* Network requests

Installation of VanillaJS couldn't be easier: you don't have to. You can just start writing JavaScript in your web application and it will simply work.

That's the good news. The bad news is that JavaScript has some limitations as a scripting language that often make it less than ideal  as a stand-alone scripting technology for Hypermedia Driven Applications:

* It is a relatively complex language, having accreted a lot of features and warts.
* Its model for concurrency involves _colored functions_, a concept described by Robert Nystrom in his oft-cited blog article _What Color is Your Function?_
  footnote:[https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/]
* It is surprisingly clunky to work with events in the language
* DOM APIs (a large portion of which were originally designed for Java)
  are verbose and do not make common functionality easy to use

None of these are deal breakers, of course, and many people prefer the "close to the metal" (for lack of a better term) nature of JavaScript to more elaborate client-side scripting approaches.

As our "hello world" example to showcase each of our scripting options, let's write a counter. It will have a number and a button that increment the number. Nothing too elaborate, but it will give you the flavor of each of the three scripting approaches we are going to use in this chapter.

We have a problem, however, as one of the things frameworks provide is still missing: a standardized code style. There are solutions to this problem, but before we reach for it, let's take a journey through various styles, starting with the simplest thing possible.

.Dismissible alert in JavaScript, inline version
[source,html]
----
<section class="counter">
  <output id="my-output">0</output> <1>
  <button
    onclick=" <2>
      document.querySelector('#my-output') <3>
        .textContent++ <4>
    "
  >Increment</button>
</section>
----
<1> Our output element has an ID to help us find it
<2> We use the `onclick` attribute, a brittle but quick way to add an event listener
<3> Find the output
<4> JavaScript lets us use the `++` operator on a string because it loves us

So, not too bad. It's a little annoying that we needed to add an `id` to the span to make this work and `document.querySelector` is a bit verbose compared to, say, `$` but (but!) it works and it doesn't require any other JavaScript libraries.

A more "standard" way to write the above would be to put the above in a separate file, either linked via a `<script src>` or placed into an inline `<script>` by a build process:

.Dismissible alert in JavaScript, in multiple files
--
[source,html]
----
<section class="counter">
  <output id="my-output">0</output>
  <button class="increment-btn">Increment</button>
</section>
----

[source,js]
----
const counterOutput = document.querySelector("#my-output") <1>
const incrementBtn  = document.querySelector(".counter .increment-btn") <2>

incrementBtn.addEventListener("click", e => { <3>
  counterOutput.innerHTML++ <4>
})
----
<1> Find the output element
<2> and the button
<3> We use `addEventListener`, which is preferable to `onclick` for many reasons
<4> The logic stays the same, only the structure around it changes
--

The main reason people do this is for the sake of Separation of Concerns.  By separating our JavaScript from our HTML, we will be able to edit one with confidence that we won't break the other.

Except... is that really the case?

Notice that the HTML in the above example is not just the previous example with the onclick attribute removed. Can you spot the difference?

You'll notice that we've had to add a class to the button so that we could find it in JS. In both the HTML and the JS, this ID is a string literal not subject to typechecking, and it certainly isn't checked if the ID is the same in both.

Furthermore, imagine that we want to change the number field from an `<output>` tag to an `<input type="number">`. This change to our HTML will break our JavaScript. The fix is trivial (change `.textContent` to `.value`), but I hope you can see how this would increase in larger components or across a whole page.

The tight coupling between components in this simple example suggests that separation between HTML and JavaScript (and CSS) is often an illusory separation of concerns. Contact.app is is not _concerned_ with structure, markup or data, it's concerned with collecting contact info and displaying it.

image::../images/separation-of-concerns-expectation-v-reality.png[]

Our suspicion is validated by developments in the JS framework world:

* JSX
* Lit
* CSS-in-JS
* Single-File Components

.2 > 1 > 2
****
Having two decoupled modules is better than having one big blob, but two tightly-coupled modules is worse than either.

(Of course, having no code at all is the best, so 0 > 2 > 1 > 2.)
****

So, should we go back to the first example? Unfortunately, JavaScript and the `on*` attributes are not a great way to program:

* They don't support custom events.
* There is no good mechanism for associating long-lasting variables with an element --- all variables are discarded when an event listener completes executing
* If you have multiple instances of an element, you will need to repeat the listener code on each, or use something more clever like event delegation.
* JavaScript code that directly manipulates the DOM can get verbose, and clutter the markup
* An element cannot listen for events on another element. For example, if you want to dismiss a popup by clicking outside it, the listener will need to be on the body element. The body element will need to have listeners that deal with many unrelated components, some of which may not even be on a particular page when pages are generated from a template.


==== AlpineJS

AlpineJS is a relatively new JavaScript library that allows you to embed your code directly in HTML.  It bills itself
as a modern replacement for jQuery, a widely used but quite old JavaScript library, and it lives up to that promise.

Installing AlpineJS is a breeze, you can simply include it via a CDN:

.Installing AlpineJS
[source,html]
----
<script src="//unpkg.com/alpinejs"></script>
----

As with htmx, you can also download it and host it on your own server.

You use AlpineJS by putting attributes directly in your HTML.  To implement our example features in AlpineJS, you would
establish a variable using the `x-data` attribute, which allows you to define variables.  Let's use it to establish
a variable named `open` with the value `false` initially.  We would then have our `span` refer to that variable with a
`x-show` attribute, which would tie the visibility of the `span` to the value of the `open` variable: if the value is
`true`, then the span is visible, otherwise it is not.

Finally, we can use the `x-on:click` attribute on the button to run some JavaScript when the button is clicked.  You can
listen for any event with the `x-on` prefix, with the name of the event following a colon after the `x-on` prefix.  In
this case we want to toggle the value of the `open` variable to `true`.

Here is what the code would look like:

.Using AlpineJS To Show Content
[source,html]
----
<div x-data="{ open: false }"> <1>
<button x-on:click="open = true">Expand</button> <2>

    <span x-show="open"> <3>
      Content...
    </span>
</div>
----
<1> The `open` variable is established with the value `false`
<2> The `@click` handler sets `open` to `true`
<3> The visibility of this span is tied to the `open` variable

As you can see, this code is much tighter than the VanillaJS implementation.  It helps that AlpineJS supports a notion
of variables, allowing you to bind the visibility of the `span` element to a variable that both it and the button
can access.  Alpine allows for much more elaborate data bindings as well, it is an excellent general purpose client-side
scripting library.

==== _hyperscript

While previous two examples are JavaScript-oriented, _hyperscript is a completely different scripting language for
front-end development.  It has a completely different syntax than JavaScript, derived from an older language called
HyperTalk, which was the scripting language of HyperCard, an old development system on the Macintosh Computer.  The
most noticable thing about _hyperscript is that it has an english-like syntax.  It was created as a sister project
to htmx, to make it possible to do event-oriented, high level scripting in htmx-based applications.

We will not be doing a deep dive on the language, but again just want to give you a flavor of what scripting in
_hyperscript is like, so you can pursue the language in more depth later if you find it interesting.

Like htmx and AlpineJS, _hyperscript can be installed via a CDN or installed locally

.Installing Hyperscript Via CDN
[source,html]
----
<script src="//unpkg.com/hyperscript.org"></script>
----

Like AlpineJS, in \_hyperscript you put attributes directly in your HTML.  Unlike AlpineJS, there is only one attribute
for _hyperscript: the `_` (underscore) attribute.  You write all your hyperscript inside this one attribute!

The implementation of our example button in hyperscript is similar, in some ways, to the VanillaJS implemenation: we will
start with the span hidden via the CSS `display` property, and toggle it.  However, the code will look quite a bit
different.  Let's look at the code first and then explain it:

.Using _hyperscript To Show Content
[source,html]
----
<div>
    <button _="on click set the *display of the next <span/> to 'inline'">Expand</button> <1>
    <span style="display: none"> <2>
      Content...
    </span>
</div>
----
<1> This is what _hyperscript looks like, believe it or not
<2> The `@click` handler sets `open` to `true`

Now, if you are a JavaScript programmer, that hyperscript probably looks insane to you.  And that's OK, it is a little
insane.  But let's parse what the code is saying, which isn't very hard since it looks so much like english: on a
click event, look up the next element in the DOM that matches the `span` CSS selector and set its `display` style
property to `inline`.  Simple, right!

There are some syntactic tricks you need to know, such as using `</>` for a CSS selector, and using the `*` prefix to
refer to a style property.  And you have to know about the `of` property access expression.  And how `set` works.

OK, maybe it is a little more than a little insane.  But fun!

.Locality of Behavior
****
Locality of Behavior (LoB) is a software design principle that we coined to describe the following characteristic of a
piece of software:

[quote, https://htmx.org/essays/locality-of-behaviour/]
____
The behaviour of a unit of code should be as obvious as possible by looking only at that unit of code
____

In simple terms: you should be able to tell what a button does by simply looking at that button.  You shouldn't need
to consult a bunch of different places to determine what the button does or why it behaves like it behaves.

All three of our examples demonstrate Locality of Behavior: by simply examining the button in question, you can see what
the button is doing and trace the effects from there.  Both AlpineJS and htmx support LoB as explicit design goals: they
are designed to be embedded directly within your HTML, putting the scripting on the elements in question.

VanillaJS is trickier here: we took advantage of the `onclick` attribute defined in the HTML specification, and, indeed
our VanillaJS example does have locality of behavior.  Unfortunately, there are only a fixed number of events that can
be responded to via `on` attributes in HTML, limiting your ability to embed code directly on elements to the standard
DOM events.  This limitation prevents you from handling custom events in this manner in VanillaJS.

And, in fact, some people prefer to move their scripting out of HTML entirely and use a different approach to hooking
in behavior to DOM elements: they will call the DOM API `addEventListener()` on elements from within a separate JavaScript
file.  This is a severe violation of Locality of Behavior: you now need to look in multiple places to understand what
the button does.  However, this does satisfy another, and much more popular design principle: Separation of Concerns (SoC).

SoC states that you should separate "concerns" such as code, markup and presentation information, into separate files,
for a cleaner overall system.

We feel that, in the case of front end scripting in a Hypermedia Driven Application, Locality of Behavior should be
favored over Separation of Concerns.
****

=== Events and The DOM

One thing that you will notice in all the scripting that we add to Contact.app is the heavy use of _events_.  This is
not an accident: proper scripting in a Hypermedia Driven Application should be heavily event driven.  Since htmx
itself allows you to trigger requests with arbitrary events, those events provide an excellent bridge between
client-side scripting and the hypermedia exchanges that define a RESTful Hypermedia Driven Application.

Another thing you might notice about the scripting examples is that many of them mutate the DOM in some way, showing
or hiding elements, or changing the focus of an element and so forth.  In many cases this change in state isn't
synchronized with the server, so how can we claim that hypermedia is the engine of application state in this case?!?

The answer is that this state is client side, and ephemeral: it is fine to have a script update the DOM in some way
that improves the user experience, so long as that script is not updating _system state_ (e.g. a contact's details)
via out-of-band, non-hypermedia communication.

== Adding a Keyboard Shortcut for Focusing the Search Input With VanillaJS

== Adding Support for Re-Ordering Contacts (No Scripting Needed!)

== Adding Support for a Drop-Down with AlpineJS

== Adding a Nicer Confirmation for Deleting Contacts With _hyperscript

=== Adding a Keyboard Shortcut for Focusing the Search Input With _hyperscript

TODO: Show how easy this is in hyperscript

=== Adding Support for a Drop-Down with _hyeprscript

TODO: Show how easy this is in hyperscript

== Being Pragmatic About Scripting

TODO: Sometimes going outside the lines is necessary, being pragmatic

== Conclusion