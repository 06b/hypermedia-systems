
= Effective HTML - Pullouts

WARNING: test of key ideas as pullouts to be sprinkled throughout the book
////
Many pieces of the chapter read like little gems; these might work well as pullouts.
The following attempts to break the chapter into pieces for use throughout the book.
This is just an option to consider.

I we go this route, it would useful to index or add a ToC entry for 'HTML Topics'

Note: I used [.design-note] to flag for formatting. 
which... may not be useful
//// 

[.design-note]
.Why Effective HTML?
****
Sprinkled throughout this book you will find tips and best practices for writing effective HTML.

It's very easy (and sometimes acceptable) to produce mediocre HTML that _seems to_ work,
and many websites settle with _seeming to_ work.

But writing good, spec-compliant HTML lets browsers do a bunch of work for you. Furthermore, even when they don't, it makes it easier to write scripts that do. Fewer issues will be found during testing and you can release faster. When issues do come up, you can often fix them more easily by refactoring HTML as opposed to heaping JavaScript and ARIA attributes over everything.

Effective HTML typically loads faster, is easier to read and debug, performs better both with search engine ranking and screen reader accessibility, and can be scraped programatically. 
// TODO: check last sentence here; pulled together from various paragraphs
****





[.design-note]
.Test, and Test Again
****
Even good HTML is not a cure-all.
If you care about machine readability, or human readability, or page weight, the most important thing to do is _testing_.
Test manually.
Test automatically.

Test with screenreaders, test with a keyboard, test on different browsers and hardware, and run linters (while coding and/or in CI).
****





[.design-note]
.Markdown soup
****
[.dfn]_Markdown soup_ is the lesser known sibling of `<div>` soup.
This is the result of web developers limiting themselves to the set of elements that the Markdown language provides shorthand for,
even when these elements are incorrect.
Consider the following example of an IEEE-style citation:

[source,markdown]
----
[1] C.H. Gross, A. Stepinski, and D. Akşimşek, <1>
_Hypermedia Systems_, <2>
Bozeman, MT, USA: Big Sky Software.
Available: <https://hypermedia.systems/>
----
<1> The reference number is written in brackets.
<2> Underscores around the book title creates an <em> element.

Here, <em> is used because it's the only Markdown element that is presented in italics by default.
This indicates that the book title is being stressed, but the purpose is to mark it as the title of a work.
HTML has the `<cite>` element that's intended for this exact purpose.

Furthermore, even though this is a numbered list perfect for the `<ol>` element, which Markdown supports, plain text is used for the reference numbers instead.
Why could this be?
The IEEE citation style requires that these numbers are presented in square brackets.
This could be achieved on an `<ol>` with CSS,
but Markdown doesn't have a way to add a class to elements meaning the square brackets would apply to all ordered lists.
****


// TODO: maybe an info gem?
[.design-note]
.On Lists 
****
We call `<ol>` and `<ul>` "ordered" and "unordered" lists. Both are actually ordered, however, and the difference is whether the place of a particular element is significant. For instance, instructions should usually be marked up with `<ol>` since it may contain references like "Repeat steps 3 to 5". If items in our list are not referenced by number, we would use an `<ul>`.
****


[.design-note]
.Embedding HTML in Markdown
****
Don't shy away from using embedded HTML in Markdown.
For larger sites, also consider Markdown extensions.

[source,markdown]
----
{.ieee-reference-list} <1>
1. C.H. Gross, A. Stepinski, and D. Akşimşek, <2>
   <cite>Hypermedia Systems</cite>, <3>
   Bozeman, MT, USA: Big Sky Software.
   Available: <https://hypermedia.systems/>
----
<1> Many Markdown dialects let us add ids, classes and attributes using curly braces.
<2> We can now use the <ol> element, and create the brackets in CSS.
<3> We use `<cite>` to mark the title of the work being cited (not the whole citation!)

You can also use custom processors to produce extra-detailed HTML instead of writing it by hand:

[source,markdown]
----
{% reference_list %} <1>
[hypers2023]: <2>
C.H. Gross, A. Stepinski, and D. Akşimşek, _Hypermedia Systems_,
Bozeman, MT, USA: Big Sky Software, 2023.
Available: <https://hypermedia.systems/>
{% end %}
----
<1> `reference_list` is a macro that will transform the plain text to highly-detailed HTML.
<2> A processor can also resolve identifiers, so we don't have to manually keep the reference list in order and the in-text citations in sync.
****










[.design-note]
.Know Your HTML Budget
****
The close relationship between content and markup means that
good HTML is labor-intensive.
Most sites have a separation between the authors,
who are rarely familiar with HTML,
and the developers, who need to develop a generic system able to handle any content that's thrown at it --
this separation usually taking the form of a CMS.
As a result, having markup tailored to content, which is often necessary for advanced HTML, is rarely feasible.

Furthermore, for internationalized sites, content in different languages being injected into the same elements can degrade markup quality as stylistic conventions differ between languages.
It's an expense few organizations can spare.

Thus, we don't expect every site to contain perfectly conformant HTML.
What's most important is to avoid _wrong_ HTML -- it can be better to fall back on a more generic element than to be precisely incorrect.

If you have the resources, however, putting more care in your HTML will produce a more polished site.
****




// TODO: check. Does this list accurately condense the work of ch.3?
[.design-note]
.Toward Effective HTML
****
Throughout the book we discuss a number of best practices for writing effective HTML. Here's a nutshell version: 

* Stay close to the HTML markup you’re producing and be able to change it. Prefer frameworks and components that help you do this. 
// TODO: maybe add. Aim for 'locality of behavior' in your markup, so that you or another developer can understand what each part of the page is doing just by looking at that part of the page.  
* Make the full range of available tags part of your toolkit. 
* Aim for good fit between tag specs and your use case; check the HTML specs when in doubt. 
* When more specific tags don’t fit, it is okay -- and usually better -- to step back to <div> than to use a tag incorrectly. 
* Stick with established libraries for UI interactions. If a use case requires an improvised solution, test carefully for keyboard interaction and accessibility.
* Prefer components that extend HTML, rather than abstracting it away.
* Test your HTML with screenreaders, with a keyboard, with different browsers and hardware, and run linters (while coding and/or in CI).
****


[.design-note]
.Resources for Effective HTML
****
Some resources we recommend:

* Foundations
* HTML specification: https://html.spec.whatwg.org/multipage

* TODO link resources on alt text.

* https://htmhell.dev: Along with sinister abuses of HTML, this website shares development tips that will help ypu keep up-to-date with best practice.

* Referenced

** Manuel Matuzović, [.cite]_Lost in Translation_, https://www.youtube.com/watch?v=Wno1IhEBTxc.

** Manuel Matuzović, [.cite]_Why I'm not the biggest fan of Single Page Applications_, https://www.matuzo.at/blog/2023/single-page-applications-criticism/

** [.cite]_semantic: the 8 letter s-word_, https://t-ravis.com/post/doc/semantic_the_8_letter_s-word/
****


// TODO: format as info gem
.About Display: none
****
`display: none;` in CSS is not purely cosmetic -- it removes elements from the accessibility tree and keyboard focus. If you want to hide an element visually without hiding it from assistive technology, you can use this utility class:

[source,css]
----
.vh {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	block-size: 1px;
	inline-size: 1px;
	overflow: hidden;
	white-space: nowrap;
}
----

`vh` is short for "`visually hidden.`" This class uses multiple methods and workarounds to make sure no browser removes the element's function.
****


// TODO: format as info gem
.Remember <details>
****
Does the information need to be presented as tabs?
Sometimes the answer is yes, but if not, a sequence of details and disclosures fulfills a very similar purpose.

[source,html]
----
<details><summary>Disclosure 1</summary>
  Disclosure 1 contents
</details>
<details><summary>Disclosure 2</summary>
  Disclosure 2 contents
</details>
----

Compromising UX just to avoid JavaScript is bad development.
But sometimes it's possible to achieve an equal (or better!) quality of UX while allowing for a simpler and more robust implementation.
****


// TODO: Some readers may want more specific advice: what does it mean to write HTML for humans? 
.Screen Reader Rage
****
The spec is a good starting point when deciding how to mark something up,
but when browser implementations don't conform,
we shouldn't throw up our hands because we did what was specified.

After all, browser implementers do a _lot_ of work to deal with developers' broken HTML -- is it such a burden to return the favor?

It is frustrating when browsers and other tools misbehave.
Accessibility itself feels inaccessible sometimes.
To reduce the frustration it may help to recognize that hypermedia exchanges are not machine-to-machine communication.
An HTML file is not a program that produces a human-readable document.
It _is_ the document.
So, instead of banging your head against a wall, focus on people, not the tools they use.

Don't write HTML for browsers. or assistive tools, or validators.
HTML is not _for_ them.
HTML is for humans.
****


// maybe move to ch1, The Essence of HTML as a Hypermedia
.What is HTML?
****
[quote, Marshall McLuhan]
The medium is the message.

Is it a document format?
Is it for applications?
Is it a rendering system?
Is it (gasp!) a programming language?

[quote, Roy Fielding, https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-718]
____
When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions.
____

HTML, like all hypermedia, blurs the distinction between the information being accessed and the application used to access it. HTML is for documents, insofar as you're willing to adopt a broad definition of "`document`" -- and it is for applications, ones that are interwoven with the data they process.

HTML is a hypermedium.

An HTML file is not a program that produces a human-readable document.
It _is_ the document.
****


// TODO: keep? format as pullout, like Web Components, ARIA
.The "`Semantic Web`"
****
[quote, '_Mean Girls_ (2004)']
Gretchen, stop trying to make fetch happen! It's not going to happen!

The "Semantic Web" was a vision of a system that could both express any kind of human knowledge, and be useful for computing.
It planned to achieve this using _ontologies_, repositories of schemas like "person", "movie" and "species" and relations like "named", "part of" and "created by".

The problem with this vision is that information on the Web rarely fits into neat categories.
Because no single ontology can be defined that encapsulates all kinds of information one might wish to publish on the Web,
Semantic Web systems need to be pluggable with different schemas.
In turn, a Semantic Web client, in order to do something useful with an arbitrary piece of HTML, needs to be able to parse these schemas, which means we need to define a standard machine-readable format for ontologies.
But a single format couldn't express every kind of object and relation...
It's turtles all the way down.

In practice, most implementations stop at the topmost turtle.
Ontologies are defined in natural language,
and clients are hardcoded to support a fixed set of schemas.
The requirement for prior agreement between server and client means this technology does not have the generality of the Web,
and for most use cases, you might as well define a JSON API.

_The Semantic Web has nothing to do with semantic HTML_.
****