<!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/pagedjs/dist/paged.polyfill.js"></script>
    <style>@keyframes bg{0%{background:0 0}}*,::after,::before{box-sizing:border-box;background-repeat:no-repeat}::after,::before{text-decoration:inherit;vertical-align:inherit}:root{cursor:default;overflow-wrap:break-word;-webkit-tap-highlight-color:transparent;text-size-adjust:none;-webkit-text-size-adjust:none}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}audio,canvas,iframe,img,svg,video{vertical-align:middle}svg:not([fill]){fill:currentColor}table{border-collapse:collapse;border-color:currentColor;text-indent:0;font-variant-numeric:tabular-nums;font:inherit}body,button,input,select,textarea{margin:0}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}fieldset{border:1px solid #a0a0a0;position:relative;padding:var(--gap);margin:var(--gap) 0;width:100%;border-radius:var(--border-radius);border:1px solid var(--graphical-fg)}progress{vertical-align:baseline}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{block-size:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[hidden],datalist{display:none!important}:focus-visible{outline:.2em solid var(--accent);z-index:32}body:focus-visible,html:focus-visible,iframe:focus-visible{outline:0}:target{outline:.2em solid var(--fg);z-index:2}details>summary:first-of-type{display:list-item}[aria-busy=true]{cursor:progress}[aria-disabled=true],[disabled]{cursor:not-allowed}:root{--gray-0: #f8fafb;--gray-1: #f2f4f6;--gray-2: #ebedef;--gray-3: #e0e4e5;--gray-4: #d1d6d8;--gray-5: #b1b6b9;--gray-6: #979b9d;--gray-7: #7e8282;--gray-8: #666968;--gray-9: #50514f;--gray-10: #3a3a37;--gray-11: #252521;--gray-12: #121210;--red-0: #fff5f5;--red-1: #ffe3e3;--red-2: #ffc9c9;--red-3: #ffa8a8;--red-4: #ff8787;--red-5: #ff6b6b;--red-6: #fa5252;--red-7: #f03e3e;--red-8: #e03131;--red-9: #c92a2a;--red-10: #b02525;--red-11: #962020;--red-12: #7d1a1a;--pink-0: #fff0f6;--pink-1: #ffdeeb;--pink-2: #fcc2d7;--pink-3: #faa2c1;--pink-4: #f783ac;--pink-5: #f06595;--pink-6: #e64980;--pink-7: #d6336c;--pink-8: #c2255c;--pink-9: #a61e4d;--pink-10: #8c1941;--pink-11: #731536;--pink-12: #59102a;--purple-0: #f8f0fc;--purple-1: #f3d9fa;--purple-2: #eebefa;--purple-3: #e599f7;--purple-4: #da77f2;--purple-5: #cc5de8;--purple-6: #be4bdb;--purple-7: #ae3ec9;--purple-8: #9c36b5;--purple-9: #862e9c;--purple-10: #702682;--purple-11: #5a1e69;--purple-12: #44174f;--violet-0: #f3f0ff;--violet-1: #e5dbff;--violet-2: #d0bfff;--violet-3: #b197fc;--violet-4: #9775fa;--violet-5: #845ef7;--violet-6: #7950f2;--violet-7: #7048e8;--violet-8: #6741d9;--violet-9: #5f3dc4;--violet-10: #5235ab;--violet-11: #462d91;--violet-12: #3a2578;--indigo-0: #edf2ff;--indigo-1: #dbe4ff;--indigo-2: #bac8ff;--indigo-3: #91a7ff;--indigo-4: #748ffc;--indigo-5: #5c7cfa;--indigo-6: #4c6ef5;--indigo-7: #4263eb;--indigo-8: #3b5bdb;--indigo-9: #364fc7;--indigo-10: #2f44ad;--indigo-11: #283a94;--indigo-12: #21307a;--blue-0: #e7f5ff;--blue-1: #d0ebff;--blue-2: #a5d8ff;--blue-3: #74c0fc;--blue-4: #4dabf7;--blue-5: #339af0;--blue-6: #228be6;--blue-7: #1c7ed6;--blue-8: #1971c2;--blue-9: #1864ab;--blue-10: #145591;--blue-11: #114678;--blue-12: #0d375e;--cyan-0: #e3fafc;--cyan-1: #c5f6fa;--cyan-2: #99e9f2;--cyan-3: #66d9e8;--cyan-4: #3bc9db;--cyan-5: #22b8cf;--cyan-6: #15aabf;--cyan-7: #1098ad;--cyan-8: #0c8599;--cyan-9: #0b7285;--cyan-10: #095c6b;--cyan-11: #074652;--cyan-12: #053038;--teal-0: #e6fcf5;--teal-1: #c3fae8;--teal-2: #96f2d7;--teal-3: #63e6be;--teal-4: #38d9a9;--teal-5: #20c997;--teal-6: #12b886;--teal-7: #0ca678;--teal-8: #099268;--teal-9: #087f5b;--teal-10: #066649;--teal-11: #054d37;--teal-12: #033325;--green-0: #ebfbee;--green-1: #d3f9d8;--green-2: #b2f2bb;--green-3: #8ce99a;--green-4: #69db7c;--green-5: #51cf66;--green-6: #40c057;--green-7: #37b24d;--green-8: #2f9e44;--green-9: #2b8a3e;--green-10: #237032;--green-11: #1b5727;--green-12: #133d1b;--lime-0: #f4fce3;--lime-1: #e9fac8;--lime-2: #d8f5a2;--lime-3: #c0eb75;--lime-4: #a9e34b;--lime-5: #94d82d;--lime-6: #82c91e;--lime-7: #74b816;--lime-8: #66a80f;--lime-9: #5c940d;--lime-10: #4c7a0b;--lime-11: #3c6109;--lime-12: #2c4706;--yellow-0: #fff9db;--yellow-1: #fff3bf;--yellow-2: #ffec99;--yellow-3: #ffe066;--yellow-4: #ffd43b;--yellow-5: #fcc419;--yellow-6: #fab005;--yellow-7: #f59f00;--yellow-8: #f08c00;--yellow-9: #e67700;--yellow-10: #b35c00;--yellow-11: #804200;--yellow-12: #663500;--orange-0: #fff4e6;--orange-1: #ffe8cc;--orange-2: #ffd8a8;--orange-3: #ffc078;--orange-4: #ffa94d;--orange-5: #ff922b;--orange-6: #fd7e14;--orange-7: #f76707;--orange-8: #e8590c;--orange-9: #d9480f;--orange-10: #bf400d;--orange-11: #99330b;--orange-12: #802b09;--choco-0: #fff8dc;--choco-1: #fce1bc;--choco-2: #f7ca9e;--choco-3: #f1b280;--choco-4: #e99b62;--choco-5: #df8545;--choco-6: #d46e25;--choco-7: #bd5f1b;--choco-8: #a45117;--choco-9: #8a4513;--choco-10: #703a13;--choco-11: #572f12;--choco-12: #3d210d;--brown-0: #faf4eb;--brown-1: #ede0d1;--brown-2: #e0cab7;--brown-3: #d3b79e;--brown-4: #c5a285;--brown-5: #b78f6d;--brown-6: #a87c56;--brown-7: #956b47;--brown-8: #825b3a;--brown-9: #6f4b2d;--brown-10:#5e3a21;--brown-11:#4e2b15;--brown-12: #422412;--sand-0: #f8fafb;--sand-1: #e6e4dc;--sand-2: #d5cfbd;--sand-3: #c2b9a0;--sand-4: #aea58c;--sand-5: #9a9178;--sand-6: #867c65;--sand-7: #736a53;--sand-8: #5f5746;--sand-9: #4b4639;--sand-10:#38352d;--sand-11:#252521;--sand-12: #121210;--camo-0: #f9fbe7;--camo-1: #e8ed9c;--camo-2: #d2df4e;--camo-3: #c2ce34;--camo-4: #b5bb2e;--camo-5: #a7a827;--camo-6: #999621;--camo-7: #8c851c;--camo-8: #7e7416;--camo-9: #6d6414;--camo-10: #5d5411;--camo-11: #4d460e;--camo-12: #36300a;--jungle-0: #ecfeb0;--jungle-1: #def39a;--jungle-2: #d0e884;--jungle-3: #c2dd6e;--jungle-4: #b5d15b;--jungle-5: #a8c648;--jungle-6: #9bbb36;--jungle-7: #8fb024;--jungle-8: #84a513;--jungle-9: #7a9908;--jungle-10: #658006;--jungle-11: #516605;--jungle-12: #3d4d04}html{font-family:var(--main-font);line-height:var(--rhythm);background:var(--bg);color:var(--fg);scroll-padding-block-start:calc(4*var(--gap))}footer,header,section+section{margin-block:calc(2*var(--gap))}aside.big,nav a{color:var(--accent)}nav a{text-decoration:none}aside h1,aside h2,aside h3,aside h4,aside h5,aside h6{font-size:1em;text-transform:none;letter-spacing:none}aside.big{background:0 0;border:0;-webkit-border-start:1px solid var(--muted-fg);border-inline-start:1px solid var(--muted-fg);border-radius:0;padding:0;-webkit-padding-start:var(--rhythm);padding-inline-start:var(--rhythm);font-style:italic}.\<h1\>,.\<h2\>,.\<h3\>,.\<h4\>,.\<h5\>,.\<h6\>,h1,h2,h3,h4,h5,h6{-webkit-margin-after:var(--gap);margin-block-end:var(--gap);font-family:var(--secondary-font);-webkit-margin-before:calc(2*var(--gap));margin-block-start:calc(2*var(--gap));position:relative}.\<h1\>,.\<h2\>,h1,h2{font-size:2em;text-transform:none;line-height:calc(2*var(--rhythm));letter-spacing:0}.\<h2\>,h2{font-size:1.6em;line-height:calc(1.5*var(--rhythm))}.\<h3\>,.\<h4\>,.\<h5\>,.\<h6\>,h3,h4,h5,h6{font-size:1.17em;line-height:calc(1*var(--rhythm))}.\<h4\>,.\<h5\>,.\<h6\>,h4,h5,h6{font-size:1em;text-transform:none;letter-spacing:0;-webkit-margin-before:var(--gap);margin-block-start:var(--gap)}h1+h2,h1:first-child,h2+h3,h2:first-child,h3+h4,h3:first-child,h4+h5,h4:first-child,h5+h6,h5:first-child,h6:first-child{-webkit-margin-before:var(--gap);margin-block-start:var(--gap)}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{outline:0}h1:target::before,h2:target::before,h3:target::before,h4:target::before,h5:target::before,h6:target::before{content:"";display:block;position:absolute;left:-.5em;width:4px;height:100%;background:var(--accent)}header{-webkit-border-after:1px solid var(--graphical-fg);border-block-end:1px solid var(--graphical-fg)}dt,footer,header{font-family:var(--secondary-font)}footer{-webkit-border-before:1px solid var(--graphical-fg);border-block-start:1px solid var(--graphical-fg)}body>footer,body>header,main+footer{padding:var(--rhythm) calc((100% - var(--eff-line-length))/2)}address{--density: 0}dl,hr,p{margin-block:var(--gap)}hr{color:inherit;margin-inline:0;flex:0 1 0px;-webkit-border-start:1px solid var(--accent);border-inline-start:1px solid var(--accent);block-size:auto;-webkit-border-before:1px solid var(--accent);border-block-start:1px solid var(--accent);-webkit-border-after:none;border-block-end:none;-webkit-border-end:none;border-inline-end:none}blockquote,pre{line-height:var(--rhythm)}pre{font-family:var(--mono-font);tab-size:2;margin:var(--gap) 0;overflow-x:auto;scrollbar-width:thin;scrollbar-color:var(--accent) transparent;font-size:.9em}blockquote{margin-inline:0 var(--gap);padding-inline:var(--gap) 0;margin-block:var(--gap);font-size:1.1em;font-style:italic;-webkit-border-start:1px solid var(--graphical-fg);border-inline-start:1px solid var(--graphical-fg);color:var(--muted-fg)}.italic address,.italic cite,.italic dfn,.italic em,.italic i,.italic var,blockquote address,blockquote cite,blockquote dfn,blockquote em,blockquote i,blockquote var,q address,q cite,q dfn,q em,q i,q var{font-style:normal}blockquote footer{text-align:right;text-align:end}ol,ul{-webkit-padding-start:var(--rhythm);padding-inline-start:var(--rhythm)}ol ol,ol ul,ul ol,ul ul{-webkit-padding-start:var(--gap);padding-inline-start:var(--gap)}ol[role=list],ol[role=listbox],ul[role=list],ul[role=listbox]{-webkit-padding-start:0;padding-inline-start:0;list-style:none}ol{list-style:decimal}dt{font-weight:700}dd{-webkit-margin-start:var(--rhythm);margin-inline-start:var(--rhythm)}li::marker{font-family:var(--secondary-font)}figure{max-width:100%;margin-inline:0}figcaption{margin-block:var(--gap);font-family:var(--secondary-font);color:var(--muted-fg)}main{max-inline-size:var(--eff-line-length);inline-size:100%;margin-inline:auto}main:first-child{padding-top:var(--gap)}.\<a\>,a{color:var(--link-fg, var(--accent));font-family:var(--secondary-font);border-radius:var(--border-radius);outline-offset:1px;background:0 0;border:0;font-size:1em;-webkit-text-decoration:1px dashed underline;text-decoration:1px dashed underline}.list-of-links :is(a,.\<a\>){text-decoration:none}:is(a,.\<a\>):focus,:is(a,.\<a\>):hover{-webkit-text-decoration:2px solid underline;text-decoration:2px solid underline;cursor:pointer;outline:0}small[role=note]{display:block;float:inline-end;clear:inline-end;--sidenote-width: 20ch;max-inline-size:var(--sidenote-width);padding-inline:1.5ch 1ch;-webkit-margin-end:calc(1em - var(--sidenote-width));margin-inline-end:calc(1em - var(--sidenote-width));-webkit-margin-after:var(--rhythm);margin-block-end:var(--rhythm);font-family:var(--secondary-font);background:var(--bg);border:1px solid transparent;transition:transform .1s ease-in-out}small[role=note]:focus-within,small[role=note]:hover{border:1px solid var(--graphical-fg);border-radius:var(--border-radius);transform:translateX(calc(0px - var(--sidenote-width) + min(var(--gutter-width),var(--sidenote-width))))}.\<small\>,kbd kbd,small{font-size:.8em}del,s{color:var(--bad-fg)}caption,q{font-style:italic}time{font-variant-numeric:tabular-nums}code,kbd,samp{font-family:var(--mono-font);font-style:normal}ins,samp{color:var(--ok-fg)}kbd kbd{display:inline-block;padding:0 .3em;line-height:1.1em;background:var(--interactive-bg);border:1px outset var(--graphical-fg);border-block-end-width:3px;border-radius:var(--border-radius)}sub{vertical-align:bottom}sub,sup{line-height:1}mark{background:var(--warn-bg);color:var(--warn-fg)}ins{background:var(--ok-bg)}del{background:var(--bad-bg)}audio,embed,iframe,img,object,video{max-inline-size:100%;inline-size:max-content;block-size:auto}caption{text-align:start;font-family:var(--secondary-font)}tbody{border-block:1px solid var(--faded-fg)}select[multiple],sup,td,th{vertical-align:top}td:not(:last-child),th:not(:last-child){-webkit-padding-end:var(--rhythm);padding-inline-end:var(--rhythm)}th{font-family:var(--secondary-font);text-align:start}input{display:block}label input:not([specificity-hack]){display:inline;padding-block:0}.\<button\>,button,input::file-selector-button,input[type=button],input[type=reset],input[type=submit]{display:inline-block;padding:0 calc(var(--rhythm)/4);vertical-align:middle;box-sizing:border-box;font-size:.8rem;line-height:1.125em;font-family:var(--secondary-font);min-height:var(--rhythm);background:var(--interactive-bg);border:1px solid var(--muted-fg);box-shadow:0 2px 4px -2px var(--fg);border-radius:var(--border-radius);color:var(--fg);text-decoration:none;display:inline-flex;place-items:center}:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):focus-visible,:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):hover{filter:brightness(1.1);box-shadow:0 3px 6px -2px var(--fg);text-decoration:none}:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):active{box-shadow:none}:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):where([aria-pressed="true"], [aria-expanded="true"]){box-shadow:0 2px 4px -1px var(--fg) inset;background:var(--pressed-interactive-bg)}:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):where([aria-pressed="true"], [aria-expanded="true"]):focus-visible,:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>):where([aria-pressed="true"], [aria-expanded="true"]):hover{box-shadow:0 1px 3px -1px var(--fg) inset}[disabled]:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>){color:var(--muted-fg);box-shadow:none}strong>:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>){background:var(--accent);color:var(--bg);border:0;font-weight:700}strong>[disabled]:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>){color:var(--muted-accent)}.big:is(button,input[type="submit"],input[type="reset"],input[type="button"],input::file-selector-button,.\<button\>){min-block-size:calc(1.5*var(--rhythm));font-size:1rem;padding-inline:calc(.5*var(--rhythm));line-height:var(--rhythm)}input:not([type]),input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=month],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],input[type=week],select,textarea{padding:calc(var(--rhythm)/4);font-size:1rem;line-height:inherit;font-family:var(--main-font);background:var(--bg);color:var(--fg);border:1px solid var(--graphical-fg);border-radius:var(--border-radius);vertical-align:top}:is(input:not([type]),input[type="text"],input[type="search"],input[type="tel"],input[type="url"],input[type="email"],input[type="password"],input[type="date"],input[type="month"],input[type="week"],input[type="time"],input[type="datetime"],input[type="datetime-local"],input[type="number"],select,textarea):focus-visible{border:1px solid var(--accent)}:is(input:not([type]),input[type="text"],input[type="search"],input[type="tel"],input[type="url"],input[type="email"],input[type="password"],input[type="date"],input[type="month"],input[type="week"],input[type="time"],input[type="datetime"],input[type="datetime-local"],input[type="number"],select,textarea)::placeholder{color:var(--muted-fg);opacity:1;text-align:end}input[type=range]{width:100%;padding:calc(var(--gap)/4)}input[type=color]{padding:0;margin:0;height:calc(1.5*var(--rhythm));border:0;background:0 0}input[type=file]{padding:calc(var(--gap)/4) 0;font:inherit;line-height:calc(var(--rhythm)/2)}input[type=file]::file-selector-button{margin-block:.1em 0;-webkit-margin-end:1ch;margin-inline-end:1ch}optgroup::before{color:var(--muted-fg);font-style:normal}label[for]{display:block;padding-block:calc(var(--gap)/4)}fieldset>legend+*{-webkit-margin-before:0;margin-block-start:0}details:not(specificity-hack){-webkit-padding-before:0;padding-block-start:0}details:not(specificity-hack):not([open]){-webkit-padding-after:0;padding-block-end:0}summary{margin:calc(0px - var(--gap));margin-bottom:0;padding-inline:var(--gap);font-family:var(--secondary-font);font-weight:700;cursor:pointer}summary:active,summary:focus-visible{filter:brightness(.8);outline:0}dialog{inline-inset:0;block-size:-moz-fit-content;block-size:fit-content;inline-size:-moz-fit-content;inline-size:fit-content;margin:auto!important;background-color:var(--bg);color:var(--fg)}dialog[open]::backdrop{display:block;background:#000;opacity:.4;animation:bg 2s}dialog:not([open]){display:none}.box,.sidebar-layout>header,[role=menu],[role=tabpanel],aside,details,dialog,figure{margin:var(--gap) 0;padding:var(--gap);overflow:clip;border-radius:var(--border-radius);background:var(--box-bg);border:1px solid var(--graphical-fg)}.titlebar{margin-inline:calc(0px - var(--gap));-webkit-margin-after:calc(0px - var(--gap));margin-block-end:calc(0px - var(--gap));padding-inline:var(--gap);font:inherit;font-family:var(--secondary-font);font-weight:700;translate:0 calc(-1px - var(--gap));background:var(--graphical-fg);color:var(--bg)}.sub-title,sub-title{display:block;font-weight:400;color:var(--muted-fg)}.tool-bar,[role=toolbar]{display:flex;flex-flow:row wrap;gap:calc(var(--gap)/2)}.tool-bar>*,[role=toolbar]>*{margin:0}.sidebar-layout header li{margin-block:calc(.5*var(--gap))}.breadcrumbs[aria-label] [aria-current=page],.sidebar-layout header a{font-weight:700}@media (min-width:75ch){.sidebar-layout{display:grid;grid-template-columns:25ch auto;inset:0}.sidebar-layout>header{border-block:none;-webkit-border-start:none;border-inline-start:none;margin:0}.sidebar-layout>:nth-child(2){overflow:auto;--full-width: calc(100vw - 25ch);margin-top:var(--gap)}}.breadcrumbs[aria-label]{font-family:var(--secondary-font)}.breadcrumbs[aria-label] ol,.breadcrumbs[aria-label] ul{list-style:none;-webkit-padding-start:0;padding-inline-start:0}.breadcrumbs[aria-label] li{display:inline}:is(.breadcrumbs[aria-label] li)+li::before{content:' / ';display:inline}.chip,.navbar,chip{font-family:var(--secondary-font);background:var(--box-bg)}.chip,chip{border:1px solid var(--accent);border-radius:calc(var(--rhythm)/2);padding-inline:calc(var(--rhythm)/2)}.navbar{padding:var(--rhythm);-webkit-border-after:1px solid var(--accent);border-block-end:1px solid var(--accent);overflow-x:auto;scrollbar-width:thin;position:sticky;z-index:5;top:0;left:0;right:0;display:flex;flex-flow:row;align-items:center;gap:var(--gap)}.navbar.expanded{flex-flow:column;align-items:start;max-height:90vh;overflow-y:auto}.navbar.expanded ul[role=list]{flex-flow:column}.navbar *{flex-shrink:0;margin-block:0}.navbar:not(.expanded) nav>:first-child,.navbar:not(.expanded)>:first-child{-webkit-margin-start:auto;margin-inline-start:auto}.navbar:not(.expanded) nav>:last-child,.navbar:not(.expanded)>:last-child{-webkit-margin-end:auto;margin-inline-end:auto}.navbar hr{align-self:stretch}.navbar nav ul[role=list]{display:flex;flex-flow:row;gap:var(--rhythm);-webkit-padding-start:0;padding-inline-start:0}.navbar nav ul[role=list] *{flex-shrink:0}.navbar a{font-weight:700;text-decoration:none;padding-inline:.2em}.navbar a:focus,.navbar a:hover{text-decoration:underline}.navbar [aria-current=page]{position:relative}.navbar [aria-current=page]::after{width:100%;height:6px;content:"";display:block;position:absolute;bottom:calc(-1*var(--gap));background:currentcolor}.navbar.expanded [aria-current=page]::after{width:6px;height:100%;position:absolute;left:calc(-1*var(--gap));top:0}.permalink-anchor{display:none}:hover>.permalink-anchor{display:initial}button.iconbutton{border:0;background:0 0;color:currentcolor;padding:0;line-height:var(--rhythm);font-size:24px;width:24px;height:24px;display:inline-block;text-align:center;border-radius:50%;transition:font-weight .2s ease-in-out}button.iconbutton:focus-visible,button.iconbutton:hover{outline:1px solid var(--accent);outline-offset:6px}button.iconbutton:active{outline-offset:3px;background:0 0}button.iconbutton[aria-pressed=true]{box-shadow:none;transform:none}[role=tablist]{display:flex;gap:.5ch;scrollbar-width:thin}[role=tab][role=tab]{all:initial;font-family:var(--secondary-font);padding:0 calc(var(--rhythm)/4);margin:0;min-height:var(--rhythm);bottom:-1px;position:relative;color:var(--fg);border:solid var(--graphical-fg);border-width:1px;background:var(--interactive-bg);border-start-start-radius:.4em;border-start-end-radius:.4em}[role=tab][role=tab]:active,[role=tab][role=tab][aria-selected=true]{background:var(--box-bg);-webkit-border-after:1px solid transparent;border-block-end:1px solid transparent}[role=tab][role=tab]:hover{background-color:var(--box-bg);box-shadow:none}[role=tab][role=tab]:focus-visible{box-shadow:none;color:var(--accent);text-decoration:underline}[role=tabpanel]{-webkit-margin-before:0;margin-block-start:0;border-start-start-radius:0;border-start-end-radius:0;z-index:1}[role=menu]{position:absolute;z-index:10;padding:calc(var(--gap)/2) 0;margin:1px 0 0;display:flex;flex-flow:column nowrap}[role=menuitem]{padding:0 calc(var(--gap)/2);display:block;text-decoration:none;border-radius:0;color:var(--fg)}[role=menuitem]:active,[role=menuitem]:focus{background:var(--accent);color:var(--bg)}[role=listbox]{list-style:none}[role=listbox] [role=option]{margin-inline:calc(-1*var(--gap));padding-inline:var(--gap)}[role=listbox] [role=option][aria-selected=true]{background:var(--interactive-bg)}[role=listbox] .active[role=option]{--temporary-bg: var(--accent);--temporary-fg: var(--bg);--temporary-accent: parent-var(--muted-accent);--temporary-muted-accent: parent-var(--box-bg);background:var(--temporary-bg);color:var(--temporary-fg)}[role=listbox] .active[role=option]>*{--bg: var(--temporary-bg);--fg: var(--temporary-fg);--accent: var(--temporary-accent);--muted-accent: var(--temporary-muted-accent)}[aria-orientation=vertical]{flex-direction:column;width:-moz-fit-content;width:fit-content;text-align:center}.plain{--box-bg: var(--plain-bg);--accent: var(--plain-fg);--graphical-fg: var(--plain-graphical-fg)}.info{--box-bg: var(--info-bg);--accent: var(--info-fg);--graphical-fg: var(--info-graphical-fg)}.ok{--box-bg: var(--ok-bg);--accent: var(--ok-fg);--graphical-fg: var(--ok-graphical-fg)}.warn{--box-bg: var(--warn-bg);--accent: var(--warn-fg);--graphical-fg: var(--warn-graphical-fg)}.bad{--box-bg: var(--bad-bg);--accent: var(--bad-fg);--graphical-fg: var(--bad-graphical-fg)}.color{color:var(--accent)}.bg{background:var(--box-bg)}.border{border-style:solid;border-color:var(--graphical-fg)}:root{--fg: var(--gray-12);--muted-fg: var(--gray-10);--faded-fg: var(--gray-6);--graphical-fg: var(--plain-graphical-fg);--plain-fg: var(--blue-10);--info-fg: var(--blue-11);--ok-fg: var(--green-11);--bad-fg: var(--red-11);--warn-fg: var(--yellow-11);--plain-graphical-fg: var(--gray-6);--info-graphical-fg: var(--blue-6);--ok-graphical-fg: var(--green-6);--bad-graphical-fg: var(--red-6);--warn-graphical-fg: var(--yellow-6);--bg: var(--gray-0);--box-bg: var(--plain-bg);--interactive-bg: var(--gray-4);--plain-bg: var(--gray-1);--info-bg: var(--blue-1);--ok-bg: var(--green-1);--bad-bg: var(--red-1);--warn-bg: var(--yellow-1);--accent: var(--blue-10);--muted-accent: var(--blue-7);--rhythm: 1.4rem;--line-length: 40rem;--border-radius: .2rem;--main-font: 'Source Sans 3', 'Source Sans Pro', -apple-system, system-ui, sans-serif;--secondary-font: var(--main-font);--mono-font: 'M Plus Code Latin', monospace, monospace;--density: 1;--full-width: 100vw;--eff-line-length: /* Effective line length for prose. */
		min(
			calc( var(--full-width) - (2 * var(--rhythm)) ),
			var(--line-length)
		);--gutter-width: /* Width of spaces at each side of page content. */
		calc(
			(
				var(--full-width)        /* Viewport width */
				- var(--eff-line-length) /* minus line width */
			) / 2)}@media (prefers-color-scheme:dark){:root:not(.-no-dark-theme){--fg: var(--gray-0);--muted-fg: var(--gray-2);--faded-fg: var(--gray-7);--plain-bg: var(--gray-11);--info-bg: var(--blue-12);--ok-bg: var(--green-12);--bad-bg: var(--red-12);--warn-bg: var(--yellow-12);--plain-faded-fg: var(--blue-6);--info-faded-fg: var(--blue-6);--ok-faded-fg: var(--green-6);--bad-faded-fg: var(--red-6);--warn-faded-fg: var(--yellow-6);--bg: var(--gray-12);--box-bg: var(--gray-10);--interactive-bg: var(--gray-8);--plain-fg: (--blue-3);--info-fg: var(--blue-3);--ok-fg: var(--green-3);--bad-fg: var(--red-3);--warn-fg: var(--yellow-3);--accent: var(--blue-3);--muted-accent: var(--blue-5)}}*{--gap: calc(var(--rhythm) * var(--density));accent-color:var(--accent)}.textcolumns{--col-width: 30ch;column-width:var(--col-width);column-gap:var(--gap);margin-block:var(--gap)}.textcolumns :first-child{-webkit-margin-before:0!important;margin-block-start:0!important}.text-align\:center{text-align:center}.center{display:grid;place-items:center}.container{max-inline-size:var(--eff-line-length);margin-inline:auto}.fullbleed,.fullscreen{position:relative;left:50%;border-radius:0;border-inline:none}.fullbleed{width:var(--full-width);transform:translateX(calc(-.5*var(--full-width)))}.fullscreen{height:100vh;width:100vw;transform:translateX(-50vw)}.width\:100\%{width:100%;max-width:100%}.height\:100\%{height:100%;max-height:100%}:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:first-child:first-child:first-child:first-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:first-child>:first-child:first-child:first-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:first-child>:first-child>:first-child:first-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:first-child>:first-child>:first-child>:first-child{-webkit-margin-before:0;margin-block-start:0}:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:last-child:last-child:last-child:last-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:last-child>:last-child:last-child:last-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:last-child>:last-child>:last-child:last-child,:is(
    body,
    .box, 
    [role=menu],
    .sidebar-layout > header,
    [role=tabpanel],
    figure,
    details,
    dialog,
    aside,
    fieldset,
    dd,
    td,
    th
)>:last-child>:last-child>:last-child>:last-child{-webkit-margin-after:0;margin-block-end:0}.padding{padding-inline:var(--gap)}.padding-block{padding-block:var(--gap)}.padding-block-start{-webkit-padding-before:var(--gap);padding-block-start:var(--gap)}.padding-block-end{-webkit-padding-after:var(--gap);padding-block-end:var(--gap)}.padding-inline{padding-inline:var(--gap)}.padding-inline-end,.padding-inline-start{-webkit-padding-start:var(--gap);padding-inline-start:var(--gap)}.margin{margin:var(--gap)}.margin-block{margin-block:var(--gap)}.margin-block-start{-webkit-margin-before:var(--gap);margin-block-start:var(--gap)}.margin-block-end{-webkit-margin-after:var(--gap);margin-block-end:var(--gap)}.margin-inline{margin-inline:var(--gap)}.margin-inline-start{-webkit-margin-start:var(--gap);margin-inline-start:var(--gap)}.margin-inline-end{-webkit-margin-end:var(--gap);margin-inline-end:var(--gap)}.flow-gap>:not(:last-child){margin-bottom:1em}.inline{display:inline}.block{display:block}.contents{display:contents}.table{display:table;width:100%;margin:0}.row,.rows>*{display:table-row}.row:not(:last-child):not([specificity-hack])>*,.rows>:not(:last-child):not([specificity-hack])>*{margin-bottom:var(--gap)}.row>:not([specificity-hack]),.rows>*>:not([specificity-hack]){display:table-cell;vertical-align:top}.row>*+:not([specificity-hack]),:is(.rows > *)>*+:not([specificity-hack]){-webkit-margin-start:var(--gap);margin-inline-start:var(--gap);display:inline-block}.big{font-size:1.4em;line-height:calc(1.5*var(--rhythm))}.fixed{position:fixed}.sticky{position:sticky}.top{top:0}.right{right:0}.bottom{bottom:0}.left{left:0}.float\:left{float:left}.float\:right{float:right}.overflow\:auto{overflow:auto}.overflow\:scroll{overflow:scroll}.airy{--density: 3}.spacious{--density: 2}.dense{--density: 1}.crowded{--density: .5}.packed{--density: 0}.autodensity{--density: 1
}@media (min-width:768px){.autodensity{--density: 2 
}}@media (min-width:1024px){.autodensity{--density: 3 
}}.vh,v-h{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);block-size:1px;inline-size:1px;overflow:hidden;white-space:nowrap}.all\:initial{all:initial}.bold{font-weight:700}.italic{font-style:italic}.allcaps{text-transform:uppercase;letter-spacing:.1rem}.primary-font{font-family:var(--primary-font)}.secondary-font{font-family:var(--secondary-font)}.display-font{font-family:var(--display-font)}.mono-font,.monospace{font-family:var(--mono-font)}.massivetext{font-size:calc(.13*var(--eff-line-length));line-height:1em;letter-spacing:0}.aestheticbreak{display:block;margin:0;padding:0;height:calc(.5*var(--gap))}.f-row{display:flex;flex-direction:row;gap:var(--gap)}.f-row>*{margin:0}.f-col{display:flex;flex-direction:column;gap:var(--gap)}.f-col>*{margin:0}.f-switch{display:flex;flex-wrap:wrap;gap:var(--gap);--f-switch-threshold: 55ch
}.f-switch>*{margin:0;flex-grow:1;flex-basis:calc((var(--f-switch-threshold) - 100%)*999)}.justify-content\:start{justify-content:start}.justify-content\:end{justify-content:end}.justify-content\:baseline{justify-content:baseline}.justify-content\:center{justify-content:center}.justify-content\:stretch{justify-content:stretch}.justify-content\:space-between{justify-content:space-between}.justify-content\:space-around{justify-content:space-around}.justify-content\:space-evenly{justify-content:space-evenly}.align-items\:start{align-items:start}.align-items\:end{align-items:end}.align-items\:baseline{align-items:baseline}.align-items\:center{align-items:center}.align-items\:stretch{align-items:stretch}.align-self\:start{align-self:start}.align-self\:end{align-self:end}.align-self\:baseline{align-self:baseline}.align-self\:center{align-self:center}.align-self\:stretch{align-self:stretch}.flex-grow\:0{flex-grow:0}.flex-grow\:1{flex-grow:1}.flex-grow\:2{flex-grow:2}.flex-grow\:3{flex-grow:3}.flex-grow\:4{flex-grow:4}.flex-grow\:5{flex-grow:5}.flex-grow\:6{flex-grow:6}.flex-grow\:7{flex-grow:7}.flex-grow\:8{flex-grow:8}.flex-grow\:9{flex-grow:9}.flex-grow\:10{flex-grow:10}.flex-grow\:11{flex-grow:11}.flex-grow\:12{flex-grow:12}.flex-wrap\:wrap{flex-wrap:wrap}.flex-wrap\:nowrap{flex-wrap:nowrap}.grid{display:grid;grid-auto-columns:var(--grid-col-width, 1fr);grid-auto-rows:var(--grid-row-width, auto);gap:var(--gap)}.grid>*{margin:0}.grid-even-rows{--grid-row-width: 1fr}.grid-variable-cols{--grid-column-width: auto}[data-cols^="1 "]{grid-column-start:1}[data-cols$=" 1"]{grid-column-end:2}[data-cols="1"]{grid-column:1}[data-cols^="2 "]{grid-column-start:2}[data-cols$=" 2"]{grid-column-end:3}[data-cols="2"]{grid-column:2}[data-cols^="3 "]{grid-column-start:3}[data-cols$=" 3"]{grid-column-end:4}[data-cols="3"]{grid-column:3}[data-cols^="4 "]{grid-column-start:4}[data-cols$=" 4"]{grid-column-end:5}[data-cols="4"]{grid-column:4}[data-cols^="5 "]{grid-column-start:5}[data-cols$=" 5"]{grid-column-end:6}[data-cols="5"]{grid-column:5}[data-cols^="6 "]{grid-column-start:6}[data-cols$=" 6"]{grid-column-end:7}[data-cols="6"]{grid-column:6}[data-cols^="7 "]{grid-column-start:7}[data-cols$=" 7"]{grid-column-end:8}[data-cols="7"]{grid-column:7}[data-cols^="8 "]{grid-column-start:8}[data-cols$=" 8"]{grid-column-end:9}[data-cols="8"]{grid-column:8}[data-cols^="9 "]{grid-column-start:9}[data-cols$=" 9"]{grid-column-end:10}[data-cols="9"]{grid-column:9}[data-cols^="10 "]{grid-column-start:10}[data-cols$=" 10"]{grid-column-end:11}[data-cols="10"]{grid-column:10}[data-cols^="11 "]{grid-column-start:11}[data-cols$=" 11"]{grid-column-end:12}[data-cols="11"]{grid-column:11}[data-cols^="12 "]{grid-column-start:12}[data-cols$=" 12"]{grid-column-end:13}[data-cols="12"]{grid-column:12}[data-rows^="1 "]{grid-row-start:1}[data-rows$=" 1"]{grid-row-end:2}[data-rows="1"]{grid-row:1}[data-rows^="2 "]{grid-row-start:2}[data-rows$=" 2"]{grid-row-end:3}[data-rows="2"]{grid-row:2}[data-rows^="3 "]{grid-row-start:3}[data-rows$=" 3"]{grid-row-end:4}[data-rows="3"]{grid-row:3}[data-rows^="4 "]{grid-row-start:4}[data-rows$=" 4"]{grid-row-end:5}[data-rows="4"]{grid-row:4}[data-rows^="5 "]{grid-row-start:5}[data-rows$=" 5"]{grid-row-end:6}[data-rows="5"]{grid-row:5}[data-rows^="6 "]{grid-row-start:6}[data-rows$=" 6"]{grid-row-end:7}[data-rows="6"]{grid-row:6}[data-rows^="7 "]{grid-row-start:7}[data-rows$=" 7"]{grid-row-end:8}[data-rows="7"]{grid-row:7}[data-rows^="8 "]{grid-row-start:8}[data-rows$=" 8"]{grid-row-end:9}[data-rows="8"]{grid-row:8}[data-rows^="9 "]{grid-row-start:9}[data-rows$=" 9"]{grid-row-end:10}[data-rows="9"]{grid-row:9}[data-rows^="10 "]{grid-row-start:10}[data-rows$=" 10"]{grid-row-end:11}[data-rows="10"]{grid-row:10}[data-rows^="11 "]{grid-row-start:11}[data-rows$=" 11"]{grid-row-end:12}[data-rows="11"]{grid-row:11}[data-rows^="12 "]{grid-row-start:12}[data-rows$=" 12"]{grid-row-end:13}[data-rows="12"]{grid-row:12}@media (max-width:768px){[data-cols\@s^="1 "]{grid-column-start:1}[data-cols\@s$=" 1"]{grid-column-end:2}[data-cols\@s="1"]{grid-column:1}[data-cols\@s^="2 "]{grid-column-start:2}[data-cols\@s$=" 2"]{grid-column-end:3}[data-cols\@s="2"]{grid-column:2}[data-cols\@s^="3 "]{grid-column-start:3}[data-cols\@s$=" 3"]{grid-column-end:4}[data-cols\@s="3"]{grid-column:3}[data-cols\@s^="4 "]{grid-column-start:4}[data-cols\@s$=" 4"]{grid-column-end:5}[data-cols\@s="4"]{grid-column:4}[data-cols\@s^="5 "]{grid-column-start:5}[data-cols\@s$=" 5"]{grid-column-end:6}[data-cols\@s="5"]{grid-column:5}[data-cols\@s^="6 "]{grid-column-start:6}[data-cols\@s$=" 6"]{grid-column-end:7}[data-cols\@s="6"]{grid-column:6}[data-cols\@s^="7 "]{grid-column-start:7}[data-cols\@s$=" 7"]{grid-column-end:8}[data-cols\@s="7"]{grid-column:7}[data-cols\@s^="8 "]{grid-column-start:8}[data-cols\@s$=" 8"]{grid-column-end:9}[data-cols\@s="8"]{grid-column:8}[data-cols\@s^="9 "]{grid-column-start:9}[data-cols\@s$=" 9"]{grid-column-end:10}[data-cols\@s="9"]{grid-column:9}[data-cols\@s^="10 "]{grid-column-start:10}[data-cols\@s$=" 10"]{grid-column-end:11}[data-cols\@s="10"]{grid-column:10}[data-cols\@s^="11 "]{grid-column-start:11}[data-cols\@s$=" 11"]{grid-column-end:12}[data-cols\@s="11"]{grid-column:11}[data-cols\@s^="12 "]{grid-column-start:12}[data-cols\@s$=" 12"]{grid-column-end:13}[data-cols\@s="12"]{grid-column:12}[data-rows\@s^="1 "]{grid-row-start:1}[data-rows\@s$=" 1"]{grid-row-end:2}[data-rows\@s="1"]{grid-row:1}[data-rows\@s^="2 "]{grid-row-start:2}[data-rows\@s$=" 2"]{grid-row-end:3}[data-rows\@s="2"]{grid-row:2}[data-rows\@s^="3 "]{grid-row-start:3}[data-rows\@s$=" 3"]{grid-row-end:4}[data-rows\@s="3"]{grid-row:3}[data-rows\@s^="4 "]{grid-row-start:4}[data-rows\@s$=" 4"]{grid-row-end:5}[data-rows\@s="4"]{grid-row:4}[data-rows\@s^="5 "]{grid-row-start:5}[data-rows\@s$=" 5"]{grid-row-end:6}[data-rows\@s="5"]{grid-row:5}[data-rows\@s^="6 "]{grid-row-start:6}[data-rows\@s$=" 6"]{grid-row-end:7}[data-rows\@s="6"]{grid-row:6}[data-rows\@s^="7 "]{grid-row-start:7}[data-rows\@s$=" 7"]{grid-row-end:8}[data-rows\@s="7"]{grid-row:7}[data-rows\@s^="8 "]{grid-row-start:8}[data-rows\@s$=" 8"]{grid-row-end:9}[data-rows\@s="8"]{grid-row:8}[data-rows\@s^="9 "]{grid-row-start:9}[data-rows\@s$=" 9"]{grid-row-end:10}[data-rows\@s="9"]{grid-row:9}[data-rows\@s^="10 "]{grid-row-start:10}[data-rows\@s$=" 10"]{grid-row-end:11}[data-rows\@s="10"]{grid-row:10}[data-rows\@s^="11 "]{grid-row-start:11}[data-rows\@s$=" 11"]{grid-row-end:12}[data-rows\@s="11"]{grid-row:11}[data-rows\@s^="12 "]{grid-row-start:12}[data-rows\@s$=" 12"]{grid-row-end:13}[data-rows\@s="12"]{grid-row:12}}@media (min-width:1024px){[data-cols\@l^="1 "]{grid-column-start:1}[data-cols\@l$=" 1"]{grid-column-end:2}[data-cols\@l="1"]{grid-column:1}[data-cols\@l^="2 "]{grid-column-start:2}[data-cols\@l$=" 2"]{grid-column-end:3}[data-cols\@l="2"]{grid-column:2}[data-cols\@l^="3 "]{grid-column-start:3}[data-cols\@l$=" 3"]{grid-column-end:4}[data-cols\@l="3"]{grid-column:3}[data-cols\@l^="4 "]{grid-column-start:4}[data-cols\@l$=" 4"]{grid-column-end:5}[data-cols\@l="4"]{grid-column:4}[data-cols\@l^="5 "]{grid-column-start:5}[data-cols\@l$=" 5"]{grid-column-end:6}[data-cols\@l="5"]{grid-column:5}[data-cols\@l^="6 "]{grid-column-start:6}[data-cols\@l$=" 6"]{grid-column-end:7}[data-cols\@l="6"]{grid-column:6}[data-cols\@l^="7 "]{grid-column-start:7}[data-cols\@l$=" 7"]{grid-column-end:8}[data-cols\@l="7"]{grid-column:7}[data-cols\@l^="8 "]{grid-column-start:8}[data-cols\@l$=" 8"]{grid-column-end:9}[data-cols\@l="8"]{grid-column:8}[data-cols\@l^="9 "]{grid-column-start:9}[data-cols\@l$=" 9"]{grid-column-end:10}[data-cols\@l="9"]{grid-column:9}[data-cols\@l^="10 "]{grid-column-start:10}[data-cols\@l$=" 10"]{grid-column-end:11}[data-cols\@l="10"]{grid-column:10}[data-cols\@l^="11 "]{grid-column-start:11}[data-cols\@l$=" 11"]{grid-column-end:12}[data-cols\@l="11"]{grid-column:11}[data-cols\@l^="12 "]{grid-column-start:12}[data-cols\@l$=" 12"]{grid-column-end:13}[data-cols\@l="12"]{grid-column:12}[data-rows\@l^="1 "]{grid-row-start:1}[data-rows\@l$=" 1"]{grid-row-end:2}[data-rows\@l="1"]{grid-row:1}[data-rows\@l^="2 "]{grid-row-start:2}[data-rows\@l$=" 2"]{grid-row-end:3}[data-rows\@l="2"]{grid-row:2}[data-rows\@l^="3 "]{grid-row-start:3}[data-rows\@l$=" 3"]{grid-row-end:4}[data-rows\@l="3"]{grid-row:3}[data-rows\@l^="4 "]{grid-row-start:4}[data-rows\@l$=" 4"]{grid-row-end:5}[data-rows\@l="4"]{grid-row:4}[data-rows\@l^="5 "]{grid-row-start:5}[data-rows\@l$=" 5"]{grid-row-end:6}[data-rows\@l="5"]{grid-row:5}[data-rows\@l^="6 "]{grid-row-start:6}[data-rows\@l$=" 6"]{grid-row-end:7}[data-rows\@l="6"]{grid-row:6}[data-rows\@l^="7 "]{grid-row-start:7}[data-rows\@l$=" 7"]{grid-row-end:8}[data-rows\@l="7"]{grid-row:7}[data-rows\@l^="8 "]{grid-row-start:8}[data-rows\@l$=" 8"]{grid-row-end:9}[data-rows\@l="8"]{grid-row:8}[data-rows\@l^="9 "]{grid-row-start:9}[data-rows\@l$=" 9"]{grid-row-end:10}[data-rows\@l="9"]{grid-row:9}[data-rows\@l^="10 "]{grid-row-start:10}[data-rows\@l$=" 10"]{grid-row-end:11}[data-rows\@l="10"]{grid-row:10}[data-rows\@l^="11 "]{grid-row-start:11}[data-rows\@l$=" 11"]{grid-row-end:12}[data-rows\@l="11"]{grid-row:11}[data-rows\@l^="12 "]{grid-row-start:12}[data-rows\@l$=" 12"]{grid-row-end:13}[data-rows\@l="12"]{grid-row:12}}
@page {
    size: 8.25in 11in;
    margin: 1in 1.1in 1in 1.1in;

    @footnote {
        float: bottom;
        border-top: 1px solid var(--faded-fg);
    }
}

@page :left {
    @top-left {
        font-family: var(--secondary-font);
        content: counter(page);
    }
}

@page :right {
    @top-right {
        font-family: var(--secondary-font);
        content: counter(page);
    }
}

@page :empty {
    @top-right {
        content: '';
    }
    @top-left {
        content: '';
    }
}

@page :nth(1) {
    @top-right {
        content: '';
    }
    @top-left {
        content: '';
    }
}

:root {
    --main-font: 'Andada Pro', 'Noto Serif', serif;
    --secondary-font: 'Alegreya Sans', sans-serif;
    --display-font: 'ChicagoFLF';
    --mono-font: 'Berkeley Mono Variable';

    hyphens: auto;
    -webkit-hyphens: auto;
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--display-font);
    page-break-after: avoid;
}

pre {
    font-size: .8em;
}

code:not(pre code) {
    font-size: .8em;
}

.language-asciiart {
    line-height: 1;
}

h1:not(.massivetext) {
    margin-top: 60%;
    page-break-after: always;
    page-break-before: right;
}

h2 {
    margin-top: 20%;
    page-break-before: right;
}

.cover {
    page: title;
    page-break-after: always;
}

.attribution {
    padding-inline-start: var(--gap);
    page-break-before: avoid;
}

.footnote {
    float: footnote;
    font-size: .8em;
}

[data-footnote-call]::after {
    content: counter(footnote, symbols('*', '†', '‡', '§'));
}

.pagedjs_area a[data-footnote-call] {
    cursor: pointer;
}

[data-footnote-marker]::after {
    content: counter(footnote, symbols('*', '†', '‡', '§')) '.';
}

.pagedjs_page {
    counter-reset: footnote;
}

a {
    color: currentColor;
    font: inherit;
    text-decoration: inherit;
}

p {
    text-align: justify;
}

.sect1 { page-break-before: always; }

.title {
    font-family: var(--secondary-font);
}

pre {
    overflow: visible;
    white-space: pre-wrap;
}

.title:last-child { page-break-before: avoid; }
.title:first-child { page-break-after: avoid; }
</style>
    </head>
    <body>
    <div id="cover">
    <h1 class="massivetext italic allcaps">Hypermedia Systems</h1>
    <p class="secondary-font">Adam Stepinski, Carson Gross, Deniz Akşimşek</p>
    </div>
    <h1 id="_hypermedia_concepts" class="sect0">Hypermedia Concepts</h1>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a book about building applications using hypermedia systems.  <em>Hypermedia systems</em> might seem like a strange phrase:
how is hypermedia a <em>system</em>? Isn&#8217;t hypermedia just a way to link documents together?</p>
</div>
<div class="paragraph">
<p>Like with HTML, on the World Wide Web?</p>
</div>
<div class="paragraph">
<p>What do you mean hypermedia <em>systems</em>?</p>
</div>
<div class="paragraph">
<p>Well, yes, HTML is <em>a</em> hypermedia.  But there is more to the way the web works than just HTML:  HTTP, the Hyper Text
Transfer Protocol, is what transfers HTML from servers to clients, and there are many details and features associated
with it: caching, various headers, response codes, and so forth.</p>
</div>
<div class="paragraph">
<p>And then, of course, there are <em>hypermedia servers</em>, which present <em>hypermedia APIs</em> (yes, <em>APIs</em>) to clients over the network.</p>
</div>
<div class="paragraph">
<p>And, finally, there is the all-important <em>hypermedia client</em>: a software client that understands how to render a <em>hypermedia
response</em> intelligibly to a human, so that a human can interact with the remote system.  The most widely known and used
hypermedia clients are, of course, web browsers.</p>
</div>
<div class="paragraph">
<p>Web browsers are perhaps the most sophisticated pieces of software we use.  They not only understand HTML, CSS and many
other file formats, but they also provide a JavaScript runtime and programming environment that is so powerful that web
developers can create entire applications in it that are nearly as sophisticated as <em>thick clients</em>, that is, native
applications.</p>
</div>
<div class="paragraph">
<p>This JavaScript runtime is so powerful, in fact, that today many developers ignore the <em>hypermedia</em> features of the
browser, in favor of building their web applications entirely in JavaScript.  Applications built in this manner have come
to be called Single Page Applications (SPAs).  Rather than navigating between pages, these web applications use
JavaScript for updating the user interface directly.  When they communicate with a server, these applications
typically use JSON API calls via AJAX.  And they often update the user interface using a &#8220;reactive&#8221; style front-end
JavaScript library.</p>
</div>
<div class="paragraph">
<p>In these applications HTML becomes a (somewhat awkward) graphical interface description language that is used
because, for historical reasons, that&#8217;s what happens to be there, in the browser.</p>
</div>
<div class="paragraph">
<p>Applications built in this style are not <em>hypermedia driven</em>: they do not take advantage of the underlying hypermedia
system of the web.</p>
</div>
<div class="paragraph">
<p>To explain what a hypermedia driven application looks like, and to contrast it with the popular SPA approach of today,
we need to first explore the entire <em>hypermedia system</em> of the web, beyond just discussing HTML.  We need to look at the
<em>network architecture</em> of the original web, including how a web server delivers a hypermedia API, and how to effectively
use the hypermedia features available in the hypermedia <em>client</em> (e.g. the browser).</p>
</div>
<div class="paragraph">
<p>Each of these are important aspects of building an effective hypermedia driven application, and it is the entire
<em>hypermedia system</em> that comes together to make hypermedia such a powerful architecture.</p>
</div>
<h3 id="_what_is_a_hypermedia_system" class="discrete">What is a Hypermedia System?</h3>
<div class="paragraph">
<p>To understand what a hypermedia system is we&#8217;ll first take an in-depth look at <em>the</em> canonical hypermedia system: the
World Wide Web.  Roy Fielding, an engineer who helped create specifications and build the
implementations of many early pieces of the web, gave us the term REpresentational State Transfer, or REST.
In his PhD dissertation he described REST as a <em>network architecture</em>, and he contrasted it with earlier approaches to building
distributed software.</p>
</div>
<div class="paragraph">
<p>We define a <em>hypermedia system</em> as a system that adheres to the RESTful network architecture in Fielding&#8217;s <em>original</em>
sense of this term.</p>
</div>
<div class="paragraph">
<p>Unfortunately, today, you probably associate the term "REST" with JSON APIs, since that is where the term is typically
used in industry.  This is a misapplied use of the term REST because JSON is not a <em>natural</em> hypermedia due to the absense of
hypermedia controls. The exhange of hypermedia is an explicit requirement for a system to be considered "RESTful."
It is a long story how we got here, using the term REST so incorrectly, and we will go into the details later in this book.
But, for now, if you currently think "REST == JSON", please try to set that understanding aside while reading this book,
and come to the concept with fresh eyes.</p>
</div>
<div class="paragraph">
<p>It is important to understand that, in his dissertation, Fielding was describing The World Wide Web as it existed in the
late 1990s.  The web, at that point, was simply web browsers exchanging hypermedia.  That system, with its simple links
and forms, was what Fielding was calling RESTful.</p>
</div>
<div class="paragraph">
<p>JSON APIs were a decade away from becoming a common tool in web development: REST was about <em>hypermedia</em> and <em>the Web 1.0</em>.</p>
</div>
<h3 id="_hypermedia_driven_applications" class="discrete">Hypermedia-Driven Applications</h3>
<div class="paragraph">
<p>In this book we are going to take a look at hypermedia as a <em>system architecture</em> and then explore some practical,
<em>modern</em> approaches to building web applications using it.  We will call applications built in this style
<em>Hypermedia-Driven Applications</em>, or HDAs, and we contrast them with a popular style in use today, the Single Page
Application.</p>
</div>
<div class="paragraph">
<p>A Hypermedia-Driven Application is an application built on top of a hypermedia system that respects and utilizes the
hypermedia functionality of that underlying system.</p>
</div>
<h3 id="_goals" class="discrete">Goals</h3>
<div class="paragraph">
<p>The goal of this book is to give you a strong sense of how the RESTful, hypermedia system architecture <em>differs</em> from
other client-server systems, and what the strengths (and weaknesses) of the hypermedia approach are.  Further, we hope
to convince you that the hypermedia architecture is <em>relevant</em> to developers building modern web applications.</p>
</div>
<div class="paragraph">
<p>We aim to give you the tools to evaluate the requirements for an application and  answer the question:</p>
</div>
<div class="paragraph">
<p>&#8220;Could I build this as a Hypermedia-Driven Application?&#8221;</p>
</div>
<div class="paragraph">
<p>We hope that for many applications the answer to that question will be &#8220;Yes!&#8221;</p>
</div>
<h3 id="_book_layout" class="discrete">Book Layout</h3>
<div class="paragraph">
<p>The book is broken into three parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An introduction (or re-introduction) to hypermedia, with a particular focus on HTML and HTTP.  We will finish this
review of core hypermedia concepts by creating a simple "Web 1.0"-style application, Contact.app, for managing contacts.</p>
</li>
<li>
<p>Next we will look at how we can use <a href="https://htmx.org">htmx</a>, a hypermedia-oriented JavaScript library created by the
authors of this book, to improve Contact.app.  By using htmx, we will be able to achieve a level of interactivity in our
application that many developers would expect to require a large, sophisticated front end library, such as React.
Thanks to htmx, we will be able to do this <em>without</em> abandoning hypermedia as a system architecture.</p>
</li>
<li>
<p>Finally, we will look at a completely different hypermedia system, Hyperview.  Hyperview is a <em>mobile</em> hypermedia system, related to, but distinct from the web and created by one of the authors of this book&#8201;&#8212;&#8201;Adam Stepinski.  It supports <em>mobile specific</em> features by providing not only a mobile specific hypermedia, but also a mobile hypermedia client, a network protocol and so on.  It provides a full <em>mobile hypermedia system</em> for you to build your mobile application with, and, in doing so, makes it possible to build mobile Hypermedia-Driven Applications.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that each section is <em>somewhat</em> independent of the others.  If you already know hypermedia in-depth and how basic Web
1.0 applications function, you may want to skip ahead to the second section on htmx and how to build modern web applications
using hypermedia.  Similarly, if you are well versed in htmx and want to dive into a novel <em>mobile</em> hypermedia,
you can skip ahead to the Hyperview section.</p>
</div>
<div class="paragraph">
<p>That being said, the book is designed to be read in order and both the htmx and Hyperview sections build on the Web 1.0
application described at the end of the first section.  Furthermore, even if you <em>are</em> well versed in all the concepts
of hypermedia and details of HTML &amp; HTTP, it is likely worth it to at least skim through the first few chapters for
a refresher.</p>
</div>
<h3 id="_hypermedia_a_new_generation" class="discrete">Hypermedia: A New Generation</h3>
<div class="paragraph">
<p>Hypermedia isn&#8217;t a frequent topic of discussion these days.  Even many older programmers who grew up with the web
in the late 1990s and early 2000s haven&#8217;t thought much about these ideas in years.  Many younger web developers have
grown up knowing nothing but Single Page Applications and the frameworks that are used to build them.</p>
</div>
<div class="paragraph">
<p>In particular, many young web developers began their careers by building React.js applications that interact with a Node server using a
JSON API; they may never have learned about hypermedia as a system at all.</p>
</div>
<div class="paragraph">
<p>This is a tragedy, and, frankly, a failure on the part of the thought leaders in the web development community to properly
communicate and advocate for the hypermedia approach.</p>
</div>
<div class="paragraph">
<p>Hypermedia was a great idea!  It still is!</p>
</div>
<div class="paragraph">
<p>By the end of this book, you will have the tools and the <em>language</em> to put this great idea to work in your own
applications.  And, further, you will be able to bring the ideas and concepts of hypermedia systems
to the broader web development community.</p>
</div>
<div class="paragraph">
<p>Hypermedia can compete, hypermedia <em>can win</em>, hypermedia <em>has won</em> as an architectural choice against the Single
Page Application approach, but <em>only</em> if smart people (like you) learn about it, build with it and then tell the world
about it.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Remember the message? “The future is not set. There is no fate but what we make for ourselves.”</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Kyle Reese<br>
<cite>Terminator 2: Judgement Day</cite>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hypermedia_a_reintroduction">1. Hypermedia: A Reintroduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hypermedia is a universal technology today, almost as common as electricity.</p>
</div>
<div class="paragraph">
<p>Billions of people use hypermedia-based systems every day, mainly by interacting with the <em>Hypertext Markup Language
(HTML)</em>  being exchanged via the <em>Hypertext Transfer Protocol (HTTP)</em> by using a web browser connected to the World Wide Web.</p>
</div>
<div class="paragraph">
<p>People use these systems to get their news, check in on friends, buy things online, play games, send emails and so
forth: the variety and sheer number of online services being delivered by hypermedia is truly astonishing.</p>
</div>
<div class="paragraph">
<p>And yet, despite this ubiquity, the topic of hypermedia itself is a strangely under-explored concept today, left mainly to
specialists.  Yes, you can find a lot of tutorials on how to author HTML, create links and forms, etc.  But it is rare
to see a discussion of HTML <em>as a hypermedia</em> and, more broadly, on how an entire hypermedia <em>system</em> fits together.</p>
</div>
<div class="paragraph">
<p>This is in contrast with the early web development era when concepts like <em>Representational State Transfer (REST)</em>
and <em>Hypermedia As The Engine of Application State (HATEOAS)</em> were discussed frequently, refined and debated among
web developers.</p>
</div>
<div class="paragraph">
<p>In a sad turn of events, today, the world&#8217;s most popular hypermedia, HTML, is often viewed resentfully: it is an
awkward, legacy markup language that must be grudgingly used to build user interfaces in what are
increasingly entirely JavaScript-based web applications.</p>
</div>
<div class="paragraph">
<p>HTML happens to be there, in the browser, and so we have to use it.</p>
</div>
<div class="paragraph">
<p>This is a shame and we hope to convince you that hypermedia is <em>not</em> simply a
piece of legacy technology that we have to accept and deal with.  Instead, we aim to show you that hypermedia is a
tremendously innovative, simple and <em>flexible</em> way to build robust applications: <em>Hypermedia-Driven Applications</em>.</p>
</div>
<div class="paragraph">
<p>We hope that by the end of this book you will feel, as we do, that the hypermedia approach deserves a seat at the table
when you, a web developer, are considering the architecture of your next application.  Creating a Hypermedia-Driven
Application on top of a  <em>hypermedia system</em> like the web is a viable and, indeed, often excellent choice for
<em>modern</em> web applications.</p>
</div>
<div class="paragraph">
<p>(And, as the section on Hyperview will show, not just web applications.)</p>
</div>
<div class="sect2">
<h3 id="_what_is_hypermedia">1.1. What Is Hypermedia?</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Hypertexts: new forms of writing, appearing on computer screens, that will branch or perform at the reader’s
command. A hypertext is a non-sequential piece of writing; only the computer display makes it practical.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Ted Nelson<br>
<cite>https://archive.org/details/SelectedPapers1977/page/n7/mode/2up</cite>
</div>
</div>
<div class="paragraph">
<p>Let us begin at the beginning: what is hypermedia?</p>
</div>
<div class="paragraph">
<p>Hypermedia is a media, for example a text, that includes <em>non-linear branching</em> from one location in the media to another,
via, for example, hyperlinks embedded in the media. The prefix &#8220;hyper-&#8221; derives from the Greek prefix &#8220;ὑπερ-&#8221; which
means &#8220;beyond&#8221; or &#8220;over&#8221;, indicating that hypermedia <em>goes beyond</em> normal, passively consumed media like magazines and
newspapers.</p>
</div>
<div class="paragraph">
<p>Hyperlinks are a canonical example of what is called a <em>hypermedia control</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Hypermedia Control</dt>
<dd>
<p>A <em>hypermedia control</em> is an element in a hypermedia that describes (or controls) some sort of
interaction, often with a remote server, by encoding information about that interaction directly and completely within
itself.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Hypermedia controls are what differentiate hypermedia from other sorts of media.</p>
</div>
<div class="paragraph">
<p>You may be more familiar with the term <em>hypertext</em>, from whose Wikipedia page the above quote is taken.  Hypertext
is a sub-category of hypermedia and much of this book is going to discuss how to build modern applications using
hypertexts such as  HTML, the Hypertext Markup Language, or HXML, a hypertext used by the Hyperview mobile hypermedia
system.</p>
</div>
<div class="paragraph">
<p>Hypertexts like HTML function alongside other technologies crucial for making an entire hypermedia system work: network
protocols like HTTP, other media types such as images, videos, hypermedia servers (i.e. servers providing hypermedia APIs),
sophisticated hypermedia clients (e.g. web browsers), and so on.</p>
</div>
<div class="paragraph">
<p>Because of this, we prefer the broader term <em>hypermedia systems</em> when describing the underlying architecture of
applications built using hypertext, to emphasize the system architecture over the particular hypermedia being used.</p>
</div>
<div class="paragraph">
<p>It is the entire hypermedia <em>system architecture</em> that is underappreciated and ignored by many modern web developers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_brief_history_of_hypermedia">1.2. A Brief History of Hypermedia</h3>
<div class="paragraph">
<p>Where did the idea of hypermedia come from?</p>
</div>
<div class="paragraph">
<p>While there were many precursors to the modern idea of hypertext and the more general hypermedia, many people point
to the 1945 article <em>As We May Think</em> written by Vannevar Bush in The Atlantic as a starting point for looking at what
has become modern hypermedia.</p>
</div>
<div class="paragraph">
<p>In this article Bush described a device called a Memex, which, using a complex mechanical system of reels and microfilm,
along with an encoding system, would allow users to jump between related frames of content.  The Memex was never actually
implemented, but it was an inspiration for later work on the idea of hypermedia.</p>
</div>
<div class="paragraph">
<p>The terms &#8220;hypertext&#8221; and &#8220;hypermedia&#8221; were coined in 1963 by Ted Nelson, who would go on to work on the <em>Hypertext Editing
System</em> at Brown University and who later created the <em>File Retrieval and Editing System (FRESS)</em>, a shockingly advanced
hypermedia system for its time.  (This was perhaps the first digital system to have a notion of &#8220;undo&#8221;.)</p>
</div>
<div class="paragraph">
<p>While Nelson was working on his ideas, Douglas Engelbart was busy at work at the Stanford Research Institute, explicitly
attempting to make Vannevar Bush&#8217;s Memex a reality.  In 1968, Englebart gave &#8220;The Mother of All Demos&#8221; in San Francisco,
California.</p>
</div>
<div class="paragraph">
<p>Englebart demonstrated an unbelievable amount of technology:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remote, collaborative text editing with his peers in Menlo Park.</p>
</li>
<li>
<p>Video and audio chat.</p>
</li>
<li>
<p>An integrated windowing system, with window resizing, etc.</p>
</li>
<li>
<p>A recognizable hypertext, whereby clicking on underlined text navigated to new content.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Despite receiving a standing ovation from a shocked audience after his talk, it was decades before the technologies
Englebart demonstrated became mainstream.</p>
</div>
<div class="sect3">
<h4 id="_modern_implementation">Modern Implementation</h4>
<div class="paragraph">
<p>In 1990, Tim Berners-Lee, working at CERN, published the first website.  He had been working on the idea of hypertext
for a decade and had finally, out of desperation at the fact it was so hard for researchers to share their research,
found the right moment and institutional support to create the World Wide Web:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Creating the web was really an act of desperation, because the situation without it was very difficult when I was working
at CERN later. Most of the technology involved in the web, like the hypertext, like the Internet, multifont text objects, had all
been designed already. I just had to put them together. It was a step of generalising, going to a higher level of abstraction,
thinking about all the documentation systems out there as being possibly part of a larger imaginary documentation system.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Tim Berners-Lee<br>
<cite>https://britishheritage.org/tim-berners-lee-the-world-wide-web</cite>
</div>
</div>
<div class="paragraph">
<p>By 1994 his creation was taking off so quickly that Berners-Lee founded the W3C, a working group of companies and researchers
tasked with improving the web.  All standards created by the W3C were royalty-free and could be adopted and implemented
by anyone, cementing the open, collaborative nature of the web.</p>
</div>
<div class="paragraph">
<p>In 2000, Roy Fielding, then at U.C. Irvine, published a seminal PhD dissertation on the web: &#8220;Architectural Styles and the
Design of Network-based Software Architectures.&#8221;  Fielding had been working on the open source Apache HTTP Server and
his thesis was a description of what he felt was a <em>new and distinct networking architecture</em> that had emerged in the early
web.  Fielding had worked on the initial HTTP specifications and, in the paper, defined the web&#8217;s hypermedia
network model using the term <em>REpresentational State Transfer (REST)</em>.</p>
</div>
<div class="paragraph">
<p>Fielding&#8217;s work became a major touchstone for early web developers, giving them a language to discuss the new technical
medium they were building applications in.</p>
</div>
<div class="paragraph">
<p>We will discuss Fielding&#8217;s key ideas in depth in Chapter 3, and try to correct the record with respect to REST,
HATEOAS and hypermedia.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_worlds_most_successful_hypertext_html">1.3. The World&#8217;s Most Successful Hypertext: HTML</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>In the beginning was the hyperlink, and the hyperlink was with the web, and the hyperlink was the web.  And it was good.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Rescuing REST From the API Winter<br>
<cite>https://intercoolerjs.org/2016/01/18/rescuing-rest.html</cite>
</div>
</div>
<div class="paragraph">
<p>The system that Berners-Lee, Fielding and many others had created revolved around a hypermedia: HTML.  HTML started as a read-only
hypermedia, used to publish (at first) academic documents.  These documents were linked together via anchor tags which
created <em>hyperlinks</em> between them, allowing users to quickly navigate between documents.</p>
</div>
<div class="paragraph">
<p>When HTML 2.0 was released, it introduced the notion of the <code>form</code> tag, joining the anchor tag (i.e. hyperlink) as a
second hypermedia control.  The introduction of the form tag made building <em>applications</em> on the web viable by providing
a mechanism for <em>updating</em> resources, rather than just reading them.</p>
</div>
<div class="paragraph">
<p>It was at this point that the web transitioned from an interesting document-oriented system to a compelling
<em>application architecture</em>.</p>
</div>
<div class="paragraph">
<p>Today HTML is the most widely used hypermedia in existence and this book naturally assumes that the reader has a
reasonable familiarity with it.  You do not need to be an HTML (or CSS) expert to understand the code in this book, but
the better you understand the core tags and concepts of HTML, the more you will get out of it.</p>
</div>
<div class="sect3">
<h4 id="_the_essence_of_html_as_a_hypermedia">The Essence of HTML as a Hypermedia</h4>
<div class="paragraph">
<p>Let us consider these two defining hypermedia elements (that is the two defining <em>hypermedia controls</em>) of HTML,
the anchor tag and the form tag, in a bit of detail.</p>
</div>
<div class="sect4">
<h5 id="_anchor_tags">Anchor Tags</h5>
<div class="paragraph">
<p>Anchor tags are so familiar as to be boring but, as the original hypermedia control, it is worth reviewing the mechanics
of hyperlinks to get our minds in the right place for developing a deeper understanding of hypermedia.</p>
</div>
<div class="paragraph">
<p>Consider a simple anchor tag, embedded within a larger HTML document:</p>
</div>
<div class="listingblock">
<div class="title">A Simple Hyperlink</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="https://hypermedia.systems/"&gt;
  Hypermedia Systems
&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An anchor tag consists of the tag itself, <code>&lt;a&gt;&lt;/a&gt;</code>, as well as the attributes and content within the tag.  Of particular
interest is the <code>href</code> attribute, which specifies a <em>hypertext reference</em> to another document or document fragment.  It
is this attribute that makes the anchor tag a hypermedia control.</p>
</div>
<div class="paragraph">
<p>In a typical web browser, this anchor tag would be interpreted to mean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Show the text &#8220;Hypermedia Systems&#8221; in a manner indicating that it is clickable.</p>
</li>
<li>
<p>When the user clicks on that text, issue an HTTP <code>GET</code> request to the URL <code><a href="https://hypermedia.systems/" class="bare">https://hypermedia.systems/</a></code>.</p>
</li>
<li>
<p>Take the HTML content in the body of the HTTP response to this request and replace the entire screen in the browser as a new
document, updating the navigation bar to this new URL.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Anchors provide the main mechanism we use to navigate around the web today, by selecting links to navigate from document
to document, or from resource to resource.</p>
</div>
<div class="paragraph">
<p>Here is what a user interaction with an anchor tag/hyperlink looks like in visual form:</p>
</div>
<div class="listingblock">
<div class="title">An HTTP GET In Action</div>
<div class="content">
<pre class="highlight"><code class="language-asciiart" data-lang="asciiart">┌────────────────────────┐   ┌─HTTP REQUEST────────────────┐
│ BROWSER              X │   │                             │
├────────────────────────┤   │ GET /                       │
│                        │   │ Host: hypermedia.systems    │
│ lorem ipsum dolor      │   └─────────────────────────────┘
│                        │
│ Hypermedia Systems ────────────────┐
│ ──────────────────     │           │
│ sit amet               │           │
│                        │           │
└────────────────────────┘           │
                              ┌──────▼──────┐
                              │   H T T P   │
                              │ S E R V E R │
                              └──────┬──────┘
┌────────────────────────┐           │
│ BROWSER              X │           │
├────────────────────────┤           │
│                        │           │
│ HYPERMEDIA SYSTEMS     ◀───────────┘
│                        │
│ The revolutionary      │   ┌─HTTP RESPONSE───────────────┐
│                        │   │                             │
│ ideas that empowered...│   │ 200 OK                      │
│                        │   │ ...                         │
└────────────────────────┘   │ &lt;h1&gt;Hypermedia Systems&lt;/h1&gt; │
                             │ ...                         │
                             └─────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the link is clicked the browser (or, as we sometimes refer to it, the <em>hypermedia client</em>) initiates an HTTP
<code>GET</code> request to the URL encoded in the link&#8217;s <code>href</code> attribute.</p>
</div>
<div class="paragraph">
<p>Note that the HTTP request includes additional data (i.e., <em>metadata</em>) on what, exactly, the browser wants from the server,
in the form of headers.  We will discuss these headers, and HTTP in more depth in Chapter 3.</p>
</div>
<div class="paragraph">
<p>The <em>hypermedia server</em> then responds to this request with a <em>hypermedia response</em>&#8201;&#8212;&#8201;the HTML&#8201;&#8212;&#8201;for the new page.
This may seem like a small and obvious point, but it is an absolutely crucial aspect of a truly RESTful <em>hypermedia
system</em>: the client and server must communicate via hypermedia!</p>
</div>
</div>
<div class="sect4">
<h5 id="_form_tags">Form Tags</h5>
<div class="paragraph">
<p>Anchor tags provide <em>navigation</em> between documents or resources, but don&#8217;t allow you to update those resources.  That functionality
falls to the form tag.</p>
</div>
<div class="paragraph">
<p>Here is a simple example of a form in HTML:</p>
</div>
<div id="listing-1-2" class="listingblock">
<div class="title">A Simple Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/signup" method="post"&gt;
  &lt;input type="text" name="email" placeholder="Enter Email To Sign Up..."/&gt;
  &lt;button&gt;Sign Up&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like an anchor tag, a form tag consists of the tag itself, <code>&lt;form&gt;&lt;/form&gt;</code>, combined with the attributes and
content within the tag.  Note that the form tag does not have an <code>href</code> attribute, but rather has an <code>action</code> attribute
that specifies where to issue an HTTP request.</p>
</div>
<div class="paragraph">
<p>Furthermore, it also has a <code>method</code> attribute, which specifies exactly which HTTP &#8220;method&#8221; to use.  In this example
the form is asking the browser to issue a <code>POST</code> request.</p>
</div>
<div class="paragraph">
<p>In contrast with anchor tags, the content and tags <em>within</em> a form can have an effect on the hypermedia interaction
that the form makes with a server.  The <em>values</em> of <code>input</code> tags and other tags such as <code>select</code> tags will be included
with the HTTP request when the form is submitted, as URL parameters in the case of a <code>GET</code> and as part of the request
body in the case of a <code>POST</code>.  This allows a form to include an arbitrary amount of information
collected from a user in a request, unlike the anchor tag.</p>
</div>
<div class="paragraph">
<p>In a typical browser this form tag and its contents would be interpreted by the browser roughly as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Show a text input and a &#8220;Sign Up&#8221; button to the user.</p>
</li>
<li>
<p>When the user submits the form by clicking the &#8220;Sign Up&#8221; button or by hitting the enter key while the input element is
focused, issue an HTTP <code>POST</code> request to the path <code>/signup</code> on the &#8220;current&#8221; server.</p>
</li>
<li>
<p>Take the HTML content in the body of the HTTP response body and replace the entire screen in the browser as a new
document, updating the navigation bar to this new URL.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This mechanism allows the user to issue requests to <em>update the state</em> of resources on the server.  Note that despite
this new type of request the communication between client and server is still done entirely with <em>hypermedia</em>.</p>
</div>
<div class="paragraph">
<p>It is the form tag that makes Hypermedia-Driven Applications possible.</p>
</div>
<div class="paragraph">
<p>If you are an experienced web developer you probably recognize that we are omitting a few details and complications
here.  For example, the response to a form submission often <em>redirects</em> the client to a different URL.</p>
</div>
<div class="paragraph">
<p>This is true, and we will get down into the muck with forms in more detail in later chapters but, for now, this simple
example suffices to demonstrate the core mechanism for updating system state purely within hypermedia.</p>
</div>
<div class="paragraph">
<p>Here is a diagram of the interaction:</p>
</div>
<div class="listingblock">
<div class="title">An HTTP POST In Action</div>
<div class="content">
<pre class="highlight"><code class="language-asciiart" data-lang="asciiart">┌────────────────────────┐   ┌─HTTP REQUEST────────────────┐
│ BROWSER              X │   │                             │
├────────────────────────┤   │ POST /sign-up               │
│                        │   │ Host: hypermedia.systems    │
│ SIGN UP                │   │ ...                         │
│ ┌────────────────────┐ │   │ email=joe@example.com       │
│ │ joe@example.com    │ │   └─────────────────────────────┘
│ └────────────────────┘ │
│ ┌─────────┐            │
│ │ Sign up │────────────────────────┐
│ └─────────┘            │           │
└────────────────────────┘           │
                              ┌──────▼──────┐
                              │   H T T P   │
                              │ S E R V E R │
                              └──────┬──────┘
┌────────────────────────┐           │
│ BROWSER              X │           │
├────────────────────────┤           │
│                        │           │
│ THANK YOU FOR SIGNING  ◀───────────┘
│ UP                     │
│                        │   ┌─HTTP RESPONSE───────────────┐
│                        │   │                             │
│                        │   │ 200 OK                      │
│                        │   │ ...                         │
└────────────────────────┘   │ &lt;h1&gt;Thank you for signing   │
                             │ up&lt;/h1&gt;                     │
                             └─────────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_web_1_0_applications">Web 1.0 Applications</h5>
<div class="paragraph">
<p>As someone interested in web development, the above diagrams and discussion are probably very familiar to you.  You may
even find this content boring.  But take a step back and consider the fact that these two hypermedia controls,
anchors and forms, are the <em>only</em> native ways for a user to interact with a server in plain HTML.</p>
</div>
<div class="paragraph">
<p>Only two tags!</p>
</div>
<div class="paragraph">
<p>And yet, armed with only these two tags, the early web was able to grow exponentially and offer a staggeringly large
amount of online, dynamic functionality to billions of people.</p>
</div>
<div class="paragraph">
<p>This is strong evidence of the power of hypermedia.  Even today, in a web development world increasingly dominated by large
JavaScript-centric front end frameworks, many people choose to use simple vanilla HTML to achieve their application goals
and are often perfectly happy with the results.</p>
</div>
<div class="paragraph">
<p>These two tags give a tremendous amount of expressive power to HTML.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_so_what_isnt_hypermedia">So What <em>Isn&#8217;t</em> Hypermedia?</h4>
<div class="paragraph">
<p>So links and forms are the two main hypermedia-based mechanisms for interacting with a server available in HTML.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s consider a different approach: let&#8217;s interact with a server by issuing an HTTP request via JavaScript.  To
do this, we will use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code></a> API, a popular API for
issuing an &#8220;Asynchronous JavaScript and XML,&#8221; or AJAX request, available in all modern web browsers:</p>
</div>
<div id="listing-1-3" class="listingblock">
<div class="title">JavaScript</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button onclick="fetch('/api/v1/contacts/1') <b class="conum">(1)</b>
                 .then(response =&gt; response.json()) <b class="conum">(2)</b>
                 .then(data =&gt; updateUI(data))"&gt; <b class="conum">(3)</b>
    Fetch Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue the request.</p>
</li>
<li>
<p>Convert the response to a JavaScript object.</p>
</li>
<li>
<p>Invoke the <code>updateUI()</code> function with the object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This button has an <code>onclick</code> attribute that specifies some JavaScript to run when the button is clicked.</p>
</div>
<div class="paragraph">
<p>The JavaScript will issue an AJAX HTTP <code>GET</code> request to <code>/api/v1/contacts/1</code> using <code>fetch()</code>.  An AJAX request is like a
&#8220;normal&#8221; HTTP request, but it is issued &#8220;behind the scenes&#8221; by the browser.  The user does not see a
request indicator from the browser as they would with normal links and forms. Additionally, unlike requests issued by those
hypermedia controls, it is up to the JavaScript code to handle the response from the server.</p>
</div>
<div class="paragraph">
<p>Despite AJAX having XML as part of its acronym, today the HTTP response to this request would almost certainly be in the
JavaScript Object Notation (JSON) format rather than XML.</p>
</div>
<div class="paragraph">
<p>An HTTP response to this request might look something like this:</p>
</div>
<div class="listingblock">
<div class="title">JSON</div>
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{ <b class="conum">(1)</b>
  "id": 42, <b class="conum">(2)</b>
  "email" : "json-example@example.org" <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The start of a JSON object.</p>
</li>
<li>
<p>A property, in this case with the name <code>id</code> and the value <code>42</code>.</p>
</li>
<li>
<p>Another property, the email of the contact with this id.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The JavaScript code above converts the JSON text received from the server into a JavaScript object by calling the
<code>json()</code> method on it.  This new JavaScript object object is then handed off to the <code>updateUI()</code> method.</p>
</div>
<div class="paragraph">
<p>The <code>updateUI()</code> method is responsible for updating the UI based on the data encoded in the JavaScript Object,
perhaps by displaying the contact in a bit of HTML generated via a client-side template in the JavaScript application.</p>
</div>
<div class="paragraph">
<p>The details of exactly what the <code>updateUI()</code> function does aren&#8217;t important for our discussion.</p>
</div>
<div class="paragraph">
<p>What <em>is</em> important, what is the <em>crucial</em> aspect of this JSON-based server interaction is that it is <em>not</em> using
hypermedia.  The JSON API being used here does not return a hypermedia response.  There are no <em>hyperlinks</em> or other
hypermedia-style controls in it.</p>
</div>
<div class="paragraph">
<p>This JSON API is, rather, a <em>Data API</em>.</p>
</div>
<div class="paragraph">
<p>Because the response is in JSON and is <em>not</em> hypermedia, the JavaScript <code>updateUI()</code> method must understand how to turn
this contact data into HTML.</p>
</div>
<div class="paragraph">
<p>In particular, the code in <code>updateUI()</code> needs to know about the <em>internal structure</em> and meaning of the data.</p>
</div>
<div class="paragraph">
<p>It needs to know:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exactly how the fields in the JSON data object are structured and named.</p>
</li>
<li>
<p>How they relate to one another.</p>
</li>
<li>
<p>How to update the local data this new data corresponds with.</p>
</li>
<li>
<p>How to render this data to the browser.</p>
</li>
<li>
<p>What additional actions/API end points can be called with this data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In short, the logic in <code>updateUI()</code> needs to have intimate knowledge of the API endpoint at <code>/api/v1/contact/1</code>, knowledge provided
via some side-channel beyond the response itself.  As a result, the <code>updateUI()</code> code and the
API have a strong relationship, known as <em>tight coupling</em>: if the format of the JSON response changes, then the code for <code>updateUI()</code> will almost certainly
also need to be changed.</p>
</div>
<div class="sect4">
<h5 id="_single_page_applications">Single Page Applications</h5>
<div class="paragraph">
<p>This bit of JavaScript, while very modest, is the organic beginnings of a much larger conceptual approach to building
web applications.  This is the beginning of a <em>Single Page Application (SPA)</em>.  The web application is no longer
navigating <em>between</em> pages using hypermedia controls as was the case with links and forms.</p>
</div>
<div class="paragraph">
<p>Instead, the application is exchanging <em>plain data</em> with the server and then updating the content <em>within</em> a single page.</p>
</div>
<div class="paragraph">
<p>When this strategy or architecture is adopted for an entire application, everything happens on a &#8220;Single Page&#8221; and,
thus the application becomes a &#8220;Single Page Application.&#8221;</p>
</div>
<div class="paragraph">
<p>The Single Page Application architecture is extremely popular today and has been the dominant approach to building web applications for the last decade. This can be observed by the high level of mind-share and discussion it has received in the industry.</p>
</div>
<div class="paragraph">
<p>Today the vast majority of Single Page Applications adopt far more sophisticated frameworks for managing their
user interface than this simple example shows.  Popular libraries such as React, Angular, Vue.js, etc. are now the common&#8201;&#8212;&#8201;indeed, the standard&#8201;&#8212;&#8201;way to build web applications.</p>
</div>
<div class="paragraph">
<p>With these more complex frameworks developers typically work with an elaborate client-side model&#8201;&#8212;&#8201;that is, with JavaScript objects
stored locally in the browser&#8217;s memory that represent the &#8220;model&#8221; or &#8220;domain&#8221; of your application.  These JavaScript objects
are updated via JavaScript code and the framework then &#8220;reacts&#8221; to these changes, updating the user interface.</p>
</div>
<div class="paragraph">
<p>When the user interface is updated by a user these changes also flow <em>into</em> the model objects, establishing a &#8220;two-way&#8221;
binding mechanism: the model can update the UI, and the UI can update the model.</p>
</div>
<div class="paragraph">
<p>This is all very sophisticated and, today, very popular.  But the fact is that developers that adopt this approach to building
web applications have largely abandoned the web&#8217;s underlying hypermedia system.</p>
</div>
<div class="paragraph">
<p>HTML is still used to build user interfaces, but the <em>hypermedia</em> aspect of the two major hypermedia controls,
anchors and forms, are ignored.  Neither tag interacts with a server via their native <em>hypermedia</em> mechanism.  Rather,
they become mere user interface elements that drive local interactions with the in-memory domain model via JavaScript,
which is then synchronized with the server using plain data JSON APIs.</p>
</div>
<div class="paragraph">
<p>So, as with our simple button above, the Single Page Application approach is <em>not</em> built on top of a hypermedia architecture.
It does not take advantage of the existing RESTful architecture of the web, nor does it utilize the built-in functionality
found in HTML&#8217;s native hypermedia controls.</p>
</div>
<div class="paragraph">
<p>SPAs are somewhat like <em>thick client applications</em> like the client-server applications of the
1980s&#8201;&#8212;&#8201;an architecture popular <em>before</em> the web came along.</p>
</div>
<div class="paragraph">
<p>This approach <em>isn&#8217;t necessarily wrong</em>, but it is worth thinking about <em>why</em> web developers so frequently take it and
if there are reasons <em>not</em> to go down this path.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_why_use_hypermedia">1.4. Why Use Hypermedia?</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The emerging norm for web development is to build a React single-page application, with server rendering. The two key
elements of this architecture are something like:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The main UI is built &amp; updated in JavaScript using React or something similar.</p>
</li>
<li>
<p>The backend is an API that that application makes requests against.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This idea has really swept the internet. It started with a few major popular websites and has crept into corners like
marketing sites and blogs.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Tom MacWright<br>
<cite>https://macwright.com/2020/05/10/spa-fatigue.html</cite>
</div>
</div>
<div class="paragraph">
<p>The JavaScript-based Single Page Application approach has taken the web development world by storm, and there was one
major and very good reason for its success: The Single Page Application offers a far more interactive and immersive experience
than the old, gronky, Web 1.0 hypermedia-based applications could.  It had the ability to smoothly update elements inline on
a page without a dramatic reload of the entire document, the ability to use CSS transitions to create nice visual effects,
the ability to hook into arbitrary events like mouse movements. All of these gave JavaScript-based applications a huge advantage
in building sophisticated user experiences.</p>
</div>
<div class="paragraph">
<p>So why on earth would you abandon this popular and modern approach for an older and much less discussed
approach such as hypermedia?</p>
</div>
<div class="sect3">
<h4 id="_javascript_fatigue">JavaScript Fatigue</h4>
<div class="paragraph">
<p>Well, we are glad you asked.</p>
</div>
<div class="paragraph">
<p>It turns out that the hypermedia architecture, even in its original Web 1.0 form, has a number of advantages when compared with
the Single Page Application + JSON Data API approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is an extremely simple approach to building web applications.</p>
</li>
<li>
<p>It is extremely tolerant of content and API changes. In fact, it thrives on them!</p>
</li>
<li>
<p>It leverages tried and true features of web browsers, such as caching.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two advantages, in particular, address major pain points in modern web development:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Single Page Application infrastructure has become extremely complex, often requiring an entire team to manage.</p>
</li>
<li>
<p>JSON API churn&#8201;&#8212;&#8201;constant changes made to JSON APIs to support application needs&#8201;&#8212;&#8201;has become a major pain point for
many application teams.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The combination of these two problems, along with other issues such as JavaScript library churn, has led to a phenomenon known as &#8220;JavaScript Fatigue.&#8221; This refers to a general sense of exhaustion with all the hoops that are necessary to jump through to
get anything done in modern-day web applications.</p>
</div>
<div class="paragraph">
<p>We believe that a hypermedia architecture can help cure JavaScript Fatigue for many developers and teams.  But if hypermedia is so great, and if it addresses so many of the problems that beset the web
development industry, why was it abandoned in the first place?  After all, hypermedia was there first.</p>
</div>
<div class="paragraph">
<p>Why didn&#8217;t web developers just stick with it?</p>
</div>
<div class="paragraph">
<p>We believe that hypermedia hasn&#8217;t made a comeback yet for two reasons.</p>
</div>
<div class="paragraph">
<p>The first is this: the expressiveness of HTML <em>as a hypermedia</em> hasn&#8217;t changed much, if at all, since HTML 2.0, which
was released <em>in the mid 1990s</em>.  Many new <em>features</em> have been added to HTML, of course, but there haven&#8217;t been <em>any</em>
major new ways to interact with a server in HTML in almost three decades.</p>
</div>
<div class="paragraph">
<p>HTML developers still only have anchor tags and forms available as hypermedia controls, and those hypermedia controls
can still only issue <code>GET</code> and <code>POST</code> requests.</p>
</div>
<div class="paragraph">
<p>This baffling lack of progress by HTML leads immediately to the second, and perhaps more practical reason that
HTML-as-hypermedia has fallen on hard times: as the interactivity and expressiveness of HTML has remained frozen, the
demands of web users have continued to increase, calling for more and more interactive web applications.</p>
</div>
<div class="paragraph">
<p>JavaScript-based applications coupled to data-oriented JSON APIs have stepped in as a way to provide these more
sophisticated user interfaces. It was the <em>user experience</em> that you could achieve in JavaScript, and that you couldn&#8217;t achieve in plain HTML, that drove the web development community to the JavaScript-based
Single Page Application approach. The shift was not driven by any inherent superiority of the Single Page Application as a system
architecture.</p>
</div>
<div class="paragraph">
<p>It didn&#8217;t have to be this way.  There is nothing <em>intrinsic</em> to the idea of hypermedia that prevents it from having a
richer, more expressive interactivity model than vanilla HTML.  Rather than abandoning
the hypermedia architecture, the industry could have demanded more interactivity from HTML.</p>
</div>
<div class="paragraph">
<p>But the industry didn&#8217;t.  Instead, it reverted to making thick-client style applications within web browsers, in an
understandable move to a more familiar model for building rich applications.</p>
</div>
<div class="paragraph">
<p>Not everyone abandoned hypermedia, of course. There have been heroic efforts to continue to advance hypermedia outside of
HTML, efforts like HyTime, VoiceXML, and HAL.</p>
</div>
<div class="paragraph">
<p>But HTML, the most widely used hypermedia in the world, stopped making progress as a hypermedia. The web development
world moved on, solving the interactivity problems with HTML and adopting a completely different
system architecture along the way.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_hypermedia_resurgence">1.5. A Hypermedia Resurgence?</h3>
<div class="paragraph">
<p>It is interesting to think about how HTML <em>could</em> have advanced.  Instead of stalling as a hypermedia, how could HTML
have continued to develop? Could it have kept adding new hypermedia controls and increasing the expressiveness of
existing ones?  Would it have been possible to build modern web applications within this original, hypermedia-oriented
and RESTful model that made the early web so powerful, so flexible, so&#8230;&#8203; fun?</p>
</div>
<div class="paragraph">
<p>This might seem like idle speculation, but we have some good news on this score: in the last decade a few
idiosyncratic, alternative front end libraries have arisen that attempt to get HTML moving again.  Ironically, these
libraries are written in JavaScript, the technology that supplanted HTML as the center of web development.</p>
</div>
<div class="paragraph">
<p>However, these libraries use JavaScript not as a <em>replacement</em> for the fundamental hypermedia system of the web.</p>
</div>
<div class="paragraph">
<p>Instead, they use JavaScript to augment HTML itself <em>as a hypermedia</em>.</p>
</div>
<div class="paragraph">
<p>These <em>hypermedia-oriented</em> libraries re-center hypermedia as the core technology in web applications.</p>
</div>
<div class="sect3">
<h4 id="_hypermedia_oriented_javascript_libraries">Hypermedia-Oriented JavaScript Libraries</h4>
<div class="paragraph">
<p>In the web development world there is an ongoing debate between the Single Page Application (SPA) approach and what is now being called the
&#8220;Multi-Page Application&#8221; (MPA) approach.  MPA is a modern name for the old, Web 1.0 way of building web applications, using
links and forms located on multiple web pages, submitting HTTP requests and getting HTML responses.</p>
</div>
<div class="paragraph">
<p>MPA applications, by their nature, are Hypermedia-Driven Applications: after all, they are exactly what Roy Fielding
was describing in his dissertation.</p>
</div>
<div class="paragraph">
<p>These applications tend to be clunky, but they work reasonably well.  Many web developers and teams choose to accept the limitations of plain HTML in the interest of simplicity and reliability.</p>
</div>
<div class="paragraph">
<p>Rich Harris, creator of Svelte.js, a popular SPA library, and a thought-leader on the SPA side of the debate, has proposed a mix
of this older MPA style and the newer SPA style.  Harris calls this approach to building web applications &#8220;transitional,&#8221; in that
it attempts to blend the MPA approach and the newer SPA approach into a coherent whole.  (This is somewhat
similar to the &#8220;transitional&#8221; trend in architecture, which combines traditional and modern architectural styles.)</p>
</div>
<div class="paragraph">
<p>&#8220;Transitional&#8221; is a fitting term for mixed-style applications, and it offers a reasonable compromise between the two approaches, using either one as appropriate on a case-by-case basis.</p>
</div>
<div class="paragraph">
<p>But this compromise still feels unsatisfactory.</p>
</div>
<div class="paragraph">
<p>Must we default to having these two very different architectural models in our applications?</p>
</div>
<div class="paragraph">
<p>Recall that the crux of the trade-off between SPAs and MPAs is the <em>user experience</em>, or interactivity of the application.
This typically drives the decision to choose one approach versus the other for an application or&#8201;&#8212;&#8201;in the case
of a &#8220;transitional&#8221; application&#8201;&#8212;&#8201;for a particular feature.</p>
</div>
<div class="paragraph">
<p>It turns out that by adopting a hypermedia-oriented library, the interactivity gap between the MPA and the SPA approach
closes dramatically.  You can use the MPA approach, that is, the hypermedia approach, for much more of your application
without compromising your user interface. You might even be able to use the hypermedia approach for all your application
needs.</p>
</div>
<div class="paragraph">
<p>Rather than having an SPA with a bit of hypermedia around the edges, or some mix of the two approaches, you can often create
a web application that is <em>primarily</em> or <em>entirely</em> hypermedia driven, and that still satisfies the interactivity that your
users require.</p>
</div>
<div class="paragraph">
<p>This can <em>tremendously</em> simplify your web application and produce a much more coherent and understandable piece of
software.  While there are still times and places for the more complex SPA approach, which we will discuss later in the book,
by adopting a hypermedia-first approach and using a hypermedia-oriented library to push HTML as far as possible,
your web application can be powerful, interactive <em>and</em> simple.</p>
</div>
<div class="paragraph">
<p>One such hypermedia oriented library is <a href="https://htmx.org">htmx</a>.  Htmx will be the focus of Part Two.
We show that you can, in fact, create many common &#8220;modern&#8221; UI features found in sophisticated Single
Page Applications by instead using the hypermedia model.</p>
</div>
<div class="paragraph">
<p>And, it is refreshingly fun and simple to do so.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hypermedia_driven_applications_2">Hypermedia-Driven Applications</h4>
<div class="paragraph">
<p>When building a web application with htmx the term Multi-Page Application applies <em>roughly</em>, but it doesn&#8217;t fully characterize
the core of the application architecture.  As you will see, htmx doesn&#8217;t <em>need</em> to replace entire pages, and, in fact, an
htmx-based application can reside entirely within a single page. We don&#8217;t recommend this practice, but it is
possible!</p>
</div>
<div class="paragraph">
<p>So it isn&#8217;t quite right to call web applications built with htmx "Multi-Page Applications."  What the older Web 1.0 MPA
approach and the newer hypermedia-oriented library powered applications have in common is their use of <em>hypermedia</em> as
their core technology and architecture.</p>
</div>
<div class="paragraph">
<p>Therefore, we use the term <em>Hypermedia-Driven Applications (HDAs)</em> to describe both.</p>
</div>
<div class="paragraph">
<p>This clarifies that the core distinction between these two approaches and the SPA approach <em>isn&#8217;t</em> the number of pages
in the application, but rather the underlying <em>system</em> architecture.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Hypermedia-Driven Application (HDA)</dt>
<dd>
<p>A web application that uses <em>hypermedia</em> and <em>hypermedia exchanges</em> as its primary
mechanism for communicating with a server.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>So, what does an HDA look like up close?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an htmx-powered implementation of the simple JavaScript-powered button above:</p>
</div>
<div id="listing-1-4" class="listingblock">
<div class="title">An Htmx Implementation</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts/1" hx-target="#contact-ui"&gt; <b class="conum">(1)</b>
    Fetch Contact
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>issues a <code>GET</code> request to <code>/contacts/1</code>, replacing the <code>contact-ui</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As with the JavaScript powered button, this button has been annotated with some attributes.  However, in
this case we do not have any JavaScript scripting.</p>
</div>
<div class="paragraph">
<p>Instead, we have <em>declarative</em> attributes much like the <code>href</code> attribute on anchor tags and the <code>action</code> attribute on
form tags.  The <code>hx-get</code> attribute tells htmx: "`When the user clicks this button, issue a <code>GET</code> request to <code>/contacts/1</code>."
The <code>hx-target</code> attribute tells htmx: "`When the response returns, take the resulting HTML and place it into the element
with the id <code>contact-ui</code>."</p>
</div>
<div class="paragraph">
<p>Here we get to the crux of htmx and how it allows you to build Hypermedia-Driven Applications:</p>
</div>
<div class="paragraph">
<p><em>The HTTP response from the server is expected to be in HTML format, not JSON</em>.</p>
</div>
<div class="paragraph">
<p>This htmx-powered button is exchanging <em>hypermedia</em> with the server, just like an anchor tag or form
might, and thus the interaction is still within the original hypermedia model of the web.  Htmx <em>is</em> adding functionality
to this button (via JavaScript), but that functionality is <em>augmenting</em> HTML as a hypermedia. Htmx extends the hypermedia
system of the web, rather than <em>replacing</em> that hypermedia system with a totally different architecture.</p>
</div>
<div class="paragraph">
<p>Despite looking superficially similar to one another it turns out that this htmx-powered button and the JavaScript-based
button are using extremely different system architectures and, thus, approaches to web development.</p>
</div>
<div class="paragraph">
<p>As we walk through building a Hypermedia-Driven Application in this book, the differences between the two approaches
will become more and more apparent.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_when_should_you_use_hypermedia">1.6. When Should You Use Hypermedia?</h3>
<div class="paragraph">
<p>Hypermedia is often, though <em>not always</em>, a great choice for a web application.</p>
</div>
<div class="paragraph">
<p>Perhaps you are building a website or application that simply doesn&#8217;t <em>need</em> a huge amount of user-interactivity.  There are
many useful web applications like this, and there is no shame in it!  Applications like Amazon, eBay, any number of news
sites, shopping sites, message boards and so on don&#8217;t need a massive amount of interactivity to be effective: they are
mainly text and images, which is exactly what the web was designed for.</p>
</div>
<div class="paragraph">
<p>Perhaps your application adds most of its value on the <em>server side</em>, by coordinating users or by applying sophisticated
data analysis and then presenting it to a user.  Perhaps your application adds value by simply sitting in front of a
well-designed database, with simple Create-Read-Update-Delete (CRUD) operations.  Again, there is no shame in this!</p>
</div>
<div class="paragraph">
<p>In any of these cases, using a hypermedia approach would likely be a great choice: the interactivity needs of
these applications are not dramatic, and much of the value of these applications lives on the server side, rather than on the client side.</p>
</div>
<div class="paragraph">
<p>All of these applications are amenable to what Roy Fielding called &#8220;large-grain hypermedia data transfers&#8221;: you can simply
use anchor tags and forms, with responses that return entire HTML documents from requests, and things will work just fine.
This is exactly what the web was designed to do!</p>
</div>
<div class="paragraph">
<p>By adopting the hypermedia approach for these applications, you will save yourself a huge amount of client-side complexity
that comes with adopting the Single Page Application approach: there is no need for client-side routing, for managing
a client-side model, for hand-wiring in JavaScript logic, and so forth.  The back button will &#8220;just work&#8221;.  Deep linking
will &#8220;just work&#8221;.  You will be able to focus your efforts on your server, where your application is actually adding value.</p>
</div>
<div class="paragraph">
<p>And, by layering htmx or another hypermedia-oriented library on top of this approach, you can address many of the usability
issues that come with vanilla HTML and take advantage of finer-grained hypermedia transfers.  This opens up a whole slew of new
user interface and experience possibilities, making the set of applications that can be built using hypermedia <em>much</em> larger.</p>
</div>
<div class="paragraph">
<p>But more on that later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_when_shouldnt_you_use_hypermedia">1.7. When Shouldn&#8217;t You Use Hypermedia?</h3>
<div class="paragraph">
<p>So, what about that <em>not always</em>?  When isn&#8217;t hypermedia going to work well for an application?</p>
</div>
<div class="paragraph">
<p>One example that springs immediately to mind is an online spreadsheet application.  In the case of a spreadsheet,
updating one cell could have a large number of cascading changes that need to be made across the entire sheet.  Worse,
this might need to happen <em>on every keystroke</em>.</p>
</div>
<div class="paragraph">
<p>In this case we have a highly dynamic user interface without clear boundaries as to what might need to be updated given
a particular change.  Introducing a hypermedia-style server round-trip on every cell change would hurt performance
tremendously.</p>
</div>
<div class="paragraph">
<p>This is simply not a situation amenable to the &#8220;large-grain hypermedia data transfer&#8221; approach of the web.  For an
application like this we would certainly recommend looking into using a sophisticated client-side JavaScript approach.</p>
</div>
<div class="paragraph">
<p><em>However</em> even in the case of an online spreadsheet there are likely areas where the hypermedia approach might help.</p>
</div>
<div class="paragraph">
<p>The spreadsheet application likely also has a settings page.  And perhaps that settings page <em>is</em> amenable to
the hypermedia approach.  If it is simply a set of relatively straight-forward forms that need to be persisted to the
server, the chances are good that hypermedia would, in fact, work great for this part of the app.</p>
</div>
<div class="paragraph">
<p>And, by adopting hypermedia for that part of your application, you might be able to simplify that part of the application
quite a bit. You could then save more of your application&#8217;s <em>complexity budget</em> for the core, complicated spreadsheet logic,
keeping the simple stuff simple.</p>
</div>
<div class="paragraph">
<p>Why waste all the complexity associated with a heavy JavaScript framework on something as simple as a settings page?</p>
</div>
<aside class="sidebar">
        <div class="titlebar">A Complexity Budget</div>
        <div class="paragraph">
<p>Any software project has a complexity budget, explicit or not: there is only so much complexity a given development
team can tolerate and every new feature and implementation choice adds at least a bit more to the overall complexity
of the system.</p>
</div>
<div class="paragraph">
<p>What is particularly nasty about complexity is that it appears to grow exponentially: one day you can keep the entire
system in your head and understand the ramifications of a particular change, and a week later the whole system seems
intractable.  Even worse, efforts to help control complexity, such as introducing abstractions or infrastructure to
manage the complexity, often end up making things even more complex.  Truly, the job of the good software engineer
is to keep complexity under control.</p>
</div>
<div class="paragraph">
<p>The sure-fire way to keep complexity down is also the hardest: say no.  Pushing back on feature requests is an art
and, if you can learn to do it well, making people feel like <em>they</em> said no, you will go far.</p>
</div>
<div class="paragraph">
<p>Sadly this is not always possible: some features will need to be built.  At this point the question becomes: &#8220;what is
the simplest thing that could possibly work?&#8221;  Understanding the possibilities available in the hypermedia approach
will give you another tool in your &#8220;simplest thing&#8221; tool chest.</p>
</div>
    </aside>
</div>
<div class="sect2">
<h3 id="_hypermedia_a_sophisticated_modern_system_architecture">1.8. Hypermedia: A Sophisticated, Modern System Architecture</h3>
<div class="paragraph">
<p>Hypermedia is often regarded as an old and antiquated technology in web development circles, useful perhaps
for static websites but certainly not a realistic choice for modern, sophisticated web applications.</p>
</div>
<div class="paragraph">
<p>Seriously? Are we claiming that modern web applications can be built using it?</p>
</div>
<div class="paragraph">
<p>Yes, seriously.</p>
</div>
<div class="paragraph">
<p>Contrary to current popular opinion, hypermedia is an <em>innovative</em> and <em>modern</em> system architecture for building
applications, in some ways <em>more modern</em> than the prevailing Single Page Application approaches.  In the remainder
of this book we will reintroduce you to the core, practical concepts of hypermedia and then demonstrate exactly how
you can take advantage of this system architecture in your own software.</p>
</div>
<div class="paragraph">
<p>In the coming chapters you will develop a firm understanding of all the benefits and techniques enabled by this approach.
We hope that, in addition, you will also become as passionate about it as we are.</p>
</div>
<div class="paragraph">
<p>This book is, in part, a plea that we &#8220;let the web be the web&#8221;, that we take the original architecture of the web
seriously, and that we consider the entire <em>hypermedia system</em> it makes available to us when we build applications
with it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_components_of_a_hypermedia_system">2. Components Of A Hypermedia System</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>hypermedia system</em> consists of a number of components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A hypermedia, such as HTML</p>
</li>
<li>
<p>A network protocol, such as HTTP</p>
</li>
<li>
<p>A server that presents a hypermedia API responding to network requests with hypermedia responses</p>
</li>
<li>
<p>A client that properly interprets those responses</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this chapter we will look at these components and their implementation in the context of the web.</p>
</div>
<div class="paragraph">
<p>Once we have reviewed the major components of the web as a hypermedia system, we will look at key insights developed by Roy
Fielding in his dissertation, &#8220;Architectural Styles and the Design of Network-based Software Architectures.&#8221;  We will see where the
terms REpresenation State Transfer (REST), RESTful and Hypermedia As The Engine Of Application State (HATEOAS) come from,
and we will analyze these terms in the context of the web.</p>
</div>
<div class="paragraph">
<p>This should give you a stronger understanding of the theoretical basis of the web as a hypermedia system, how it is
supposed to fit together, and why Hypermedia-Driven Applications are RESTful, whereas JSON APIs&#8201;&#8212;&#8201;despite the way the
term REST is currently used in the industry&#8201;&#8212;&#8201;are not.</p>
</div>
<div class="sect2">
<h3 id="_components_of_a_hypermedia_system_2">2.1. Components Of A Hypermedia System</h3>
<div class="sect3">
<h4 id="_the_hypermedia">The Hypermedia</h4>
<div class="paragraph">
<p>The fundamental technology of a hypermedia system is a hypermedia that allows a
client and server to communicate with one another in a dynamic, non-linear fashion.  Again, what makes a hypermedia
a hypermedia is the presence of <em>hypermedia controls</em>: elements in the hypermedia that allow users to select
non-linear actions within the hypermedia.  Users of a hypermedia system can <em>interact</em> with the media in a manner beyond
simply reading from start to end.</p>
</div>
<div class="paragraph">
<p>We have already mentioned the two primary hypermedia controls in HTML, anchors and forms, which allow a browser to
present links and operations to a user through a browser.</p>
</div>
<div class="paragraph">
<p>In the case of HTML, these links and forms typically specify the target of their operations using Uniform Resource
Locators (URLs):</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Uniform Resource Locator</dt>
<dd>
<p>A uniform resource locator is a textual string that refers to, or <em>points to</em> a location
on a network where a <em>resource</em> can be retrieved from, as well as the mechanism by which the resource can be retrieved.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A URL is a string consisting of various subcomponents:</p>
</div>
<div class="listingblock">
<div class="title">URL Components</div>
<div class="content">
<pre>[scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]</pre>
</div>
</div>
<div class="paragraph">
<p>Many of these subcomponents are not required, and are often omitted.</p>
</div>
<div class="paragraph">
<p>A typical URL might look like this:</p>
</div>
<div class="listingblock">
<div class="title">A simple URL</div>
<div class="content">
<pre>https://hypermedia.systems/book</pre>
</div>
</div>
<div class="paragraph">
<p>This particular URL is made up of the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A protocol or scheme (in this case <code>https</code>)</p>
</li>
<li>
<p>A domain (in this case <code>hypermedia.systems</code>)</p>
</li>
<li>
<p>A path (in this case <code>/book</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This URL uniquely identifies a retrievable <em>resource</em> on the internet, to which an <em>HTTP Request</em> can be issued by
a hypermedia client that &#8220;speaks&#8221; HTTPS, such as a web browser.  If this URL is found as the reference of a
hypermedia control within an HTML document, it implies that there is a <em>hypermedia server</em> on the other side of the
network that understands HTTPS as well, and that can respond to this request with a <em>representation</em> of the given
resource (or redirect you to another location, etc.)</p>
</div>
<div class="paragraph">
<p>Note that URLs are often not written out entirely within HTML.  It is very common to see anchor tags that look like this,
for example:</p>
</div>
<div class="listingblock">
<div class="title">A Simple Link</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="/book/contents/"&gt;Table Of Contents&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have a <em>relative</em> hypermedia reference, where the protocol, host and port are <em>implied</em> to be that of the &#8220;current
document&#8221;, that is, the same as whatever the protocol and server were to retrieve the current HTML page.  So, if this
link was found in an HTML document retrieved from <code><a href="https://hypermedia.systems/" class="bare">https://hypermedia.systems/</a></code>, then the implied URL for this anchor
would be <code><a href="https://hypermedia.systems/book/contents/" class="bare">https://hypermedia.systems/book/contents/</a></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hypermedia_protocols">Hypermedia Protocols</h4>
<div class="paragraph">
<p>The hypermedia control (link) above tells a browser: &#8220;When a user clicks on this text, issue request to
<a href="https://hypermedia.systems/book/contents/" class="bare">https://hypermedia.systems/book/contents/</a> using the Hypertext Transfer Protocol&#8221;, or HTTP.</p>
</div>
<div class="paragraph">
<p>HTTP is the <em>protocol</em> used to transfer HTML (hypermedia) between browsers (hypermedia clients) and servers (hypermedia
servers) and, as such, is the key network technology that binds the distributed hypermedia system of the web together.</p>
</div>
<div class="paragraph">
<p>HTTP version 1.1 is a relatively simple network protocol, so lets take a look at what the <code>GET</code> request triggered by the anchor
tag would look like.  This is the request that would be sent to the server found at <code>hypermedia.systems</code>, on port <code>80</code>
by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">GET /book/contents/ HTTP/1.1
Accept: text/html,*/*
Host: hypermedia.systems</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line specifies that this is an HTTP <code>GET</code> request.  It then specifies the path of the resource being
requested.  Finally, it contains the HTTP version for this request.</p>
</div>
<div class="paragraph">
<p>After that are a series of HTTP <em>Request Headers</em>, individual lines of name/value pairs, separated by a colon, which provide
<em>metadata</em> that can be used by the server to determine exactly how to respond to the client request.  In this case,
with the <code>Accept</code> header, the browser is saying it would prefer HTML as a response format, but will accept anything that
the server responds with.</p>
</div>
<div class="paragraph">
<p>Next, it has a <code>Host</code> header, which specifies the server that the request has been sent to. This is useful when multiple
domains are hosted on the same host.</p>
</div>
<div class="paragraph">
<p>An HTTP response from a server to this request might look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 870
Server: Werkzeug/2.0.2 Python/3.8.10
Date: Sat, 23 Apr 2022 18:27:55 GMT

&lt;html lang="en"&gt;
&lt;body&gt;
&lt;body&gt;
&lt;header&gt;
    &lt;h1&gt;HYPERMEDIA SYSTEMS&lt;/h1&gt;
  ...
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the first line, the HTTP Response specifies the HTTP version being used, followed by a <em>response code</em> of <code>200</code>,
indicating that the given resource was found and that the request succeeded.  This is followed by a string, <code>OK</code> that
corresponds to the response code.  (The actual string doesn&#8217;t matter, it is the response code that tells the client
the result of a request, as we will discuss in more detail below.)</p>
</div>
<div class="paragraph">
<p>After the first line of the response, as with the HTTP Request, we see a series of <em>Response Headers</em> that provide
metadata to the client to assist in displaying the <em>representation</em> of the resource correctly.</p>
</div>
<div class="paragraph">
<p>Finally, we see some new HTML content.  This content is the HTML <em>representation</em> of the requested resource, in this
case a table of contents of a book.  The browser will use this HTML to replace the entire content in its display window,
showing the user this new page, and updating the address bar to reflect the new URL.</p>
</div>
<div class="sect4">
<h5 id="_http_methods">HTTP Methods</h5>
<div class="paragraph">
<p>The anchor tag above issued an HTTP <code>GET</code>, where <code>GET</code> is the <em>method</em> of the request.  The particular method
being used in an HTTP request is perhaps the most important piece of information about it, after the actual resource that
the request is directed at.</p>
</div>
<div class="paragraph">
<p>There are many methods available in HTTP; the ones of most practical importance to developers are the following:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>GET</code></dt>
<dd>
<p>A GET request retrieves the representation of the specified resource. GET requests should not mutate data.</p>
</dd>
<dt class="hdlist1"><code>POST</code></dt>
<dd>
<p>A POST request submits data to the specified resource. This will often result in a mutation of state on the server.</p>
</dd>
<dt class="hdlist1"><code>PUT</code></dt>
<dd>
<p>A PUT request replaces the data of the specified resource. This results in a mutation of state on the server.</p>
</dd>
<dt class="hdlist1"><code>PATCH</code></dt>
<dd>
<p>A PATCH request replaces the data of the specified resource. This results in a mutation of state on the server.</p>
</dd>
<dt class="hdlist1"><code>DELETE</code></dt>
<dd>
<p>A DELETE request deletes the specified resource. This results in a mutation of state on the server.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These methods <em>roughly</em> line up with the &#8220;Create/Read/Update/Delete&#8221; or CRUD pattern found in many applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>POST</code> corresponds with Creating a resource</p>
</li>
<li>
<p><code>GET</code> corresponds with Reading a resource</p>
</li>
<li>
<p><code>PUT</code> and <code>PATCH</code> correspond with Updating a resource</p>
</li>
<li>
<p><code>DELETE</code> corresponds, well, with Deleting a resource</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that this HTTP Action/CRUD correspondence is a rough rule of thumb for application development, the underlying RFCs
that specify them make no such connection and are often somewhat obscure.  Here, for example, is the documentation
on the distinction between a <code>POST</code> and a <code>PUT</code> from <a href="https://www.rfc-editor.org/rfc/rfc2616">RCF-2616</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed
representation. The target resource in a POST request is intended to handle the enclosed representation according to the
resource&#8217;s own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the
target resource.  Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact
effect is only known by the origin server.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; RCF-2616<br>
<cite>https://www.rfc-editor.org/rfc/rfc2616#section-9.6</cite>
</div>
</div>
<div class="paragraph">
<p>So, in plain terms, a <code>POST</code> can be handled by a server pretty much however it likes, whereas a <code>PUT</code> should be handled
as a &#8220;replacement&#8221; of the resource, although the language, once again allows the server to do pretty much whatever it
would like within the constraint of being idempotent.</p>
</div>
<div class="paragraph">
<p>This sort of academic language (and arguments around it) can be alienating to many web developers.  While we feel it is
good to learn these concepts (e.g. idempotency) in depth, we also feel that requiring a PhD to build effective hypermedia
systems is unreasonable.  Frankly, the academic and pedantic language around things like HTTP methods is one reason why
hypermedia has fallen on hard times.</p>
</div>
<div class="paragraph">
<p>In any event, in a properly structured HTML-based hypermedia system you should use an appropriate HTTP method for the operation a
particular hypermedia control performs: If a hypermedia control such as a button <em>deletes</em> a resource, for example, ideally
it should an HTTP <code>DELETE</code> request to do so.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">HTML &amp; HTTP Methods</div>
        <div class="paragraph">
<p>A strange thing about HTML is that, despite being the world&#8217;s most popular hypermedia and despite being designed alongside
HTTP (which is the Hypertext Transfer Protocol, after all!), the native hypermedia controls in HTML can only issue
HTTP <code>GET</code> and <code>POST</code> requests:</p>
</div>
<div class="paragraph">
<p>Anchor tags always issue a <code>GET</code> request.</p>
</div>
<div class="paragraph">
<p>Forms can issue either a <code>GET</code> or <code>POST</code> using the <code>method</code> attribute.</p>
</div>
<div class="paragraph">
<p>Forms and anchor tags <em>can&#8217;t</em> issue <code>PUT</code>, <code>PATCH</code> or <code>DELETE</code> requests!  If you wish to issue these last three types
of requests, you currently <em>have</em> to resort to JavaScript to do so.  Since a <code>POST</code> can do damned near anything, it
ends up being used for any mutation on the server, and <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code> are left aside in plain HTML-based
applications.</p>
</div>
<div class="paragraph">
<p>This is an obvious shortcoming of HTML as a hypermedia, and it is hard to understand why this hasn&#8217;t been fixed in the
HTML specification yet!</p>
</div>
    </aside>
</div>
<div class="sect4">
<h5 id="_http_response_codes">HTTP Response Codes</h5>
<div class="paragraph">
<p>HTTP Request methods allow a client to tell a server <em>what</em> to do to a given resource.  HTTP Responses contain
<em>response codes</em>, which tell a client what the result of the request was.   HTTP response codes are numeric
values that are embedded in the HTTP response, as we saw above.</p>
</div>
<div class="paragraph">
<p>The most familiar response code for most web developers is probably <code>404</code>, which stands for &#8220;Not Found&#8221;.  This
is the response code that is returned by web servers when a resource that does not exist is requested from them.</p>
</div>
<div class="paragraph">
<p>HTTP breaks response codes up into various categories:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>100</code>-<code>199</code></dt>
<dd>
<p>Informational responses that provide information about how the server is processing the response</p>
</dd>
<dt class="hdlist1"><code>200</code>-<code>299</code></dt>
<dd>
<p>Successful responses indicating that the request succeeded</p>
</dd>
<dt class="hdlist1"><code>300</code>-<code>399</code></dt>
<dd>
<p>Redirection responses indicating that the request should be sent to some other URL</p>
</dd>
<dt class="hdlist1"><code>400</code>-<code>499</code></dt>
<dd>
<p>  Client error responses indicating that the client made some sort of bad request (e.g. asking for something that didn&#8217;t
exist in the case of <code>404</code> errors)</p>
</dd>
<dt class="hdlist1"><code>500</code>-<code>599</code></dt>
<dd>
<p>Server error responses indicating that the server encountered an error internally as it attempted to respond to the request</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Within each of these categories there are multiple response codes for specific situations.</p>
</div>
<div class="paragraph">
<p>Here are some of the more common or interesting ones:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>200 OK</code></dt>
<dd>
<p>The HTTP request succeeded</p>
</dd>
<dt class="hdlist1"><code>301 Moved Permanently</code></dt>
<dd>
<p>The URL for the requested resource has moved to a new location permanently, and the new URL will be provided in
the <code>Location</code> response header</p>
</dd>
<dt class="hdlist1"><code>302 Found</code></dt>
<dd>
<p>The URL for the requested resource has moved to a new location temporarily, and the new URL will be provided in
the <code>Location</code> response header</p>
</dd>
<dt class="hdlist1"><code>303 See Other</code></dt>
<dd>
<p>The URL for the requested resource has moved to a new location, and the new URL will be provided in
the <code>Location</code> response header.  Additionally, this new URL should be retrieved with a <code>GET</code> request.</p>
</dd>
<dt class="hdlist1"><code>401 Unauthorized</code></dt>
<dd>
<p>The client is not yet authenticated (yes, authenticated, despite the name) and must be authenticated
to retrieve the given resource.</p>
</dd>
<dt class="hdlist1"><code>403 Forbidden</code></dt>
<dd>
<p>The client does not have access to this resource.</p>
</dd>
<dt class="hdlist1"><code>404 Not Found</code></dt>
<dd>
<p>The server cannot find the requested resource.</p>
</dd>
<dt class="hdlist1"><code>500 Internal Server Error</code></dt>
<dd>
<p>The server encountered an error when attempting to process the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>There are some fairly subtle differences between HTTP response codes.  (And, to be honest, some ambiguities between them.)
The difference between a <code>302</code> redirect and a <code>303</code> redirect, for example, is that the former will issue the request to the
new URL using the same HTTP method, were the latter will always use a <code>GET</code>.  A small, but often crucial difference,
as we will see later in the book.</p>
</div>
<div class="paragraph">
<p>Nonetheless, a well crafted hypermedia system will take advantage of both HTTP methods and HTTP response codes to create a sensible
hypermedia API.  You do not want to build a hypermedia system that uses a <code>POST</code> method for all requests and responds
with <code>200 OK</code> for every response.  Some JSON Data APIs built on top of HTTP do exactly this!</p>
</div>
<div class="paragraph">
<p>When building a Hypermedia-Driven Application, you want, instead, to go &#8220;with the grain&#8221; of the web and use HTTP methods
and response codes as they were designed to be used.</p>
</div>
</div>
<div class="sect4">
<h5 id="_caching_http_responses">Caching HTTP Responses</h5>
<div class="paragraph">
<p>A constraint of REST (and, therefore, a feature of HTTP) is the notion of Caching responses: a server can indicate to
a client (as well as intermediary HTTP servers) that a given response can be cached for future requests to the same
URL.</p>
</div>
<div class="paragraph">
<p>The cache behavior of an HTTP response from a server can be indicated with the <code>Cache-Control</code> response header.  This
header can have a number of different values indicating the cacheability of a given response.  If, for example, the header
contains the value <code>max-age=60</code>, this indicates that a client may cache this response for 60 seconds, and need not issue
another HTTP request for that resource until that time limit has expired.</p>
</div>
<div class="paragraph">
<p>Another important caching-related response header is <code>Vary</code>.  This response header can be used to indicate exactly what
headers in an HTTP Request form the unique identifier for a cached result.  This becomes important to allow the browser
to correctly cache content in situations where a particular header affects the form of the server response.  A common
pattern in htmx-powered applications is to use a custom header set by htmx, <code>HX-Request</code>, to differentiate between
&#8220;normal&#8221; web requests and requests submitted by htmx.  To properly cache the response to these requests, the <code>HX-Request</code>
request header must be indicated by the <code>Vary</code> response header.</p>
</div>
<div class="paragraph">
<p>A full discussion of caching HTTP responses is beyond the scope of this chapter; see
the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN Article on HTTP Caching</a> if you would like to know more on the topic.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hypermedia_servers">Hypermedia Servers</h4>
<div class="paragraph">
<p>Hypermedia servers are any server that can respond to an HTTP request with an HTTP response.  Because HTTP is so simple,
this means that nearly any programming language can be used to build a hypermedia server.  There are a vast number of
libraries available for building HTTP-based hypermedia servers in nearly every programming language imaginable.</p>
</div>
<div class="paragraph">
<p>This is one of the best aspects of adopting hypermedia as your primary technology for building a web application: it removes
the pressure of adopting JavaScript as a back-end technology.  In contrast, if you decide to adopt a JavaScript-heavy
Single Page Application-based front end, and you use JSON Data APIs, you will feel significant pressure to adopt
JavaScript on the back end.</p>
</div>
<div class="paragraph">
<p>In this latter situation, you already have a ton of code written in JavaScript.  Why maintain two separate code bases in
two different languages? Why not create reusable domain logic on the client-side as well as the server-side?  Now that
JavaScript has excellent server-side technologies available like node and deno, why not just a single language for
everything?</p>
</div>
<div class="paragraph">
<p>In contrast, using a hypermedia-based front end gives you a lot more freedom in picking the back end technology you want
to use.  Your decision can be based on the domain of your application, what languages and server software you are familiar
with or are passionate about, or just what you feel like trying out.</p>
</div>
<div class="paragraph">
<p>You certainly aren&#8217;t writing your server-side logic in HTML!  And every major programming language has at least one good
web framework and templating library that can be used to handle HTTP requests cleanly.</p>
</div>
<div class="paragraph">
<p>Perhaps if you are doing something in big data, perhaps you&#8217;d like to use Python, which has tremendous support for that
domain.</p>
</div>
<div class="paragraph">
<p>Perhaps if you are doing AI work, perhaps you&#8217;d like to use Lisp, leaning on a language with a long history in that
area of research.</p>
</div>
<div class="paragraph">
<p>Maybe you are a functional programming enthusiast and want to use OCaml or Haskell.  Perhaps you just really like Julia or
Nim.</p>
</div>
<div class="paragraph">
<p>These are all perfectly valid reasons for choosing a particular server-side technology!</p>
</div>
<div class="paragraph">
<p>By using hypermedia as your system architecture, you are freed up to adopt any of these choices. There simply isn&#8217;t a
large JavaScript code base on the front end pressuring you to adopt JavaScript on the back end.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Hypermedia On Whatever you&#8217;d Like (HOWL)</div>
        <div class="paragraph">
<p>In the htmx community we call this (with tongue in cheek) the HOWL stack: Hypermedia On Whatever you&#8217;d Like.  The htmx community
is multi-language and multi-framework, there are rubyists as well as pythonistas, lispers as well as haskellers.  There
are even JavaScript enthusiasts!  All these languages and frameworks are able to adopt hypermedia, and are able to still
share techniques and offer support to one another because they share a common underlying architecture: they are all using
the web as a hypermedia system.</p>
</div>
<div class="paragraph">
<p>Hypermedia, in this sense, provides a &#8220;universal language&#8221; for the web that we can all use.</p>
</div>
    </aside>
</div>
<div class="sect3">
<h4 id="_hypermedia_clients">Hypermedia Clients</h4>
<div class="paragraph">
<p>We now come to the final major component in a hypermedia system: the hypermedia client.  Hypermedia <em>clients</em> are software
that understand how to interpret a particular hypermedia, and the hypermedia controls within it, properly.  The canonical
example, of course, is the web browser, which understand HTML and can present it to a user to interact with. Web browsers
are incredibly sophisticated pieces of software.  (So sophisticated, in fact, that they are often re-purposed away from
being a hypermedia client, to being a sort of cross-platform virtual machine for launching Single Page Applications.)</p>
</div>
<div class="paragraph">
<p>Browsers aren&#8217;t the only hypermedia clients out there, however.  In the last section of this book we will look at
Hyperview, a mobile-oriented hypermedia.  One of the outstanding features of Hyperview is that it doesn&#8217;t simply provide
a hypermedia, HXML, but also provides a <em>working hypermedia client</em> for that hypermedia.  This makes building a proper
Hypermedia-Driven Application with Hyperview extremely easy.</p>
</div>
<div class="paragraph">
<p>A crucial feature of a hypermedia system is what is known as <em>the uniform interface</em>.  We discuss this concept in depth
in the next section on REST.  What is often ignored in discussions about hypermedia is how important the hypermedia
client is in taking advantage of this uniform interface.  A hypermedia client must know how to properly interpret and
present hypermedia controls found in a hypermedia response from a hypermedia server for the whole hypermedia system
to hang together.  Without a sophisticated client that can do this, hypermedia controls and a hypermedia-based API are
much less useful.</p>
</div>
<div class="paragraph">
<p>This is one reason why JSON APIs have rarely adopted hypermedia controls successfully: JSON APIs are typically consumed
by code that is expecting a fixed-format and isn&#8217;t designed to be a hypermedia client.  For clients like this, the
power of hypermedia controls embedded within an API response is irrelevant and often simply annoying:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The short answer to this question is that HATEOAS isn’t a good fit for most modern use cases for APIs. That is why
after almost 20 years, HATEOAS still hasn’t gained wide adoption among developers. GraphQL on the other hand is spreading
like wildfire because it solves real-world problems.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Freddie Karlbom<br>
<cite>https://techblog.commercetools.com/graphql-and-rest-level-3-hateoas-70904ff1f9cf</cite>
</div>
</div>
<div class="paragraph">
<p>HATEOAS will be described in more detail below, but the take away here is that a good hypermedia client is a necessary
component within a larger hypermedia system.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rest">2.2. REST</h3>
<div class="paragraph">
<p>Now that we have reviewed the major components of a hypermedia system, it&#8217;s time to look more deeply into the concept of
REST.  The term &#8220;REST&#8221; comes from Chapter 5 of Roy Fielding&#8217;s PhD dissertation on the architecture
of the web.  Fielding wrote his dissertation at U.C. Irvine, after having helped build much of the infrastructure of the early
web, including the Apache web server.  Roy was attempting to formalize and describe the novel distributed computing system
that he had helped to build.</p>
</div>
<div class="paragraph">
<p>We are going to focus in on what we feel is the most important section of Fielding&#8217;s dissertation, from a web development
perspective: Section 5.1. This section contains the core concepts (Fielding calls them <em>constraints</em>) of Representational
State Transfer, or REST.</p>
</div>
<div class="paragraph">
<p>Before we get into the muck, however, it is important to understand that Fielding discusses REST as a <em>network architecture</em>,
that is an entirely different way of architecting a distributed system.  And a novel one that should be <em>contrasted</em> with
earlier distributed systems.</p>
</div>
<div class="paragraph">
<p>It is also important to emphasize that, at the time Fielding wrote his dissertation, JSON APIs and AJAX did not exist.
He was describing the early web, with HTML being transferred over HTTP by early browsers, as a hypermedia system.</p>
</div>
<div class="paragraph">
<p>Today, in a strange turn of events, the term &#8220;REST&#8221; is mainly associated with JSON Data APIs, rather than with HTML
and hypermedia.  This becomes extremely humorous once you realize that the vast majority of JSON Data APIs aren&#8217;t
RESTful, and, in fact <em>can&#8217;t</em> be RESTful, since they aren&#8217;t using a natural hypermedia format.</p>
</div>
<div class="paragraph">
<p>To re-emphasise: REST, as coined by Fielding, describes <em>the pre-JSON API web</em>, and letting go of the current, common
usage of the term as &#8220;JSON API&#8221; is necessary to develop a proper understanding of it.</p>
</div>
<div class="sect3">
<h4 id="_the_constraints_of_rest">The &#8220;Constraints&#8221; of REST</h4>
<div class="paragraph">
<p>In his dissertation, Fielding defines various &#8220;constraints&#8221; to describe how a RESTful system must behave.  This approach
can feel a little round-about and difficult to follow for many people, but it is an appropriate approach for an academic
dissertation.  Given a bit of time thinking about the constraints he outlines, and some concrete examples, it will
become easy to understand if a given system actually satisfies the architectural requirements of REST or not.</p>
</div>
<div class="paragraph">
<p>Here are the constraints of REST, which are outlined in Section 5.1 of his dissertation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is a client-server architecture (section 5.1.2)</p>
</li>
<li>
<p>It must be stateless (section 5.1.3) that is, every request contains all information necessary to respond to that request</p>
</li>
<li>
<p>It must allow for caching (section 5.1.4)</p>
</li>
<li>
<p>It must have a <em>uniform interface</em> (section 5.1.5)</p>
</li>
<li>
<p>It is a layered system (section 5.1.6)</p>
</li>
<li>
<p>Optionally, can allow for Code-On-Demand (section 5.1.7), that is, scripting.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s go through each of these constrains in turn and discuss them in detail, looking at how (and to what extent) the web
satisfies each of them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_client_server_constraint">The Client-Server Constraint</h4>
<div class="paragraph">
<p>See <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_2">Section 5.1.2</a> for the
Client-Server constraint.</p>
</div>
<div class="paragraph">
<p>Obviously, the REST model Fielding was describing involved both <em>clients</em> (browsers, in the case of the web) and <em>servers</em> (such
as the Apache Web Server he had been working on) communicating via a network connection.  This was the context of his
work: he was describing the network architecture of the World Wide Web, and contrasting it with earlier architectures,
notably thick-client networking models such as the Common Object Request Broker Architecture (CORBA).</p>
</div>
<div class="paragraph">
<p>It should be obvious that any web application, regardless of how it is designed, will satisfy this requirement.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_statelessness_constraint">The Statelessness Constraint</h4>
<div class="paragraph">
<p>See <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3">Section 5.1.3</a> for the Stateless constraint.</p>
</div>
<div class="paragraph">
<p>As described by Fielding, a RESTful system is stateless: every request should encapsulate all information necessary to
respond to that request, with no side state or context stored on either the client or the server.</p>
</div>
<div class="paragraph">
<p>In practice, for many web applications today, we actually violate this constraint: it is common to establish a
<em>session cookie</em> that acts as a unique identifier for a given user and that is sent along with every request.  While this
session cookie is, by itself, not stateful (it is sent with every request), it is typically
used as a key to look up information stored on the server, in what is usually termed "`the session`."</p>
</div>
<div class="paragraph">
<p>This session information is typically stored in some sort of shared storage across multiple web servers, holding things
like the current users email or id, their roles, partially created domain objects, caches, and so forth.</p>
</div>
<div class="paragraph">
<p>This violation of the Statelessness REST architectural constraint has proven to be useful for building web applications
and, for the most part, does not appear to have had a significant impact on the overall flexibility of the approach.  But
it is worth bearing in mind that even Web 1.0 applications often violate the purity of REST in the interest of pragmatic
trade-offs.</p>
</div>
<div class="paragraph">
<p>It should be noted, however, that sessions do cause additional operational complexity headaches when deploying hypermedia
servers, which now may need to have shared access to the session state information stored across an entire cluster.  So
Fielding was correct in pointing out that an ideal RESTful system, one that did not violate this constraint, would,
indeed, be simpler and therefore more robust.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_caching_constraint">The Caching Constraint</h4>
<div class="paragraph">
<p>See <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_4">Section 5.1.4</a> for the Caching constraint.</p>
</div>
<div class="paragraph">
<p>This constraint states that a RESTful system should support the notion of caching, with explicit information on the
cache-ability of responses for future requests of the same resource.  This allows both clients as well as intermediary
servers between a given client and final server to cache the results of a given request.</p>
</div>
<div class="paragraph">
<p>As we discussed above, HTTP has a sophisticated caching mechanism via Response headers that is often overlooked or
underutilized when building hypermedia applications.  Given the existence of this functionality, however, it is
easy to see how this constraint is satisfied by the web.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_uniform_interface_constraint">The Uniform Interface Constraint</h4>
<div class="paragraph">
<p>Now we come to the most interesting and, in our opinion, innovative constraint in REST: that of the <em>uniform interface</em>.
This constraint is the source of much of the <em>flexibility</em> and <em>simplicity</em> of a hypermedia system, so we are going to
spend a lot of time on it.</p>
</div>
<div class="paragraph">
<p>See <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">Section 5.1.5</a> for the Uniform Interface
constraint.</p>
</div>
<div class="paragraph">
<p>In this section, Fielding says:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on
a uniform interface between components&#8230;&#8203; In order to obtain a uniform interface, multiple architectural constraints
are needed to guide the behavior of components. REST is defined by four interface constraints: identification of
resources; manipulation of resources through representations; self-descriptive messages; and, hypermedia as the engine
of application state</p>
</div>
</blockquote>
</div>
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>Architectural Styles and the Design of Network-based Software Architectures</cite>
</div>
</div>
<div class="paragraph">
<p>So we have four additional sub-constraints that, taken together, form the Uniform Interface constraint.</p>
</div>
<div class="sect4">
<h5 id="_identification_of_resources">Identification of Resources</h5>
<div class="paragraph">
<p>In a RESTful system, resources should have a unique identifier.  Today the concept of Universal Resource Locators (URLs) is
common, but at the time of Fielding&#8217;s writing they were still relatively new and novel.</p>
</div>
<div class="paragraph">
<p>What might be more interesting today is the notion of a <em>resource</em>, thus being identified: in a RESTful system, <em>any</em> sort of
data that can be referenced, that is, the target of a hypermedia reference, is considered a resource.  URLs, though common
enough today, end up solving the very complex problem of uniquely identifying any and every resource on the internet.</p>
</div>
</div>
<div class="sect4">
<h5 id="_manipulation_of_resources_through_representations">Manipulation of Resources Through Representations</h5>
<div class="paragraph">
<p>In a RESTful system, <em>representations</em> of the resource are transferred between clients and servers.  These
representations can contain both data and metadata about the request (such as &#8220;control data&#8221; like an HTTP
method or response code).  A particular data format or <em>media type</em> may be used to present a given resource to a client,
and that media type can be negotiated between the client and the server.</p>
</div>
<div class="paragraph">
<p>We saw this latter aspect of the uniform interface in the <code>Accept</code> header in the requests above.</p>
</div>
</div>
<div class="sect4">
<h5 id="_self_descriptive_messages">Self-Descriptive Messages</h5>
<div class="paragraph">
<p>The Self-Descriptive Messages constraint, combined with the next one, HATEOAS, form what we consider to be the core of
the Uniform Interface, of REST and why hypermedia provides such a powerful system architecture.</p>
</div>
<div class="paragraph">
<p>The Self-Descriptive Messages constraint requires that, in a RESTful system, messages must be <em>self-describing</em>.</p>
</div>
<div class="paragraph">
<p>This means that <em>all information</em> necessary to both display <em>and also operate</em> on the data being represented must be
present in the response.  In a properly RESTful system, there can be no additional &#8220;side&#8221; information necessary for
client to transform a response from a server into a useful user interface.  Everything must &#8220;be in&#8221; the message itself,
in the form of hypermedia controls.</p>
</div>
<div class="paragraph">
<p>This might sound a little abstract, lets look at a concrete example.</p>
</div>
<div class="paragraph">
<p>Consider two different potential responses from of an HTTP server for the URL <code><a href="https://example.com/contacts/42" class="bare">https://example.com/contacts/42</a></code>.</p>
</div>
<div class="paragraph">
<p>Both responses will return information about a contact, but they will take very different forms.</p>
</div>
<div class="paragraph">
<p>The first implementation returns an HTML representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html lang="en"&gt;
&lt;head&gt;
&lt;h1&gt;Joe Smith&lt;/h1&gt;
&lt;div&gt;
    &lt;div&gt;Email: joe@example.bar&lt;/div&gt;
    &lt;div&gt;Status: Active&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
    &lt;a href="/contacts/42/archive"&gt;Archive&lt;/a&gt;
&lt;/p&gt;
&lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second implementation returns a JSON representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "Joe Smith",
  "email": "joe@example.org",
  "status": "Active"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What can we say about the differences between these two responses?</p>
</div>
<div class="paragraph">
<p>One thing that may initially jump out at you is that the JSON representation is smaller than the HTML
representation.  Fielding notes exactly this trade-off when using a RESTful architecture:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The trade-off, though, is that a uniform interface degrades efficiency, since information is transferred in a
standardized form rather than one which is specific to an application&#8217;s needs.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>Architectural Styles and the Design of Network-based Software Architectures</cite>
</div>
</div>
<div class="paragraph">
<p>So REST <em>trades off</em> representational efficiency for other goals.</p>
</div>
<div class="paragraph">
<p>To understand these other goals, first notice that the HTML representation has a hyperlink in it to navigate to a page
to archive the contact.  The JSON representation, in contrast, does not have this link.</p>
</div>
<div class="paragraph">
<p>What are the ramifications of this fact for a client of the JSON API?</p>
</div>
<div class="paragraph">
<p>What this means is that the JSON API client must know <em>in advance</em> exactly what other URLs (and request methods) are
available for working with the contact information.  If the JSON client is able to update this contact in some way, it
must know how to do so from some source of information <em>external</em> to the JSON message.  Is if the contact has a different
status, say &#8220;Archived&#8221;, does this change the allowable actions?  If so, what are the new allowable actions?</p>
</div>
<div class="paragraph">
<p>The source of all this information might be API documentation, word of mouth or, if the developer controls both the server
and the client, internal knowledge.  But it is <em>outside</em> the message.</p>
</div>
<div class="paragraph">
<p>The hypermedia (or HTML) client, on the other hand, needs only to know how to render the given HTML.  It doesn&#8217;t need to understand
what actions are available for this contact: they are simply encoded <em>within</em> the HTML itself as hypermedia controls.  It doesn&#8217;t need to
understand what the status field means or, in fact, what a contact even is!</p>
</div>
<div class="paragraph">
<p>The browser, our hypermedia client, simply renders the HTML and allows the user, who presumably understands the concept
of a Contact, to make a decision on what action to pursue from the actions made available in the representation.</p>
</div>
<div class="paragraph">
<p>This difference between the two responses demonstrates the crux of REST and hypermedia, what makes them so powerful
 and flexible: clients (that is, web browsers) don&#8217;t need to understand <em>anything</em> about the underlying resources being
represented.</p>
</div>
<div class="paragraph">
<p>Browsers only (only! As if it is easy!) need to understand how to parse and display hypermedia, in this case HTML.  This
gives hypermedia-based systems unprecedented flexibility in dealing with changes to both the backing representations and
to the system itself.</p>
</div>
</div>
<div class="sect4">
<h5 id="_hypermedia_as_the_engine_of_application_state_hateoas">Hypermedia As The Engine of Application State (HATEOAS)</h5>
<div class="paragraph">
<p>The final sub-constraint on the Uniform Interface is that, in a RESTful system, hypermedia should be &#8220;the engine of
application state&#8221;.  This is sometimes abbreviated as &#8220;HATEOAS&#8221;, although Fielding prefers to use the terminology
&#8220;the hypermedia constraint&#8221; when discussing it.</p>
</div>
<div class="paragraph">
<p>This constraint is closely related to the previous self-describing message constraint.  Let us consider again the two different
implementations of the end point <code>/contacts/42</code>, one returning HTML and one returning JSON.  Let&#8217;s update the situation
such that the contact identified by this URL has now been archived.</p>
</div>
<div class="paragraph">
<p>What do our responses look like?</p>
</div>
<div class="paragraph">
<p>The first implementation returns the following HTML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html lang="en"&gt;
&lt;head&gt;
&lt;h1&gt;Joe Smith&lt;/h1&gt;
&lt;div&gt;
    &lt;div&gt;Email: joe@example.bar&lt;/div&gt;
    &lt;div&gt;Status: Archived&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
    &lt;a href="/contacts/42/unarchive"&gt;Unarchive&lt;/a&gt;
&lt;/p&gt;
&lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second implementation returns the following JSON representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "Joe Smith",
  "email": "joe@example.org",
  "status": "Archived"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important point to notice here is that, by virtue of being a self-describing message, the HTML response now shows that
the &#8220;Archive&#8221; operation is no longer available, and a new &#8220;Unarchive&#8221; operation has become available.  The HTML representation
of the contact <em>encodes</em> the state of the application (that is, exactly what can and cannot be done with this particular
representation) in a way that the JSON representation does not.</p>
</div>
<div class="paragraph">
<p>A client interpreting the JSON response must, again, understand not only the general concept of a Contact,
but also specifically what the &#8220;status&#8221; field with the value &#8220;Archived&#8221; means.  It must know exactly what operations
are available on an &#8220;Archived&#8221; contact, to appropriately display them to an end user.  The state of the application,
in this situation is not encoded in the response, but rather in a mix of raw data and side channel information such as
API documentation.</p>
</div>
<div class="paragraph">
<p>Furthermore, in the majority of front end SPA frameworks today, this contact information would live <em>in memory</em> in a
JavaScript object representing a model of the contact.  The DOM would be updated based on changes to this model, that
is, the DOM would &#8220;react&#8221; to changes to this backing JavaScript model.</p>
</div>
<div class="paragraph">
<p>This approach is certainly <em>not</em> using Hypermedia As The Engine Of Application State: rather, it is using a javascript
model as the engine of application state, and synchronizing that model with a server and with the browser.</p>
</div>
<div class="paragraph">
<p>With the HTML approach, the Hypermedia is, indeed, The Engine Of Application State: there is no additional model on the
client side, and all state is expressed directly in the hypermedia, in this case HTML.  As state changes on the server,
it is reflected in the representation (that is, HTML) sent back to the client.  The hypermedia client (a browser) doesn&#8217;t know
anything about contacts, what the concept of &#8220;Archiving&#8221; is, or anything else about the particular domain model for this
response: it simply knows how to render HTML.</p>
</div>
<div class="paragraph">
<p>Because a hypermedia client doesn&#8217;t need to know anything about the server model beyond how to render hypermedia to
a client, it is incredibly flexible with respect to the representations it receives and displays to users.</p>
</div>
</div>
<div class="sect4">
<h5 id="_hateoas_api_churn">HATEOAS &amp; API Churn</h5>
<div class="paragraph">
<p>Because this last point is so important to understand in order to appreciate the flexibility of hypermedia, let&#8217;s look
at a practical example of it in action: consider a situation where a new feature has added the web application of these
two end points.  This feature allows you to send a message to a given Contact.</p>
</div>
<div class="paragraph">
<p>How would this change each of the two responses from the server?</p>
</div>
<div class="paragraph">
<p>The HTML representation might now look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html lang="en"&gt;
&lt;head&gt;
&lt;h1&gt;Joe Smith&lt;/h1&gt;
&lt;div&gt;
    &lt;div&gt;Email: joe@example.bar&lt;/div&gt;
    &lt;div&gt;Status: Active&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
    &lt;a href="/contacts/42/archive"&gt;Archive&lt;/a&gt;
    &lt;a href="/contacts/42/message"&gt;Message&lt;/a&gt;
&lt;/p&gt;
&lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JSON representation, on the other hand, might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "Joe Smith",
  "email": "joe@example.org",
  "status": "Active"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, once again, the JSON representation is unchanged.  There is no indication of this new functionality.  Instead,
a client must <em>know</em> about this change, presumably via some shared documentation between the client and the server.</p>
</div>
<div class="paragraph">
<p>Contrast this with the HTML response.  Because of the uniform interface of the RESTful model and, in particular,
because we are using Hypermedia As The Engine of Application State, no such exchange of documentation is necessary!  Instead,
the client (a browser) simply renders the new HTML with this operation in it, making this operation available for the end user
without any additional coding changes.</p>
</div>
<div class="paragraph">
<p>A pretty neat trick!</p>
</div>
<div class="paragraph">
<p>Now, in this case, if the JSON client is not properly updated, the error state is relatively benign: a new bit of functionality
is simply not made available to users.  But consider a more severe change to the API: what if the archive functionality
was removed?  Or what if the URLs or the HTTP methods for these operations changed in some way?</p>
</div>
<div class="paragraph">
<p>In this case, the JSON client may be broken in a much more serious manner.</p>
</div>
<div class="paragraph">
<p>The HTML response, however, would simply be updated to exclude the removed options or to update the URLs used for them.  Clients
would see the new HTML, display it properly, and allow users to select whatever the new set of operations happens to be.  Once
again, the uniform interface of REST has proven to be extremely flexible: despite a potentially radically new layout
for our hypermedia API, clients continue to keep working.</p>
</div>
<div class="paragraph">
<p>An important fact falls out of this:  because of this flexibility, hypermedia APIs <em>do not have the versioning headaches
that JSON Data APIs do</em>.</p>
</div>
<div class="paragraph">
<p>Once a Hypermedia-Driven Application has been &#8220;entered into&#8221; (that is, loaded through some entry point URL), all functionality
and resources are surfaced through self-describing messages.  Therefore, there is no need to exchange documentation with
the client: the client simply renders the hypermedia (in this case HTML) and everything works out.  When a change occurs,
there is no need to create a new version of the API: clients simply retrieve updated hypermedia, which encodes the new
operations and resources in it, and display it to users to work with.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_layered_system">Layered System</h4>
<div class="paragraph">
<p>The final &#8220;required&#8221; constraint on a RESTful system that we will consider is The Layered System constraint.  This constraint can be found in <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_6">Section 5.1.6</a> of Fielding&#8217;s dissertation.</p>
</div>
<div class="paragraph">
<p>To be frank, after the excitement of the uniform interface constraint, the &#8220;layered system&#8221; constraint is a bit of a
let down.  But it is still worth understanding and it is actually utilized effectively by The web.  The constraint
requires that a RESTful architecture be &#8220;layered&#8221;, allowing for multiple servers to act as intermediaries between
a client and the eventual &#8220;source of truth&#8221; server.</p>
</div>
<div class="paragraph">
<p>These intermediary servers can act as proxies, transform intermediate requests and responses and so forth.</p>
</div>
<div class="paragraph">
<p>A common modern example if this layering feature of REST is the use of Content Delivery Networks (CDNs) to deliver unchanging
static assets to clients more quickly, by storing the response from the origin server in intermediate servers more
closely located to the client making a request.</p>
</div>
<div class="paragraph">
<p>This allows content to be delivered more quickly to the end user and reduces load on the origin server.</p>
</div>
<div class="paragraph">
<p>Nothing nearly as exciting for web application developers as the uniform interface, at least in our opinion, but useful
nonetheless.</p>
</div>
</div>
<div class="sect3">
<h4 id="_an_optional_constraint_code_on_demand">An Optional Constraint: Code-On-Demand</h4>
<div class="paragraph">
<p>We called The Layered System constraint the final "required" constraint because
Fielding mentions one additional constraint on a RESTful system. This Code On Demand constraint is somewhat awkwardly described as "optional" (Section 5.1.7).</p>
</div>
<div class="paragraph">
<p>In this section, Fielding says:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>REST allows client functionality to be extended by downloading and executing code in the form of applets or scripts. This
simplifies clients by reducing the number of features required to be pre-implemented. Allowing features to be downloaded
after deployment improves system extensibility. However, it also reduces visibility, and thus is only an optional constraint
within REST.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>Architectural Styles and the Design of Network-based Software Architectures</cite>
</div>
</div>
<div class="paragraph">
<p>So, scripting was and is a native aspect of the original RESTful model of the web, and thus
should of course be allowed in a Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>However, in a Hypermedia-Driven Application the presence of scripting should <em>not</em> change the fundamental networking
model: hypermedia should still be the engine of application state, server communication should still consist of
hypermedia exchanges rather than, for example, JSON data exchanges, and so on.</p>
</div>
<div class="paragraph">
<p>Today, unfortunately, the scripting layer of the web, JavaScript, is quite often used to <em>replace</em>, rather than augment
the hypermedia model.  We will elaborate in a later chapter what scripting that does not replace the underlying hypermedia
system of the web looks like.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">2.3. Conclusion</h3>
<div class="paragraph">
<p>After this deep dive into Chapter 5 of Roy Fielding&#8217;s dissertation, we hope you have much better understanding of REST,
and in particular, of the uniform interface and HATEOAS. We hope you can see <em>why</em> these characteristics make hypermedia
systems so flexible.</p>
</div>
<div class="paragraph">
<p>If you didn&#8217;t really appreciate what REST and HATEOAS meant before now, don&#8217;t feel bad: it took some of us over a decade of
working in web development, and building a hypermedia-oriented library to boot, to realize just how
special HTML, hypermedia and the web is!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_effective_html">3. Effective HTML</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re here, you can probably write some HTML.
The web is <em>the</em> hypermedia system after all, the one this book will spend the most time with,
and HTML is its format.</p>
</div>
<div class="paragraph">
<p>As with every aspect of the web, it has been exapted and reinterpreted by web developers in myriad ways.
Is it a document format?
Is it for applications?
Is it a rendering system?
Is it (gasp!) a programming language?
These are the contenders in the Eternal Debate of the web development world,
and none will ever win because none of them are right.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-718</cite>
</div>
</div>
<div class="paragraph">
<p>HTML, as well as hypermedia before and after it, removes the distinction between the information being accessed and the application used to access it. HTML is for documents, insofar as you&#8217;re willing to adopt a broad definition of &#8220;document&#8221;, and it is for applications, ones that are interwoven with the data they process.</p>
</div>
<div class="paragraph">
<p>HTML is a hypermedium.</p>
</div>
<div class="paragraph">
<p>In this chapter, we&#8217;ll learn about some HTML practices that are either skipped over,
or shoved in people&#8217;s faces as <em>semantic</em> or <em>accessible</em> without understanding why.
We&#8217;ll learn why HTML is far cooler than a programming language.</p>
</div>
<div class="sect2">
<h3 id="_why_relearn_html">3.1. Why relearn HTML?</h3>
<div class="paragraph">
<p>Have you noticed that a lot of websites are bad?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pages are bloated with <code>&lt;div&gt;</code> soup, and stylesheets are big as a result of trying to select elements in that mess. The result is slow loading times.<span id="_footnote_1" class="footnote"><a href="https://almanac.httparchive.org/en/2020/markup" class="bare">https://almanac.httparchive.org/en/2020/markup</a></span> Other than <code>&lt;div&gt;</code> being the most common element, the HTTP Archive Web Almanac found that 0.06% of pages surveyed in 2020 contained the nonexistent <code>&lt;h7&gt;</code> element. 0.0015% used <code>&lt;h8&gt;</code>.</p>
</li>
<li>
<p>Websites, including websites containing public data or results of publicly-funded research, are impossible to scrape programmatically.</p>
</li>
<li>
<p>So-called MVPs (minimum viable product) are released in open beta while being completely unusable by vast swathes of people&#8201;&#8212;&#8201;UX not just buggy, but nonexistent.<span id="_footnote_2" class="footnote"><a href="https://adrianroselli.com/2022/11/accessibility-gaps-in-mvps.html" class="bare">https://adrianroselli.com/2022/11/accessibility-gaps-in-mvps.html</a></span> Is an inaccessible product &#8220;viable&#8221;?</p>
</li>
<li>
<p>Search engines have a hard time extracting useful information from a page, and rank that page lower as a result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several disparate reasons for these issues, but the neglect of HTML is a significant one.</p>
</div>
<div class="paragraph">
<p>People who write HTML are referred to in Web platform specifications as "`authors`."
This sells our lot short by quite a bit, however;
from day to day, the average web developer might take on the role of
typesetter, copy editor, graphic designer, and of course, programmer.
Thus, anyone in the business of making websites should take HTML seriously.</p>
</div>
<div class="paragraph">
<p>The way most of us write HTML (and likely the way many of us learned it) is a very tight feedback loop:
we write something, <em>Alt-Tab</em> to the browser to see if it works, and go back to edit.
It&#8217;s an amazingly fast and enjoyable way to build, but the way it&#8217;s often practiced has a significant flaw:
<em>If it looks right, it gets shipped.</em>
The developer is focusing almost exclusively to their own UI needs.
Any other way of using a website becomes an afterthought.</p>
</div>
<div class="paragraph">
<p>Thus, if you care about machine readability, or human readability, or page weight, what you should do is <em>test</em>.</p>
</div>
<div class="paragraph">
<p>Did you think we were going to talk about semantic HTML? Keep reading for that, but alas, it&#8217;s no substitute for testing. Test manually. Test automatically. Test with screenreaders, test with a keyboard, test on different browsers and hardware, run linters (while coding and/or in CI). Read the markup&#8201;&#8212;&#8201;the markup being sent to browsers, not the templates and code you write. Know exactly what any type of hypermedia client is doing in any circumstance.</p>
</div>
<div class="paragraph">
<p>So where does HTML and the s-word come in?</p>
</div>
<div class="paragraph">
<p>Easy. Writing good, spec-compliant HTML lets browsers do a bunch of work for you. Furthermore, even when they don&#8217;t, it makes it easier to write scripts that do. Fewer issues will be found during testing and you can release faster. When issues do come up, you can often fix them more easily by rewriting semantic HTML as opposed to heaping JavaScript and ARIA attributes over everything.</p>
</div>
<div class="paragraph">
<p>Good HTML will not absolve you from doing your job, but it will make it easier.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_s_word">3.2. The S word</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Gretchen, stop trying to make fetch happen! It&#8217;s not going to happen!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; _Mean Girls_ (2004)
</div>
</div>
<div class="paragraph">
<p>In human language, a word can only have a certain meaning if some group of people know it to have that meaning.
You could define your own words and use them, the aforementioned Ted Nelson and company really liked to, but it&#8217;s difficult.
Providing a definition when you use it is not enough;
you also need an audience interested enough to read and remember that definition.</p>
</div>
<div class="paragraph">
<p>As this applies to computer languages too, any hypermedia format which lets documents define their own elements is an infinite universe of &#8220;fetch&#8221;-es to make happen.
Thus, let us renounce the schematamania that plagues many hypermedia discussions.
Instead, when we talk about semantics, we refer to the simple act of using elements in accordance with their agreed-upon meaning.</p>
</div>
<div class="paragraph">
<p>Instead of being extensible through schemas or namespaces, or whatever DTDs are, HTML is extended in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Ad-hoc extensibility.</strong> HTML is a fault-tolerant language, choosing to ignore things it doesn&#8217;t recognize instead of throwing errors.
This means you can use unspecified attributes.
htmx relies on this heavily.
If extensions see common acceptance, they might even be incorporated into specifications! (We can dream.)</p>
</li>
<li>
<p><strong>Specified extension points.</strong> Things like classes, <code>&lt;meta&gt;</code> tags, custom elements and <code>data-</code> attributes are made for custom data.
They can be used to build meta-languages embedded in HTML.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This might seem like a downgrade, and an anxiety-inducing one at that.
Think of the name collisions!
Indeed, it has some significant compromises, but it also correctly acknowledges that defining custom semantics without prior agreement between all parties is a fiction.
A flexible format --not an infinity of namespaces with URLs pointing to nothing --is &#8220;software design on the scale of decades&#8221;.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s be real, after all --out of all the sites using &#8220;Open Graph&#8221; tags, how many use the appropriate <code>prefix</code> attribute? How many of their developers even know the <code>prefix</code> attribute exists?</p>
</div>
</div>
<div class="sect2">
<h3 id="_html_is_for_humans_first">3.3. HTML is for humans first</h3>
<div class="paragraph">
<p>An HTML file is not a program that produces a human-readable document.
It <em>is</em> the document.</p>
</div>
<div class="paragraph">
<p>Treat HTML semantics not as a technical specification, but as something close to a <em>style guide</em>.
The meanings of HTML elements and attributes
(besides a few like <code>&lt;meta&gt;</code> and <code>&lt;script&gt;</code>)
are derived from conventions of human communication:
intractably fuzzy, and culturally dependent.
They have quite specific meanings in the spec,
but these meanings can be used sarcastically, hyperbolically, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The relationship between the content and the markup means good HTML is actually quite expensive.
If a site has a developer/author split, authors will need to work closely with developers or know HTML themselves to produce markup that reflects their intended meaning.
This is rarely feasible, except for sites written, designed and coded by one person.
Furthermore, for internationalized sites, content in different languages being injected into the same elements can degrade markup quality as stylistic conventions differ between languages.
Dishearteningly, but understandably, it&#8217;s an expense few organizations can spare.</p>
</div>
<div class="paragraph">
<p>Thus, we don&#8217;t demand that every site makes the "most semantic" HTML.
What&#8217;s most important is to avoid <em>wrong</em> HTML---it&#8217;s better to fall back on a more generic element than be precisely incorrect.
Sometimes, div is fine.</p>
</div>
<div class="paragraph">
<p>If you have the resources, however, putting more care in your HTML will produce a more polished site.
Much like style guides, well-written semantic HTML gives prestige to a document, even when few people notice it.
It can also make your HTML easier to maintain.</p>
</div>
<div class="paragraph">
<p>Good HTML is also good for non-visual usage.
When working on accessibility, you may find yourself trying and failing to please screen readers.
Especially if ARIA is involved, it can be extremely frustrating to do what seems like the right thing and have assistive tools not do what you expect.
What helps with this frustration is to stop treating hypermedia exchanges as machine-to-machine communication.
When browsers misbehave, we complain, but most of us don&#8217;t just down tools and concede:
"I did as the spec told me; it&#8217;s not my fault that the website is broken, my work here is done."
We get in there and fix it.
So, instead of banging your head against a wall, focus on people, not the tools they use.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t write HTML for browsers.<br>
Don&#8217;t write HTML for assistive tools.<br>
Don&#8217;t write HTML for validators.<br>
HTML is not <em>for</em> them.<br>
HTML is for humans.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Author&#8217;s note</div>
        <div class="paragraph">
<p>The rest of this chapter is currently incomplete and <em>very</em> unorganized.</p>
</div>
    </aside>
</div>
<div class="sect2">
<h3 id="_using_the_spec">3.4. Using the spec</h3>
<div class="paragraph">
<p>While the big spec document with all the algorithms is probably better for smugly linking to people in chatrooms,
don&#8217;t miss out on the developer-friendly version at <a href="https://html.spec.whatwg.org/dev/" class="bare">https://html.spec.whatwg.org/dev/</a>.</p>
</div>
<div class="paragraph">
<p>For readers with better things to do, section 4 features a list of all tags in HTML.
It includes what tags mean, where they can occur, and what they are allowed to contain.
It even tells you when you&#8217;re allowed to leave out closing tags!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
This is a valid HTML document.</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_revisit_the_html5_elements">Revisit the &#8220;HTML5 elements&#8221;</h4>
<div class="quoteblock">
<blockquote>
The beginning of wisdom is to call things by their right names.
</blockquote>
<div class="attribution">
&#8212; Confucius
</div>
</div>
<div class="paragraph">
<p>A set of elements introduced with HTML5 have become a symbol of semantic markup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>section</p>
</li>
<li>
<p>article</p>
</li>
<li>
<p>nav</p>
</li>
<li>
<p>header</p>
</li>
<li>
<p>footer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Don&#8217;t write HTML with the mindset of
&#8220;The more of these elements there are, the more semantic it is.&#8221;
Otherwise, the results might look somewhat like this:</p>
</div>
<div class="listingblock">
<div class="title">HTMHell, <span class="cite">#10 &lt;section&gt; is no replacement for &lt;div&gt;</span>, <a href="https://www.htmhell.dev/10-section-is-no-replacement-for-div/" class="bare">https://www.htmhell.dev/10-section-is-no-replacement-for-div/</a></div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;section id="page-top"&gt;
  &lt;section data-section-id="page-top" style="display: none;"&gt;&lt;/section&gt;
&lt;/section&gt;
&lt;main&gt;
  &lt;section id="main-content"&gt;
    &lt;header id="main-header"&gt;
      &lt;h1&gt;...&lt;/h1&gt;
      &lt;section class="container-fluid"&gt;
        &lt;section class="row"&gt;
          &lt;article class="content col-sm-12"&gt;
            &lt;section class="content-inner"&gt;
              &lt;div class="content__body"&gt;
                &lt;article class="slider"&gt;
                  &lt;section class="slide"&gt; … &lt;/section&gt;
                &lt;/article&gt;
              &lt;/div&gt;
            &lt;/section&gt;
          &lt;/article&gt;
        &lt;/section&gt;
      &lt;/section&gt;
    &lt;/header&gt;
  &lt;/section&gt;
&lt;/main&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes, <code>&lt;div&gt;</code> really is fine.</p>
</div>
<div class="paragraph">
<p>However, while you shouldn&#8217;t abuse advanced HTML, you shouldn&#8217;t restrict yourself either.
Instead, learn the meaning of every tag and consider each another tool in your tool chest.
(With the 113 elements currently defined in the spec, it&#8217;s more of a tool shed).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_html_tips_and_tricks">3.5. HTML tips and tricks</h3>
<div class="sect3">
<h4 id="_label_your_inputs_one_way_or_another">Label your inputs, one way or another</h4>
<div class="paragraph">
<p><code>&lt;input&gt;</code> elements always need to be labelled. However, they don&#8217;t necessarily need a visible <code>&lt;label&gt;</code> element. There are other ways to label:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Use a label, but hide it visually with CSS:</strong> Use the visually hidden utility for this.</p>
</li>
<li>
<p><strong>Use <code>aria-label</code>:</strong></p>
<div class="listingblock">
<div class="title">Search form using aria-label</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form&gt;
  &lt;input type="search" aria-label="Search for..."&gt;
  &lt;button&gt;Search&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Use <code>aria-labelledby</code>:</strong>
This can be a good option for inputs where a nearby element provides context.</p>
<div class="listingblock">
<div class="title">Search form using aria-labelledby</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form&gt;
  &lt;input type="search" aria-labelledby="search-button"&gt;
  &lt;button id="search-button"&gt;Search&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_dont_use_figcaption_for_alt_text">Don&#8217;t use &lt;figcaption&gt; for alt-text</h4>
<div class="paragraph">
<p>Use the <code>alt</code> attribute instead! Figure captions shouldn&#8217;t regurgitate the information in an image. Instead, they should be used to give context or provide metadata such as source or date. The <code>alt</code> attribute, on the other hand, should be a substitute for the image, describing the relevant aspects of what is depicted for the benefit of people who can&#8217;t view it.</p>
</div>
<div class="paragraph">
<p>Captions might be misused for alt text when the author wants the alt text to be visible as text. To achieve this, some social media platforms use an &#8220;ALT&#8221; button that opens the alt text in a popup window. The main drawback of this approach is that you need to implement a popup window. You could also use a <code>&lt;p&gt;</code> after the image with <code>aria-hidden</code> on it.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The <code>alt</code> attribute</div>
        <div class="paragraph">
<p>They say a picture is worth a thousand words. How are we supposed to produce an acceptable substitute in just a few sentences?</p>
</div>
<div class="paragraph">
<p>When writing alt text, you should only provide the information that is relevant. This means that the alt text should not be stored with the image (as is unfortunately the case with many CMSs) but in the document --because different aspects of an image are relevant in different contexts.</p>
</div>
<div class="paragraph">
<p>TODO link resources on alt text.</p>
</div>
    </aside>
</div>
<div class="sect3">
<h4 id="_write_useful_link_text">Write useful link text</h4>
<div class="paragraph">
<p>Wherever possible, the text of a link should describe what the link points to without much context needed. Of course, you might need to alter it to fit a sentence structure, but you should avoid links that don&#8217;t give information other than &#8220;this is a link&#8221;.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Don&#8217;t
</td>
<td class="hdlist2">
<p>For user records, [click here]</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Do
</td>
<td class="hdlist2">
<p>[User records]</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_aria_is_easy_as_long_as_you_stick_to_the_basics">ARIA is easy --as long as you stick to the basics</h4>

</div>
</div>
<div class="sect2">
<h3 id="_extending_html">3.6. Extending HTML</h3>
<div class="sect3">
<h4 id="_data_attributes">Data attributes</h4>

</div>
<div class="sect3">
<h4 id="_microformats">Microformats</h4>
<div class="paragraph">
<p><a href="https://microformats.org/" class="bare">https://microformats.org/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_elements">Custom elements?</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_web_1_0_application">4. A Web 1.0 Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To start our journey into Hypermedia-Driven Applications, we are going to create a simple contact management web
application called Contact.app.  We will start with a basic, &#8220;Web 1.0-style&#8221; Multi-Page Application (MPA), in the grand
CRUD (Create, Read, Update, Delete) tradition.  It will not be the best contact management application in the world.  But
that&#8217;s OK because it will be simple (a great virtue of web 1.0 applications!) and it will do its job.</p>
</div>
<div class="paragraph">
<p>This application will also be easy to incrementally improve in the coming chapter by utilizing the hypermedia-oriented
library htmx.</p>
</div>
<div class="paragraph">
<p>By the time we are finished building and enhancing the application, over the next few chapters, it will have some very
slick features that most developers today would assume requires the use of a heavy JavaScript framework.</p>
</div>
<div class="sect2">
<h3 id="_picking_a_web_stack_to_use">4.1. Picking A &#8220;Web Stack&#8221; To Use</h3>
<div class="paragraph">
<p>In order to demonstrate how web 1.0 applications works, we need to pick a server-side language and a library for
handling HTTP requests.  Colloquially, this is called our &#8220;Server-Side&#8221; or &#8220;Web&#8221; stack, and there are literally hundreds
of options to choose from, many with passionate followings.  You probably have a web framework that you prefer and, while
we wish we could write this book for every possible stack out there, in the interest of simplicity (and sanity) we can only pick one.</p>
</div>
<div class="paragraph">
<p>For this book we are going to use the following stack:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We will use <a href="https://www.python.org/">Python</a> as our programming language.</p>
</li>
<li>
<p>We will use <a href="https://palletsprojects.com/p/flask/">Flask</a> as our web framework, allowing us to connect HTTP requests to python logic.</p>
</li>
<li>
<p>We will use <a href="https://palletsprojects.com/p/jinja/">Jinja2</a> for our server-side templating language, allowing us to render HTML responses using a familiar
and intuitive syntax.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Why did we pick this particular stack?</p>
</div>
<div class="paragraph">
<p>First, Python is the most popular programming language in the world, as of this writing, according to the
<a href="https://www.tiobe.com/tiobe-index/">TIOBE index</a>, a respected measure of programming language popularity.
Perhaps more importantly, Python is very easy to read even if you aren&#8217;t very familiar with it.</p>
</div>
<div class="paragraph">
<p>Flask was chosen as the web framework because it is very simple and does not impose a lot of structure on top of the
basics of HTTP request handling. This bare-bones approach isn&#8217;t for everyone: in the Python community, for example, many people
prefer the &#8220;Batteries Included&#8221; nature of Django, which supplies much more functionality out of the box than Flask does.</p>
</div>
<div class="paragraph">
<p>For teaching purposes, and to minimize the conceptual burden for non-Python developers, we feel that an un-opinionated
and lighter-weight library will make it easier for readers to follow along.  The focus of this book is on the <em>hypermedia
exchanges</em>, rather than deeper server-side functionality like working with a database, and by using Flask we are able
to keep the book focused on that aspect.</p>
</div>
<div class="paragraph">
<p>Jinja2 templates were picked because they are the default templating language for Flask.  They are simple enough and
similar enough to most other server-side templating languages that most people who are familiar with any server-side
(or client-side) templating library should be able to understand them quickly and easily.</p>
</div>
<div class="paragraph">
<p>With this stack we will be rendering HTML <em>on the server-side</em> to return to clients, rather than producing JSON.  This
is the traditional approach to building web applications, but, with the rise of SPAs, is not as widely used a technique
as it once was.  Today, as people are rediscovering this approach to building web applications, the term &#8220;Server-Side
Rendering&#8221; or SSR is emerging as the way that people talk about this style of templating.  This is in contrast with
&#8220;Client-Side Rendering&#8221;, that is, rendering templates in the browser with data retrieved in JSON form from the server,
as is common in SPA libraries.</p>
</div>
<div class="paragraph">
<p>In Contact.app we will intentionally keep things as simple as possible to maximize the teaching value of our code: it
won&#8217;t be perfectly factored code, and it certainly won&#8217;t be the most beautiful web application ever built, but it will
be easy to follow for readers even if they have little Python experience, and it should be easy to translate the application
and the techniques demonstrated into your preferred programming language and web framework.</p>
</div>
</div>
<div class="sect2">
<h3 id="_python">4.2. Python</h3>
<div class="paragraph">
<p>Since this book is intended to teach how hypermedia can be used effectively, we aren&#8217;t going to do deep dives into
the various technologies we use <em>around</em> that hypermedia.  This has some obvious drawbacks: if you aren&#8217;t comfortable
with Python, for example, some example python code in the book may be a bit confusing or mysterious at first.</p>
</div>
<div class="paragraph">
<p>If you feel like you need a quick introduction to the language before diving into the code, we recommend the following
books/websites:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nostarch.com/python-crash-course-3rd-edition">Python Crash Course</a> from No Starch Press</p>
</li>
<li>
<p><a href="https://learnpythonthehardway.org/python3/">Learn Python The Hard Way</a> by Zed Shaw</p>
</li>
<li>
<p><a href="https://www.py4e.com/">Python For Everybody</a> by Dr. Charles R. Severance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That being said, we think most web developers, even developers who are unfamiliar with Python, should be able to follow
along in the code. Most of the authors hadn&#8217;t written very much Python before writing this book, and we got the hang of
it pretty quickly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_introducing_flask_our_first_route">4.3. Introducing Flask: Our First Route</h3>
<div class="paragraph">
<p>Flask is a very simple but flexible web framework for Python.  Just like this book isn&#8217;t a Python book, it isn&#8217;t a Flask book
either, so we will only go into as much detail about it as is necessary to show off hypermedia concepts.  However, unlike
Python, which is similar in many ways to other programming languages, Flask might be a bit different than web frameworks
you are familiar with, so we will need to do a bit more of an introduction to it in order to prepare you for the coming
chapters.</p>
</div>
<div class="paragraph">
<p>Thankfully, Flask is simple enough that most web developers shouldn&#8217;t have a problem following along, so let&#8217;s go over
the core ideas.</p>
</div>
<div class="paragraph">
<p>A Flask application consists of a series of <em>routes</em> tied to functions that execute when an HTTP request to a given path is
made.  It uses a Python feature called &#8220;decorators&#8221; to declare the route that will be handled, which is then followed by
a function to handle request to that route.  We will often use the term &#8220;handler&#8221; to refer to the functions associated
with a route.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create our first route definition, a simple &#8220;Hello Flask&#8221; route.  In the following python code you will see the
<code>@app</code> symbol.  This is the flask decorator that allows us to set up our routes.  Don&#8217;t worry too much about
how decorators work in Python, just know that this feature allows us to map a given <em>path</em> to a particular function
(i.e. handler).  The flask application, when started, will take HTTP requests and look up the matching handler and
invoke it.</p>
</div>
<div class="paragraph">
<p>Here is what the code looks like:</p>
</div>
<div class="listingblock">
<div class="title">A Simple &#8220;Hello World&#8221; Route</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/") <b class="conum">(1)</b>
def index(): <b class="conum">(2)</b>
    return "Hello World!" <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Establishes we are mapping the <code>/</code> path as a route</p>
</li>
<li>
<p>The next method is the handler for that route</p>
</li>
<li>
<p>Returns the string &#8220;Hello World!&#8221; to the client</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>route()</code> method on the Flask decorator takes an argument: the path you wish the route to handle.  Here we
pass in the root or <code>/</code> path, as a string, to handle requests to the root path.</p>
</div>
<div class="paragraph">
<p>This route declaration is then followed by a simple function definition, <code>index()</code>.  In Python, decorators invoked in
this manner apply to the function immediately following them.  Therefore, this function becomes the &#8220;handler&#8221; for that
route, and will be executed when an HTTP request to the given path is made.</p>
</div>
<div class="paragraph">
<p>Note that the name of the function doesn&#8217;t matter, we can call it whatever we&#8217;d like so long as it is unique.  In this
case we chose <code>index()</code> because that fits with the route we are handling: the root &#8220;index&#8221; of the web
application.</p>
</div>
<div class="paragraph">
<p>So we have the <code>index()</code> function immediately following our route definition for the root, and this will become the
handler for the root URL in our web application.</p>
</div>
<div class="paragraph">
<p>The handler in this case is dead simple, it just returns a string, &#8220;Hello Flask!&#8221;, to the client.  This isn&#8217;t even
hypermedia yet, but, nonetheless, a browser will render it just fine:</p>
</div>
<div id="figure-1-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/figure_2-1_hello_world.png" alt="figure 2 1 hello world">
</div>
<div class="title">Figure 1. Hello Flask!</div>
</div>
<div class="paragraph">
<p>Great, there&#8217;s our first step into Flask, showing the core technique we are going to use to respond to HTTP requests:
routes mapped to handlers.</p>
</div>
<div class="paragraph">
<p>For Contact.app, rather than rendering &#8220;Hello Flask!&#8221; at the root path, we are going to do something a little fancy:
we are going to redirect to another path, the <code>/contacts</code> path.  Redirects are a feature of HTTP that allow you to
redirect a client to another location with an HTTP response.</p>
</div>
<div class="paragraph">
<p>We are going to display a list of contacts as our root page, and, arguably, redirecting to the <code>/contacts</code> path to
display this information is a bit more consistent with notion of resources with REST.  This is a judgement call on our
part, and not something we feel is too important, but it makes sense in terms of routes we will set up later in the
application.</p>
</div>
<div class="paragraph">
<p>To change our &#8220;Hello World&#8221; route to a redirect, we only need to change one line of code:</p>
</div>
<div class="listingblock">
<div class="title">Changing &#8220;Hello World&#8221; to a Redirect</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/")
def index():
    return redirect("/contacts") <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Update to a call to <code>redirect()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now the <code>index()</code> function simply returns the result of calling the Flask-supplied <code>redirect()</code> function with the path
we with to redirect the user to.  In this case the path is <code>/contacts</code>, and we pass this path in as a string argument.
Now, if you navigate to the root path, <code>/</code>, our Flask application will forward you on to the <code>/contacts</code> path.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contact_app_functionality">4.4. Contact.app Functionality</h3>
<div class="paragraph">
<p>OK, now that we have our feet under us with respect to defining routes, let&#8217;s get down to specifying and then implementing
our web application.</p>
</div>
<div class="paragraph">
<p>What will Contact.app do?</p>
</div>
<div class="paragraph">
<p>Initially, it will provide the following functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide a list of contacts, including first name, last name, phone and email address</p>
</li>
<li>
<p>Provide the ability to search the list of contacts</p>
</li>
<li>
<p>Provide the ability to add a new contact to the list</p>
</li>
<li>
<p>Provide the ability to view the details of a contact on the list</p>
</li>
<li>
<p>Provide the ability to edit the details of a contact on the list</p>
</li>
<li>
<p>Provide the ability to delete a contact from the list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, as you can see, Contact.app is a fairly basic CRUD application, the sort of application that is perfect for an old-school
web 1.0 approach.</p>
</div>
<div class="paragraph">
<p>Note that the source code of Contact.app is available on <a href="https://github.com/bigskysoftware/contact-app">GitHub</a>.</p>
</div>
<div class="sect3">
<h4 id="_showing_a_searchable_list_of_contacts">Showing A Searchable List Of Contacts</h4>
<div class="paragraph">
<p>Let&#8217;s look at our first real bit of functionality: the ability to show all the contacts in our system in a list (really,
in a table).</p>
</div>
<div class="paragraph">
<p>This functionality is going to be found at the <code>/contacts</code> path, which is the path our previous route is redirecting to.</p>
</div>
<div class="paragraph">
<p>We will use Flask to route the <code>/contacts</code> path to a handler function, <code>contacts()</code>. This function is going to do one of
two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is a search term found in the request, it will filter down to only contacts matching that term</p>
</li>
<li>
<p>If not, it will simply list all contacts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is a common approach in web 1.0 style applications: the same URL that displays all instances of some resource
also serves as the search results page for those resources.  Taking this approach makes it easy to reuse the list
display that is common to both types of request.</p>
</div>
<div class="paragraph">
<p>Here is what the code looks like for this handler:</p>
</div>
<div class="listingblock">
<div class="title">Server Side Search</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q") <b class="conum">(1)</b>
    if search is not None:
        contacts_set = Contact.search(search) <b class="conum">(2)</b>
    else:
        contacts_set = Contact.all() <b class="conum">(3)</b>
    return render_template("index.html", contacts=contacts_set) <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Look for the query parameter named <code>q</code>, which stands for &#8220;query&#8221;</p>
</li>
<li>
<p>If the parameter exists, call the <code>Contact.search()</code> function with it</p>
</li>
<li>
<p>If not, call the <code>Contact.all()</code> function</p>
</li>
<li>
<p>pass the result to the <code>index.html</code> template to render to the client</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We see the same sort of routing code we saw in our first example, but we have a more elaborate handler function.
First, we check to see if a search query parameter named <code>q</code> is part of the request.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Query Strings</dt>
<dd>
<p>A &#8220;query string&#8221; is  part of the URL specification, and you are probably familiar with this term, but
for those who are not, let&#8217;s review what it is.  Here is an example URL with a query string in it:
<code><a href="https://example.com/contacts?q=joe" class="bare">https://example.com/contacts?q=joe</a></code>.  The query string is everything after the <code>?</code> and, you can see, it has a
name-value pair format.  In this URL, the query parameter <code>q</code> is set to the string value <code>joe</code>.  In plain HTML, a
query string can be included in a request either by being hardcoded in an anchor tag or, more dynamically, by
using a form tag with a <code>GET</code> request.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To return to our Flask route, if a query parameter named <code>q</code> is found, we call out to the <code>search()</code> method on a
<code>Contact</code> model object to do the actual contact search and return all the matching contacts.</p>
</div>
<div class="paragraph">
<p>If the query parameter is <em>not</em> found, we simply get all contacts by invoking the <code>all()</code> method on the <code>Contact</code> object.</p>
</div>
<div class="paragraph">
<p>Finally, we then render a template, <code>index.html</code> that displays the given contacts, passing in the results of whichever
of these two functions we ended up calling.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">A Note On The Contact Class</div>
        <div class="paragraph">
<p>The <code>Contact</code> Python class being used above is obviously a very important part of our overall system.  It is the &#8220;domain
model&#8221; or just &#8220;model&#8221; class for our application, providing the &#8220;business logic&#8221; around the management of Contacts.
However, the <em>implementation</em> of the <code>Contact</code> class is not relevant to Contact.app as a Hypermedia-Driven Application,
so we will not be looking at the internals of the class.</p>
</div>
<div class="paragraph">
<p>It could be working with a database (it isn&#8217;t) or a simple flat file (it is), but it doesn&#8217;t really matter.  We want
to leave that part of the system aside, and treat it as a black box.  We will present contacts as a resource to our
Hypermedia-Driven front end, but not concern ourselves with the internal details of the model.</p>
</div>
<div class="paragraph">
<p>We ask you to simply accept that it is a &#8220;normal&#8221; domain model class, and the methods on it act in the &#8220;normal&#8221; manner.
We will focus on <code>Contact</code> as a <em>resource</em> and how to effectively provide hypermedia representations
of that resource to clients.</p>
</div>
    </aside>
<div class="sect4">
<h5 id="_the_list_search_templates">The List &amp; Search Templates</h5>
<div class="paragraph">
<p>Now that we have our handler logic written, we need to take a look at the templates that we are going to use to render
HTML in our response to the client.  At a high level, our HTML response needs to have the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A list of any matching or all contacts</p>
</li>
<li>
<p>A search box that a user may type a search term into and then submit for searches</p>
</li>
<li>
<p>A bit of surrounding &#8220;chrome&#8221;: a header and footer for the website that will be the same regardless of the page you
are on</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We are using the Jinja2 templating language, which has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We can use double-curly braces, <code>{{ }}</code>,  to embed expression values in the template.</p>
</li>
<li>
<p>we can use curly-percents, <code>{% %}</code>, for directives, like iteration or including other content.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Beyond this basic syntax, Jinja2 is very similar to other templating languages used to generate content, and should
be easy to follow for most web developers.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the first few lines of code in the <code>index.html</code> template:</p>
</div>
<div class="listingblock">
<div class="title">Start of index.html</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{% extends 'layout.html' %} <b class="conum">(1)</b>

{% block content %} <b class="conum">(2)</b>

    &lt;form action="/contacts" method="get" class="tool-bar"&gt;  <b class="conum">(3)</b>
            &lt;label for="search"&gt;Search Term&lt;/label&gt;
            &lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"/&gt; <b class="conum">(4)</b>
            &lt;input type="submit" value="Search"/&gt;
     &lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the layout template for this template</p>
</li>
<li>
<p>Delimit the content to be inserted into the layout</p>
</li>
<li>
<p>Create a search form that will issue an HTTP <code>GET</code> to <code>/contacts</code></p>
</li>
<li>
<p>Create an input that a query can be typed into to search contacts</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first line of code references a base template, <code>layout.html</code>, with the <code>extends</code> directive.  This layout
template provides the layout for the page (again, sometimes called &#8220;the chrome&#8221;): it wraps the template content in an
<code>&lt;html&gt;</code> tag, imports any necessary CSS and JavaScript in a <code>&lt;head&gt;</code> element, places a <code>&lt;body&gt;</code> tag around the main
content and so forth.  All the common content that wrapped around the &#8220;normal&#8221; content for the entire application
is located in this file.</p>
</div>
<div class="paragraph">
<p>The next line of code declares the <code>content</code> section of this template.  This content block is used by the <code>layout.html</code>
template to inject the content of <code>index.html</code> within its HTML.</p>
</div>
<div class="paragraph">
<p>Next we have our first bit of actual HTML, rather than just Jinja directives.  We have a simple HTML form that allows
you to search contacts by issuing a <code>GET</code> request to the <code>/contacts</code> path.  The form itself contains a label and
an input with the name &#8220;q&#8221;.  This input&#8217;s value will be submitted with the <code>GET</code> request to the <code>/contacts</code> path,
as a query string (since this is a <code>GET</code> request.)</p>
</div>
<div class="paragraph">
<p>Note that the value of this input is set to the Jinja expression <code>{{ request.args.get('q') or '' }}</code>.  This expression
is evaluated by Jinja and will insert the request value of &#8220;q&#8221; as the input&#8217;s value, if it exists.  This will &#8220;preserve&#8221;
the search value when a user does a search, so that when the results of a search are rendered the text input contains
the term that was searched for.  This makes for a better user experience since the user can see exactly what the
current results match, rather than having a blank text box at the top of the screen.</p>
</div>
<div class="paragraph">
<p>Finally, we have a submit-type input.  This will render as a button and, when it is clicked on, it will trigger the
form to issue an HTTP request.</p>
</div>
<div class="paragraph">
<p>This search UI forms the top of our contact page.  Following it is a table of contacts, either all contacts or the
contacts that match the search, if a search was done.</p>
</div>
<div class="paragraph">
<p>Here is what the template code for the contact table looks like:</p>
</div>
<div class="listingblock">
<div class="title">The Contacts Table</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;First&lt;/th&gt; &lt;th&gt;Last&lt;/th&gt; &lt;th&gt;Phone&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;&lt;/th&gt;<b class="conum">(1)</b>
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for contact in contacts %} <b class="conum">(2)</b>
            &lt;tr&gt;
                &lt;td&gt;{{ contact.first }}&lt;/td&gt;
                &lt;td&gt;{{ contact.last }}&lt;/td&gt;
                &lt;td&gt;{{ contact.phone }}&lt;/td&gt;
                &lt;td&gt;{{ contact.email }}&lt;/td&gt; <b class="conum">(3)</b>
                &lt;td&gt;&lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
                    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;&lt;/td&gt; <b class="conum">(4)</b>
            &lt;/tr&gt;
        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Output some headers for our table</p>
</li>
<li>
<p>Iterate over the contacts that were passed in to the template</p>
</li>
<li>
<p>Output the values of the current contact, first name, last name, etc.</p>
</li>
<li>
<p>An "operations" column, with links to edit or view the contact details</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is the core of the page: we construct a table with appropriate headers matching the data we are going
to show for each contact.  We iterate over the contacts that were passed into the template by the handler method using
the <code>for</code> loop directive in Jinja2.  We then construct a series of rows, one for each contact, where we render the
first and last name, phone and email of the contact as table cells in the row.</p>
</div>
<div class="paragraph">
<p>Additionally, we have another table cell that includes two links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A link to the "Edit" page for the contact, located at <code>/contacts/{{ contact.id }}/edit</code> (e.g. For the contact with
id 42, the edit link will point to <code>/contacts/42/edit</code>)</p>
</li>
<li>
<p>A link to the "View" page for the contact <code>/contacts/{{ contact.id }}</code> (using our previous contact example, the view
page would be at <code>/contacts/42</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, we have a bit of end-matter: a link to add a new contact and a Jinja2 directive to end the <code>content</code> block:</p>
</div>
<div class="listingblock">
<div class="title">The Add Contact Link</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;p&gt;
        &lt;a href="/contacts/new"&gt;Add Contact&lt;/a&gt; <b class="conum">(1)</b>
    &lt;/p&gt;

{% endblock %} <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Link to the page that allows you to create a new contact</p>
</li>
<li>
<p>The closing element of the <code>content</code> block</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And that&#8217;s our complete template.  Using this simple server-side template, in combination with our handler method, we
can respond with an HTML <em>representation</em> of all the contacts requested.  So far, so hypermedia.</p>
</div>
<div class="paragraph">
<p>Here is what the template looks like, rendered with a bit of contact information:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/figure_2-2_table_etc.png" alt="figure 2 2 table etc">
</div>
<div class="title">Figure 2. Contact.app</div>
</div>
<div class="paragraph">
<p>Now, our application won&#8217;t win any design awards at this point, but notice that our template, when rendered,
provides all the functionality necessary to see all the contacts and search them, and also provides links to edit them,
view details of them or even create a new one.</p>
</div>
<div class="paragraph">
<p>And it does all this without the client (that is, the browser) knowing a thing about what contacts are or how to
work with them.  Everything is encoded <em>in</em> the hypermedia.  A web browser accessing this application just knows how to
issue HTTP requests and then render HTML, nothing more about the specifics of our applications end points or underlying
domain model.</p>
</div>
<div class="paragraph">
<p>As simple as our application is at this point, it is thoroughly RESTful.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_a_new_contact">Adding A New Contact</h4>
<div class="paragraph">
<p>The next bit of functionality that we will add to our application is the ability to add new contacts.  To do this, we
are going to need to handle that <code>/contacts/new</code> URL referenced in the &#8220;Add Contact&#8221; link above.  Note that when a user
clicks on that link, the browser will issue a <code>GET</code> request to the <code>/contacts/new</code> URL.</p>
</div>
<div class="paragraph">
<p>All the other routes we have been looking at so far are using <code>GET</code> as well, but we are actually going to use two
different HTTP methods for this bit of functionality: an HTTP <code>GET</code> to render a form for adding a new contact,
and then an HTTP <code>POST</code> <em>to the same path</em> to actually create the contact, so we are going to be explicit about the
HTTP method we want to handle when we declare this route.</p>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="listingblock">
<div class="title">The New Contact GET Route</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/new", methods=['GET']) <b class="conum">(1)</b>
def contacts_new_get():
    return render_template("new.html", contact=Contact()) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Declare a route, explicitly handling <code>GET</code> requests to this path</p>
</li>
<li>
<p>Render the <code>new.html</code> template, passing in a new contact object</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Simple enough. We just render a <code>new.html</code> template with a new Contact.  (<code>Contact()</code> is how you construct a new instance
of the <code>Contact</code> class in Python, if you aren&#8217;t familiar with it.)</p>
</div>
<div class="paragraph">
<p>While the handler code for this route is very simple, the <code>new.html</code> template is more complicated.  For the
remaining templates we are going to omit the layout directive and the content block declaration, but you
can assume they are the same unless we say otherwise.  This will let us focus on the "meat" of the template.</p>
</div>
<div class="paragraph">
<p>If you are familiar with HTML you are probably expecting a form element here, and you will not be disappointed.  We are
going to use the standard form hypermedia control for collecting contact information and submitting it to the server.</p>
</div>
<div class="paragraph">
<p>Here is what our HTML looks like:</p>
</div>
<div class="listingblock">
<div class="title">The New Contact Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/contacts/new" method="post"&gt; <b class="conum">(1)</b>
    &lt;fieldset&gt;
        &lt;legend&gt;Contact Values&lt;/legend&gt;
        &lt;p&gt;
            &lt;label for="email"&gt;Email&lt;/label&gt; <b class="conum">(2)</b>
            &lt;input name="email" id="email" type="email" placeholder="Email" value="{{ contact.email or '' }}"&gt; <b class="conum">(3)</b>
            &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt; <b class="conum">(4)</b>
        &lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A form that submits to the <code>/contacts/new</code> path, using an HTTP <code>POST</code></p>
</li>
<li>
<p>A label for the first form input</p>
</li>
<li>
<p>the first form input, of type email</p>
</li>
<li>
<p>Any error messages associated with this field</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the first line of code we create a form that will submit back <em>to the same path</em> that we are handling: <code>/contacts/new</code>.
Rather than issuing an HTTP <code>GET</code> to this path, however, we will issue an HTTP <code>POST</code> to it.  Using a <code>POST</code> in this manner
will signal to the server that we want to create a new Contact, rather than get a form.</p>
</div>
<div class="paragraph">
<p>We then have a label (always a good practice, as mentioned in the last chapter!) and an input that captures the email of
the contact being created.  The name of the input is <code>email</code> and, when this form is submitted, the value of this input
will be submitted in the <code>POST</code> request, associated with the <code>email</code> key.</p>
</div>
<div class="paragraph">
<p>Next we have inputs for the other fields for contacts:</p>
</div>
<div class="listingblock">
<div class="title">Inputs And Labels For The New Contact Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">        &lt;p&gt;
            &lt;label for="first_name"&gt;First Name&lt;/label&gt;
            &lt;input name="first_name" id="first_name" type="text" placeholder="First Name" value="{{ contact.first or '' }}"&gt;
            &lt;span class="error"&gt;{{ contact.errors['first'] }}&lt;/span&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;label for="last_name"&gt;Last Name&lt;/label&gt;
            &lt;input name="last_name" id="last_name" type="text" placeholder="Last Name" value="{{ contact.last or '' }}"&gt;
            &lt;span class="error"&gt;{{ contact.errors['last'] }}&lt;/span&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;label for="phone"&gt;Phone&lt;/label&gt;
            &lt;input name="phone" id="phone" type="text" placeholder="Phone" value="{{ contact.phone or '' }}"&gt;
            &lt;span class="error"&gt;{{ contact.errors['phone'] }}&lt;/span&gt;
        &lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we have a button that will submit the form, the end of the form tag, and a link back to the main contacts table:</p>
</div>
<div class="listingblock">
<div class="title">The Submit Button For The New Contact Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">        &lt;button&gt;Save&lt;/button&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;

&lt;p&gt;
    &lt;a href="/contacts"&gt;Back&lt;/a&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is worth pointing out something that is easy to miss in this straight-forward example: we are seeing the flexibility
of hypermedia in action.</p>
</div>
<div class="paragraph">
<p>If we add a new field, remove a field, or change the logic around how fields are validated or work with one another,
this new state of affairs would be reflected in the new hypermedia representation given to users.  A user would see the
updated new form, and be able to work with whatever new features is had, with no software update required.</p>
</div>
<div class="sect4">
<h5 id="_handling_the_post_to_contactsnew">Handling The Post to <code>/contacts/new</code></h5>
<div class="paragraph">
<p>The next step in our application is to handle the <code>POST</code> that this form makes to <code>/contacts/new</code>.</p>
</div>
<div class="paragraph">
<p>To do so, we need to add another route to our application that handles the <code>/contacts/new</code> path like our handler above,
but that handles an HTTP <code>POST</code> method instead of an HTTP <code>GET</code>.  We will use the submitted form values to attempt to
create a new Contact.</p>
</div>
<div class="paragraph">
<p>If we are successful in creating a Contact, we will redirect the user to the list of contacts and show a success message.
If we aren&#8217;t successful, then we will render the new contact form again with whatever values the user entered and
render error messages about what issues need to be fixed so that the user can correct them.</p>
</div>
<div class="paragraph">
<p>Here is our new request handler:</p>
</div>
<div class="listingblock">
<div class="title">The New Contact Controller Code</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/new", methods=['POST'])
def contacts_new():
    c = Contact(None, request.form['first_name'], request.form['last_name'], request.form['phone'],
                request.form['email']) <b class="conum">(1)</b>
    if c.save(): <b class="conum">(2)</b>
        flash("Created New Contact!")
        return redirect("/contacts") <b class="conum">(3)</b>
    else:
        return render_template("new.html", contact=c) <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We construct a new contact object with the values from the form</p>
</li>
<li>
<p>We try to save it</p>
</li>
<li>
<p>On success, &#8220;flash&#8221; a success message &amp; redirect to the <code>/contacts</code> page</p>
</li>
<li>
<p>On failure, re-render the form, showing any errors to the user</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The logic in this handler is a bit more complex than other methods we have seen, but it isn&#8217;t too bad.  The first thing
we do is create a new Contact, again using the <code>Contact()</code> syntax in Python to construct the object.  We pass in the values
that the user submitted in the form by using the <code>request.form</code> object, a feature provided by Flask.</p>
</div>
<div class="paragraph">
<p>This <code>request.form</code> allows us to access submitted form values in an easy and convenient way, by simply passing in the same
name associated with the various inputs.</p>
</div>
<div class="paragraph">
<p>We also pass in <code>None</code> as the first value to the <code>Contact</code> constructor.  This is the &#8220;id&#8221; parameter, and by passing in
<code>None</code> we are signaling that it is a new contact, and needs to have an ID generated for it.    (Again, we are not
going to dig deeply into the details of how this model object is implemented, our only concern is using it to generate
hypermedia responses.)</p>
</div>
<div class="paragraph">
<p>Next, we call the <code>save()</code> method on the Contact object.  This method returns <code>true</code> if the save is successful, and <code>false</code> if
the save is unsuccessful (for example, a bad email was submitted by the user)</p>
</div>
<div class="paragraph">
<p>If we are able to save the contact (that is, there were no validation errors), we create a <em>flash</em> message indicating
success and redirect the browser back to the list page.  A &#8220;flash&#8221; is a common feature in web frameworks that allows
you to store a message that will be available on the <em>next</em> request, typically in a cookie or in a session store.</p>
</div>
<div class="paragraph">
<p>Finally, if we are unable to save the contact, we re-render the <code>new.html</code> template with the contact.  This will show the
same template as above, but the inputs will be filled in with the submitted values, and any errors associated with the
fields will be rendered to feedback to the user as to what validation failed.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The Post/Redirect/Get Pattern</div>
        <div class="paragraph">
<p>This handler is implementing a very common strategy in web 1.0-style development called the
<a href="https://en.wikipedia.org/wiki/Post/Redirect/Get">Post/Redirect/Get</a> or PRG pattern.  By issuing an HTTP redirect once
a contact has been created and forwarding the browser on to another location, we ensure that the <code>POST</code> does not
end up in the browsers request cache.</p>
</div>
<div class="paragraph">
<p>This means that if the user accidentally (or intentionally) refreshes the page, the browser will not submit another <code>POST</code>,
potentially creating another contact.  Instead, it will issue the <code>GET</code> that we redirect to, which should be side-effect
free.</p>
</div>
<div class="paragraph">
<p>We will use the PRG pattern in a few different places in this book.</p>
</div>
    </aside>
<div class="paragraph">
<p>OK, so we have our server-side logic set up to save contacts.  And, believe it or not, this is about as complicated as
our handler logic will get, even when we look at adding more sophisticated htmx-driven behaviors.  Simplicity is a great
selling point for hypermedia!</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_viewing_the_details_of_a_contact">Viewing The Details Of A Contact</h4>
<div class="paragraph">
<p>The next piece of functionality we will implement is the detail page for a Contact.  The user will navigate to this
page by clicking the &#8220;View&#8221; link in one of the rows in the list of contacts.  This will take them to the path
<code>/contact/&lt;contact id&gt;</code> (e.g. <code>/contacts/42</code>).</p>
</div>
<div class="paragraph">
<p>Note that this is a common pattern in web development: Contacts are being treated as resources and the URLs around these
resources are organized in a coherent manner:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you wish to view all contacts, you issue a <code>GET</code> to <code>/contacts</code></p>
</li>
<li>
<p>If you wish to get a hypermedia representation allowing you to create a new contact, you issue a <code>GET</code> to <code>/contacts/new</code></p>
</li>
<li>
<p>If you wish to view a specific contact (with, say, an id of <code>42), you issue a `GET</code> to <code>/contacts/42</code></p>
</li>
</ul>
</div>
<aside class="sidebar">
        <div class="titlebar">The Eternal Bike Shed of URL Design</div>
        <div class="paragraph">
<p>It is easy to quibble about the particulars of the path scheme you use for your application:</p>
</div>
<div class="paragraph">
<p>&#8220;Should we <code>POST</code> to <code>/contacts/new</code> or to <code>/contacts</code>?&#8221;</p>
</div>
<div class="paragraph">
<p>We have seen many arguments online and in person advocating for one approach versus another.  We feel it is more
important to understand the overarching idea of <em>resources</em> and the <em>hypermedia representations</em>, rather than
getting too worked up about the smaller details of your URL design.</p>
</div>
<div class="paragraph">
<p>We recommend you just pick a reasonable, resource-oriented URL layout you like and then stay consistent.  Remember,
in a hypermedia system, you can always change your end-points later, because you are using hypermedia as the engine
of application state!</p>
</div>
    </aside>
<div class="paragraph">
<p>Our handler logic for the detail route is going to be <em>very</em> simple: we just look the Contact up by id, which is embedded in
the path of the URL for the route.  To extract this ID we are going to need to introduce a final bit of Flask
functionality: the ability to call out pieces of a path and have them automatically extracted and passed in to a
handler function.</p>
</div>
<div class="paragraph">
<p>Here is what the code looks like, just a few lines of simple Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;") <b class="conum">(1)</b>
def contacts_view(contact_id=0): <b class="conum">(2)</b>
    contact = Contact.find(contact_id) <b class="conum">(3)</b>
    return render_template("show.html", contact=contact) <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Map the path, with a path variable named <code>contact_id</code></p>
</li>
<li>
<p>The handler takes the value of this path parameter</p>
</li>
<li>
<p>Look up the corresponding contact</p>
</li>
<li>
<p>Render the <code>show.html</code> template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can see the syntax for extracting values from the path in the first line of code: you enclose the part of the
path you wish to extract in <code>&lt;&gt;</code> and give it a name.  This component of the path will be extracted and then passed
into the handler function, via the parameter with the same name.</p>
</div>
<div class="paragraph">
<p>So, if you were to navigate to the path <code>/contacts/42</code> then the value <code>42</code> would be passed into the <code>contacts_view()</code>
function for the value of <code>contact_id</code>.</p>
</div>
<div class="paragraph">
<p>Once we have the id of the contact we want to look up, we load it up using the <code>find</code> method on the <code>Contact</code> object.  We
then pass this contact into the <code>show.html</code> template and render a response.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_contact_detail_template">The Contact Detail Template</h4>
<div class="paragraph">
<p>Our <code>show.html</code> template is relatively simple, just showing the same information as the table but in a slightly different
format (perhaps for printing).  If we add functionality like &#8220;notes&#8221; to the application later on, however, this will give
us a good place to do so.</p>
</div>
<div class="paragraph">
<p>Again, we will omit the &#8220;chrome&#8221; of the template and focus on the meat:</p>
</div>
<div class="listingblock">
<div class="title">The Contact Details Template</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;h1&gt;{{contact.first}} {{contact.last}}&lt;/h1&gt;

&lt;div&gt;
  &lt;div&gt;Phone: {{contact.phone}}&lt;/div&gt;
  &lt;div&gt;Email: {{contact.email}}&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;a href="/contacts/{{contact.id}}/edit"&gt;Edit&lt;/a&gt;
&lt;a href="/contacts"&gt;Back&lt;/a&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We simply render a nice First Name and Last Name header, with the additional contact information below it,
and a couple of links: a link to edit the contact and a link to navigate back to the full list of contacts.</p>
</div>
</div>
<div class="sect3">
<h4 id="_editing_and_deleting_a_contact">Editing And Deleting A Contact</h4>
<div class="paragraph">
<p>Next up we will tackle the functionality on the other end of that &#8220;Edit&#8221; link.  Editing a contact is going to look very
similar to creating a new contact.  As with adding a new contact, we are going to need two routes that handle the same
path, but using different HTTP methods: a <code>GET</code> to <code>/contacts/&lt;contact_id&gt;/edit</code> will return a form allowing you to edit
the contact and a <code>POST</code> to that path will update it.</p>
</div>
<div class="paragraph">
<p>We are also going to piggyback the ability to delete a contact along with this editing functionality.  To do this we
will need to handle a <code>POST</code> to <code>/contacts/&lt;contact_id&gt;/delete</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the code to handle the <code>GET</code>, which, again, will return an HTML representation of an editing interface
for the given resource:</p>
</div>
<div class="listingblock">
<div class="title">The Edit Contact Controller Code</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;/edit", methods=["GET"])
def contacts_edit_get(contact_id=0):
    contact = Contact.find(contact_id)
    return render_template("edit.html", contact=contact)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see this looks an awful lot like our &#8220;Show Contact&#8221; functionality.  In fact, it is nearly identical except
for the template that we render: here we render <code>edit.html</code> rather than <code>show.html</code>.</p>
</div>
<div class="paragraph">
<p>While our handler code looked similar to the &#8220;Show Contact&#8221; functionality, the <code>edit.html</code> template is going to look
very similar to the template for the &#8220;New Contact&#8221; functionality: we will have a form that submits updated contact
values to the same &#8220;edit&#8221; URL and that presents all the fields of a contact as inputs for editing, along with any error
messages.</p>
</div>
<div class="paragraph">
<p>Here is the first bit of the form:</p>
</div>
<div class="listingblock">
<div class="title">The Edit Contact Form Start</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;form action="/contacts/{{ contact.id }}/edit" method="post"&gt; <b class="conum">(1)</b>
        &lt;fieldset&gt;
            &lt;legend&gt;Contact Values&lt;/legend&gt;
              &lt;p&gt;
                  &lt;label for="email"&gt;Email&lt;/label&gt;
                  &lt;input name="email" id="email" type="text" placeholder="Email" value="{{ contact.email }}"&gt; <b class="conum">(2)</b>
                  &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
              &lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue a <code>POST</code> to the <code>/contacts/{{ contact.id }}/edit</code> path</p>
</li>
<li>
<p>As with the <code>new.html</code> page, the input is tied to the contact&#8217;s email</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This HTML is nearly identical to our <code>new.html</code> form, except that this form is going to submit a <code>POST</code> to a different
path, based on the id of the contact that we want to update.  (It&#8217;s worth mentioning here that, rather than <code>POST</code>, we
would prefer to use a <code>PUT</code> or <code>PATCH</code>, but those are not available in plain HTML.)</p>
</div>
<div class="paragraph">
<p>Following this we have the remainder of our form, again very similar to the <code>new.html</code> template, and our submit button
to submit the form.</p>
</div>
<div class="listingblock">
<div class="title">The Edit Contact Form Body</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">              &lt;p&gt;
                  &lt;label for="first_name"&gt;First Name&lt;/label&gt;
                  &lt;input name="first_name" id="first_name" type="text" placeholder="First Name"
                         value="{{ contact.first }}"&gt;
                  &lt;span class="error"&gt;{{ contact.errors['first'] }}&lt;/span&gt;
              &lt;/p&gt;
              &lt;p&gt;
                  &lt;label for="last_name"&gt;Last Name&lt;/label&gt;
                  &lt;input name="last_name" id="last_name" type="text" placeholder="Last Name"
                         value="{{ contact.last }}"&gt;
                  &lt;span class="error"&gt;{{ contact.errors['last'] }}&lt;/span&gt;
              &lt;/p&gt;
              &lt;p&gt;
                  &lt;label for="phone"&gt;Phone&lt;/label&gt;
                  &lt;input name="phone" id="phone" type="text" placeholder="Phone" value="{{ contact.phone }}"&gt;
                  &lt;span class="error"&gt;{{ contact.errors['phone'] }}&lt;/span&gt;
              &lt;/p&gt;
            &lt;button&gt;Save&lt;/button&gt;
        &lt;/fieldset&gt;
    &lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the final part of our template we have a small difference between the <code>new.html</code> and <code>edit.html</code>.  Below the main
editing form, we include a second form that allows you to delete a contact.  It does this by issuing a <code>POST</code>
to the <code>/contacts/&lt;contact id&gt;/delete</code> path.  Just as we would prefer to use a <code>PUT</code> to update a contact, we would
much rather use an HTTP <code>DELETE</code> request to delete one.  Unfortunately that also isn&#8217;t possible in plain HTML.</p>
</div>
<div class="paragraph">
<p>To finish up the page, there is a simple hyperlink back to the list of contacts.</p>
</div>
<div class="listingblock">
<div class="title">The Edit Contact Form Footer</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;form action="/contacts/{{ contact.id }}/delete" method="post"&gt;
        &lt;button&gt;Delete Contact&lt;/button&gt;
    &lt;/form&gt;

    &lt;p&gt;
        &lt;a href="/contacts/"&gt;Back&lt;/a&gt;
    &lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given all the similarities between the <code>new.html</code> and <code>edit.html</code> templates, you may be wondering why we are not
<em>refactoring</em> these two templates to share logic between them.  That&#8217;s a good observation and, in a production system,
we would probably do just that.</p>
</div>
<div class="paragraph">
<p>For our purposes, however, since our application is small and simple, we will leave the templates separate.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Factoring Your Applications</div>
        <div class="paragraph">
<p>One thing that often trips people up who are coming to hypermedia applications from a JavaScript background is the
notion of "components".  In JavaScript-oriented applications it is common to break your app up into small
client-side components that are then composed together.  These components are often developed and tested in isolation and
provide a nice abstraction for developers to create testable code.</p>
</div>
<div class="paragraph">
<p>With Hypermedia Driven Applications, in contrast, you factor your application on the server side.  As we said, the above form could be
refactored into a shared template between the edit and create templates, allowing you to achieve a reusable and DRY (Don&#8217;t
Repeat Yourself) implementation.</p>
</div>
<div class="paragraph">
<p>Note that factoring on the server-side tends to be coarser-grained than on the client-side: you tend to split out common
<em>sections</em> rather than create lots of individual components.  This has both benefits (it tends to be simple) as well as
drawbacks (it is not nearly as isolated as client-side components) .</p>
</div>
<div class="paragraph">
<p>Overall, however, a properly factored server-side hypermedia application can be extremely DRY!</p>
</div>
    </aside>
<div class="sect4">
<h5 id="_handling_the_post_to_contactscontact_id">Handling The Post to <code>/contacts/&lt;contact_id&gt;</code></h5>
<div class="paragraph">
<p>Next we need to handle the HTTP <code>POST</code> request that the form in our <code>edit.html</code> template submits.  We will declare
another route that handles the path as the <code>GET</code> above.</p>
</div>
<div class="paragraph">
<p>Here is the new handler code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;/edit", methods=["POST"]) <b class="conum">(1)</b>
def contacts_edit_post(contact_id=0):
    c = Contact.find(contact_id) <b class="conum">(2)</b>
    c.update(request.form['first_name'], request.form['last_name'], request.form['phone'], request.form['email']) <b class="conum">(3)</b>
    if c.save(): <b class="conum">(4)</b>
        flash("Updated Contact!")
        return redirect("/contacts/" + str(contact_id)) <b class="conum">(5)</b>
    else:
        return render_template("edit.html", contact=c) <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle a <code>POST</code> to <code>/contacts/&lt;contact_id&gt;/edit</code></p>
</li>
<li>
<p>Look the contact up by id</p>
</li>
<li>
<p>update the contact with the new information from the form</p>
</li>
<li>
<p>Attempt to save it</p>
</li>
<li>
<p>On success, flash a success message &amp; redirect to the detail page</p>
</li>
<li>
<p>On failure, re-render the edit template, showing any errors</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The logic in this handler is very similar to the logic in the handler for adding a new contact.  The only real difference
is that, rather than creating a new Contact, we look the contact up by id and then call the <code>update()</code> method on it with
the values that were entered in the form.</p>
</div>
<div class="paragraph">
<p>Once again, this consistency between our CRUD operations is one of the nice and simplifying aspects of traditional CRUD web
applications.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_a_contact">Deleting A Contact</h4>
<div class="paragraph">
<p>We piggybacked contact delete functionality into the same template used to edit a contact.  This second form will issue
an HTTP <code>POST</code> to <code>/contacts/&lt;contact_id&gt;/delete</code>, and we will need to create a handler for that path as well.</p>
</div>
<div class="paragraph">
<p>Here is what the controller looks like:</p>
</div>
<div class="listingblock">
<div class="title">The Delete Contact Controller Code</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;/delete", methods=["POST"]) <b class="conum">(1)</b>
def contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete() <b class="conum">(2)</b>
    flash("Deleted Contact!")
    return redirect("/contacts") <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle a <code>POST</code> the <code>/contacts/&lt;contact_id&gt;/delete</code> path</p>
</li>
<li>
<p>Look up and then invoke the <code>delete()</code> method on the contact</p>
</li>
<li>
<p>Flash a success message and redirect to the main list of contacts</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The handler code is very simple since we don&#8217;t need to do any validation or conditional logic: we simply look up the
contact the same way we have been doing in our other handlers and invoke the <code>delete()</code> method on it, then redirect
back to the list of contacts with a success flash message.</p>
</div>
<div class="paragraph">
<p>No need for a template in this case, the contact is gone.</p>
</div>
</div>
<div class="sect3">
<h4 id="_contact_app_implemented">Contact.app&#8230;&#8203; Implemented!</h4>
<div class="paragraph">
<p>And, well&#8230;&#8203; believe it or not, that&#8217;s our entire contact application!  The Flask and Jinja2 code should be simple enough
that you are able to follow along, even if Python isn&#8217;t your preferred language or Flask isn&#8217;t your preferred web
application framework.  Again, we don&#8217;t expect you to be a Python or Flask experts (we aren&#8217;t!) and you shouldn&#8217;t need
more than a basic understanding of how they work for the remainder of the book.</p>
</div>
<div class="paragraph">
<p>Now, admittedly, this isn&#8217;t a large or sophisticated application, but it does demonstrate many of the aspects of
traditional, web 1.0 applications: CRUD, the Post/Redirect/Get pattern, working
with domain logic in a controller, organizing our URLs in a coherent, resource-oriented manner.</p>
</div>
<div class="paragraph">
<p>And, furthermore, this is a deeply <em>Hypermedia-Driven</em> web application.  Without thinking about it very much, we have
been using REST, HATEOAS and all the other hypermedia concepts we discussed earlier.  We would bet that this simple
little contact app of ours is more RESTful than 99% of all JSON APIs ever built!</p>
</div>
<div class="paragraph">
<p>And it was all effortless: just by virtue of using a <em>hypermedia</em>, HTML, we naturally fall into the RESTful network
architecture.</p>
</div>
<div class="paragraph">
<p>So that&#8217;s great.  But what&#8217;s the matter with this little web app?  Why not end here and go off to develop the old web 1.0 style
applications people used to build?</p>
</div>
<div class="paragraph">
<p>Well, at some level, nothing is wrong with it.  Particularly for an application that is as simple as this one it, the older
way of building web apps might be a perfectly acceptable approach!</p>
</div>
<div class="paragraph">
<p>However, our application does suffer from that &#8220;clunkiness&#8221; that we mentioned earlier when discussing web 1.0 applications:
every request replaces the entire screen, introducing a noticeable flicker when navigating between pages.  You lose your
scroll state.  You have to click around a bit more than you might in a more sophisticated web application.</p>
</div>
<div class="paragraph">
<p>Contact.app, at this point, just doesn&#8217;t feel like a &#8220;modern&#8221; web application, does it?</p>
</div>
<div class="paragraph">
<p>Is it time to reach for a JavaScript framework and JSON APIs to make our contact application more interactive?</p>
</div>
<div class="paragraph">
<p>No.  No it isn&#8217;t.</p>
</div>
<div class="paragraph">
<p>It turns out that we can improve the user experience of this application <em>without</em> abandoning the
hypermedia architecture. In the next few chapters we will look at <a href="https://htmx.org">htmx</a>, a hypermedia-oriented library
that will let us improve our contact application <em>without</em> abandoning the hypermedia approach we have used so far.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_hypermedia_driven_web_applications_with_htmx" class="sect0">Hypermedia-Driven Web Applications With htmx</h1>
<div class="sect1">
<h2 id="_extending_html_as_hypermedia">5. Extending HTML As Hypermedia</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter we introduced a simple Web 1.0-style hypermedia application to manage contacts.  Our application
supported the normal CRUD operations for contacts, as well as a simple mechanism for searching contacts.  Our application
was built using nothing but forms and anchor tags, the traditional hypermedia controls used to interact with servers.
The application exchanges hypermedia (HTML) with the server over HTTP, issuing <code>GET</code> and <code>POST</code> HTTP requests and
receiving back full HTML documents in response.</p>
</div>
<div class="paragraph">
<p>It is a pretty basic web application, but it is also definitely a Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>The application, as it stands, is robust, it leverages the web&#8217;s native technologies and is simple to understand.  So
what&#8217;s not to like about the application, then?</p>
</div>
<div class="paragraph">
<p>Unfortunately, our application has a few issues common to web 1.0 style applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From a user experience perspective: there is a noticeable refresh when you move between pages of the application, or when you create, update or
delete a contact.  This is because every user interaction (link click or form submission) requires a full page
refresh, with a whole new HTML document to process after each action.</p>
</li>
<li>
<p>From a technical perspective, all the updates are done with the <code>POST</code> HTTP method.  This, despite the fact that
more logical actions and HTTP request types like <code>PUT</code> and <code>DELETE</code> exist and would make more sense for some
of the operations we implemented.  After all, if we wanted to delete a resource, wouldn&#8217;t it make more sense to use an HTTP <code>DELETE</code> request
to do so?  Somewhat ironically, since we are using pure HTML, we are unable to access the full expressive power
of HTTP, which was designed specifically <em>for</em> HTML.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first point, in particular, is noticeable in Web 1.0 style applications like ours and is what is responsible for giving
them the reputation for being &#8220;clunky&#8221; when compared with their more sophisticated JavaScript-based Single Page Application
cousins.</p>
</div>
<div class="paragraph">
<p>We could address this issue by adopting a Single Page Application framework, and updating our server-side to
provide JSON-based responses.  Single Page Applications eliminate the clunkiness of web 1.0 applications by updating a
web page directly: they mutate the Document Object Model (DOM) directly, without doing a full page refresh.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The DOM</div>
        <div class="paragraph">
<p>The DOM is the internal model that a browser builds up when it processes HTML, forming a tree of &#8220;nodes&#8221; for
the tags and other content in the HTML.  The DOM provides a programmatic JavaScript API that allows you to update the nodes
in a page directly, without the use of hypermedia.  Using this API, JavaScript code can insert new content, or remove or
update existing content, entirely outside the normal browser request mechanism.</p>
</div>
    </aside>
<div class="paragraph">
<p>There are a few different styles of SPA, but, as we discussed in Chapter 1, the most common approach today is to tie
the DOM to a JavaScript model and then let an SPA framework like <a href="https://reactjs.org/">React</a> or <a href="https://vuejs.org/">Vue</a>
<em>reactively</em> update the DOM when a JavaScript model is updated: you make a change to a JavaScript object that is
stored locally in memory in the browser, and the web page &#8220;magically&#8221; updates its state to reflect the change in the
model.</p>
</div>
<div class="paragraph">
<p>In this style of application, communication with the server is typically done via a JSON Data API,
with the application sacrificing the advantages of hypermedia in order to provide a better, smoother user experience.</p>
</div>
<div class="paragraph">
<p>Many web developers today would not even consider the hypermedia approach due to the perceived &#8220;legacy&#8221; feel of these
Web 1.0 style applications.</p>
</div>
<div class="paragraph">
<p>The second, technical point may strike you as a bit pedantic, and we am the first to admit that conversations around
REST and which HTTP Action is right for a given operation can become very tedious.  But still, it&#8217;s mildly infuriating that,
when using plain HTML, it is impossible to use HTTP fully.</p>
</div>
<div class="sect2">
<h3 id="_a_close_look_at_a_hyperlink">5.1. A Close Look At A Hyperlink</h3>
<div class="paragraph">
<p>It turns out that we can actually boost the interactivity of our application without resorting to the SPA approach, by
using a library called <a href="https://htmx.org">htmx</a>.  To understand how htmx allows us to improve the UX of our Web 1.0 style
application without abandoning hypermedia, let&#8217;s revisit the hyperlink/anchor tag from Chapter 1.  Recall, a hyperlink
is what is known as a <em>hypermedia control</em>, a mechanism</p>
</div>
<div class="paragraph">
<p>Consider again this simple anchor tag which, when interpreted by a browser, creates a hyperlink to the website for
this book:</p>
</div>
<div class="listingblock">
<div class="title">A Simple Hyperlink, Again</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="https://hypermedia.systems/"&gt;
  Hypermedia Systems
&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break down in painstaking detail exactly what happens with this link:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The browser will render the text &#8220;Hypermedia Systems&#8221; to the screen, likely with a decoration indicating it is clickable.</p>
</li>
<li>
<p>Then, when a user clicks on the text&#8230;&#8203;</p>
</li>
<li>
<p>The browser will issue an HTTP <code>GET</code> to <code><a href="https://hypermedia.systems" class="bare">https://hypermedia.systems</a></code>&#8230;&#8203;</p>
</li>
<li>
<p>The browser will load the HTML body of the HTTP response into the browser window, replacing the current document.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So we have four aspects of a simple hypermedia link like this, with the last three aspects supplying the mechanism that distinguishes
a hyperlink from &#8220;normal&#8221; text and makes this a hypermedia control.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s take a moment and think about how we can <em>generalize</em> these last three aspects of a hyperlink.</p>
</div>
<div class="sect3">
<h4 id="_why_only_anchors_forms">Why Only Anchors &amp; Forms?</h4>
<div class="paragraph">
<p>An initial observation is: what makes anchor tags (and forms) so special?</p>
</div>
<div class="paragraph">
<p>Shouldn&#8217;t other elements be able to issue HTTP requests as well?</p>
</div>
<div class="paragraph">
<p>For example, why shouldn&#8217;t <code>button</code> elements be able to issue HTTP requests?  It seemed kind of silly to have to wrap a
form tag around a button just to make deleting contacts work in our application.  Maybe other elements should be able
to issue HTTP requests as well, and act as hypermedia controls on their own.</p>
</div>
<div class="paragraph">
<p>This is our first opportunity to generalize HTML as a hypermedia:</p>
</div>
<div class="box info">
        <div class="titlebar">Opportunity 1</div>
        <div class="paragraph">
<p>HTML could be extended to allow <em>any</em> element to issue a request to the server and act as a hypermedia control</p>
</div>
    </div>
</div>
<div class="sect3">
<h4 id="_why_only_clicks_submits">Why Only Clicks &amp; Submits?</h4>
<div class="paragraph">
<p>For our next observation, let&#8217;s consider the event that triggers the request to the server on our link: a click event.</p>
</div>
<div class="paragraph">
<p>Well, what&#8217;s so special about clicking (in the case of anchors) or submitting (in the case of forms)?  Those are just two
of many, many events that are fired by the DOM, after all.  Events like mouse down, or key up, or blur are all events
you might want to use to issue an HTTP request.</p>
</div>
<div class="paragraph">
<p>Why shouldn&#8217;t these other events be able to trigger requests as well?</p>
</div>
<div class="paragraph">
<p>This gives us our second opportunity to expand the expressiveness of HTML:</p>
</div>
<div class="box info">
        <div class="titlebar">Opportunity 2</div>
        <div class="paragraph">
<p>HTML could be extended to allow <em>any</em> event, not just a click, as in the case of our hyperlinks, to trigger HTTP requests</p>
</div>
    </div>
</div>
<div class="sect3">
<h4 id="_why_only_get_post">Why Only <code>GET</code> &amp; <code>POST</code>?</h4>
<div class="paragraph">
<p>Getting a bit more technical in our thinking leads us to the problem we noted earlier: plain HTML only
give us access to the <code>GET</code> and <code>POST</code> actions of HTTP?</p>
</div>
<div class="paragraph">
<p>HTTP <em>stands</em> for Hypertext Transfer Protocol, and yet the format it was explicitly designed for, HTML, only supports
two of the five developer-facing request types!  You <em>have</em> to use JavaScript and issue an AJAX request to get at the
other three: <code>DELETE</code>, <code>PUT</code> and <code>PATCH</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s recall what are all of these different HTTP request types designed to represent?</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GET</code> corresponds with &#8220;getting&#8221; a representation for a resource from a URL: it is a pure read, with no mutation of
the resource</p>
</li>
<li>
<p><code>POST</code> submits an entity (or data) to the given resource, often creating or mutating the resource and causing a state change</p>
</li>
<li>
<p><code>PUT</code> submits an entity (or data) to the given resource for update or replacement, again likely causing a state change</p>
</li>
<li>
<p><code>PATCH</code> is similar to <code>PUT</code> but implies a partial update and state change rather than a complete replacement of the entity</p>
</li>
<li>
<p><code>DELETE</code> deletes the given resource</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These operations correspond closely to the CRUD operations we discussed in Chapter 2, and by only giving us access to two
of the five, HTML hamstrings our ability to take full advantage of HTTP.</p>
</div>
<div class="paragraph">
<p>This gives us our third opportunity to expand the expressiveness of HTML:</p>
</div>
<div class="box info">
        <div class="titlebar">Opportunity 3</div>
        <div class="paragraph">
<p>HTML could be extended so that it could access these missing three HTTP methods, <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code>.</p>
</div>
    </div>
</div>
<div class="sect3">
<h4 id="_why_only_replace_the_entire_screen">Why Only Replace The Entire Screen?</h4>
<div class="paragraph">
<p>As a final observation, consider the last aspect of a hyperlink: it replaces  the <em>entire</em> screen when a user clicks on it.</p>
</div>
<div class="paragraph">
<p>It turns out that this technical detail is the primary culprit for poor user experience in Web 1.0 Applications.
A full page refresh can cause a flash of unstyled content, it destroys the scroll state of the user by scrolling to the
top of the page no matter what, and so forth.</p>
</div>
<div class="paragraph">
<p>But there is no rule saying that hypermedia exchanges <em>must</em> replace the entire document.</p>
</div>
<div class="paragraph">
<p>This gives us our fourth, final and perhaps most important opportunity to generalize HTML:</p>
</div>
<div class="box info">
        <div class="titlebar">Opportunity 4</div>
        <div class="paragraph">
<p>HTML could be extended to allow the responses to requests to replace elements <em>within</em> the current document, rather than
requiring that they replace the <em>entire</em> document</p>
</div>
    </div>
<div class="paragraph">
<p>This is actually a very old concept in hypermedia.  Ted Nelson, in his 1980 book &#8220;Literary Machines&#8221; coined the term
<em>transclusion</em> to capture this idea: the inclusion of content into an existing document via a hypermedia reference.
If HTML supported this style of &#8220;dynamic transclusion&#8221;, then Hypermedia Driven Applications could function much more like
a Single Page Application, where only part of the DOM is updated by a given user interaction or network request.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extending_html_as_a_hypermedia_with_htmx">5.2. Extending HTML as a Hypermedia with htmx</h3>
<div class="paragraph">
<p>These four opportunities present us a way to generalize HTML that would extend HTML well beyond its current abilities, but
in a way that is <em>entirely within</em> the original hypermedia model of the web. The fundamentals of HTML, HTTP, the browser,
and so on, won&#8217;t be changed dramatically.  Rather, these generalizations of <em>existing functionality</em> already found within
HTML would simply let us accomplish <em>more</em> using HTML.</p>
</div>
<div class="paragraph">
<p>htmx is a JavaScript library that extends HTML in exactly this manner, and it will be the focus of the next few chapters
of this book.  htmx is not the only JavaScript library that takes this hypermedia-oriented approach (other excellent
examples are <a href="https://unpoly.com">Unpoly</a> and <a href="https://hotwire.dev">Hotwire</a>), but htmx is the purest of these libraries in
its pursuit of extending HTML as a hypermedia.</p>
</div>
<div class="sect3">
<h4 id="_installing_and_using_htmx">Installing and Using htmx</h4>
<div class="paragraph">
<p>From a practical &#8220;getting started&#8221; perspective, Htmx is a simple, dependency-free and stand-alone JavaScript library that
can be added to a web application by simply including it via a <code>script</code> tag in your <code>head</code> element.</p>
</div>
<div class="paragraph">
<p>Because of this simple installation model, you can take advantage of tools like public CDNs to install the library.</p>
</div>
<div class="paragraph">
<p>Below is an example using the popular <a href="https://unpkg.com">unpkg</a> Content Delivery Network (CDN) to install version <code>1.7.0</code>
of the library.  We use an integrity hash to ensure that the delivered JavaScript content matches what we expect.  This
SHA can be found on the htmx website.</p>
</div>
<div class="paragraph">
<p>We also mark the script as <code>crossorigin="anonymous"</code> so no credentials will be sent to the CDN.</p>
</div>
<div id="listing-3-2" class="listingblock">
<div class="title">Installing htmx</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;head&gt;
  &lt;script src="https://unpkg.com/htmx.org@1.7.0"
          integrity="sha384-EzBXYPt0/T6gxNp0nuPtLkmRpmDBbjg6WmCUZRLXBBwYYmwAUxzlSGej0ARHX0Bo"
          crossorigin="anonymous"&gt;&lt;/script&gt;

&lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are used to modern JavaScript development, with complex build systems and large numbers of dependencies, it may
be a bit shocking to find that that&#8217;s all it takes to install htmx!</p>
</div>
<div class="paragraph">
<p>This is in the spirit of the early web, when you could simply include a script tag and things would &#8220;just work&#8221;.  To be honest,
this still feels a bit like magic, even today!</p>
</div>
<div class="paragraph">
<p>Of course, you might not want to use a CDN. In that case you can download htmx to your local system and adjust the
script tag to point to wherever you keep your static assets.  Or, you may have one of those more sophisticated build system
that automatically installs dependencies.  In this case you can use the Node Package Manager (npm) name for the library:
<code>htmx.org</code> and install it in the usual manner that your build system supports.</p>
</div>
<div class="paragraph">
<p>Once htmx has been installed, you can begin using it immediately.</p>
</div>
</div>
<div class="sect3">
<h4 id="_no_javascript_required">No JavaScript Required&#8230;&#8203;</h4>
<div class="paragraph">
<p>And here we get to the funny part of htmx: unlike the vast majority of JavaScript libraries, htmx does not require you,
the user of htmx, to actually write any JavaScript.</p>
</div>
<div class="paragraph">
<p>Instead, you will use <em>attributes</em> placed directly on elements in your HTML to drive more dynamic behavior.  htmx extends
HTML as a hypermedia, and it wants that extension to be as natural and consistent as possible with existing
HTML concepts.  Just as an anchor tag uses an <code>href</code> attribute to specify the URL to retrieve, and forms use an <code>action</code>
attribute to specify the URL to submit the form to, htmx uses HTML <em>attributes</em> to specify the URL that an HTTP request
should be issued to.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_triggering_http_requests">5.3. Triggering HTTP Requests</h3>
<div class="paragraph">
<p>Let&#8217;s look at the first feature of htmx: the ability for any element in a web page to issue HTTP requests.  This is the
core functionality provided by htmx, and it consists of five attributes that can be used to issue the five different
developer-facing types of HTTP requests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hx-get</code> - issues an HTTP <code>GET</code> request</p>
</li>
<li>
<p><code>hx-post</code> - issues an HTTP <code>POST</code> request</p>
</li>
<li>
<p><code>hx-put</code> - issues an HTTP <code>PUT</code> request</p>
</li>
<li>
<p><code>hx-patch</code> - issues an HTTP <code>PATCH</code> request</p>
</li>
<li>
<p><code>hx-delete</code> - issues an HTTP <code>DELETE</code> request</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of these attributes, when placed on an element, tell the htmx library: &#8220;When a user clicks (or whatever) this
element, issue an HTTP request of the specified type&#8221;</p>
</div>
<div class="paragraph">
<p>The values of these attributes are similar to the values of both <code>href</code> on anchors and <code>action</code> on forms: you specify the
URL you wish to issue the given HTTP request type to.  Typically, this is done via a server-relative path.</p>
</div>
<div class="paragraph">
<p>As a first example, if we wanted a button to issue a <code>GET</code> request to <code>/contacts</code> then we would write the following
HTML:</p>
</div>
<div class="listingblock">
<div class="title">A Simple htmx-Powered Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts"&gt; <b class="conum">(1)</b>
  Get The Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A simple button that issues an HTTP <code>GET</code> to <code>/contacts</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The htmx library will see the <code>hx-get</code> attribute on this button, and hook up some JavaScript logic to issue an HTTP
<code>GET</code> AJAX request to the <code>/contacts</code> path when the user clicks on it.</p>
</div>
<div class="paragraph">
<p>Very easy to understand and very consistent with the rest of HTML.</p>
</div>
<div class="sect3">
<h4 id="_its_all_just_html">It&#8217;s All Just HTML!</h4>
<div class="paragraph">
<p>With this request being issued by the button above, we get to perhaps the most important thing to understand about htmx:
it expects the response to this AJAX request <em>to be HTML</em>!  htmx is an extension of HTML.  A native hypermedia control
like an anchor tag will typically get an HTML response to a request it creates.  Similarly, htmx expects the server to
respond to the requests that it makes with HTML.</p>
</div>
<div class="paragraph">
<p>This may come as a bit of a shock to web developers who are used to responding to an AJAX request with JSON,
which is far and away the most common response format for such requests.  But AJAX requests are just HTTP requests and
there is no rule saying they must use JSON!  Recall again that AJAX stands for Asynchronous JavaScript &amp; XML, so JSON
is already a step away from the format originally envisioned for this API: XML.</p>
</div>
<div class="paragraph">
<p>htmx simply goes another direction and expects HTML.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">htmx vs. &#8220;plain&#8221; HTML responses</div>
        <div class="paragraph">
<p>There is an important difference between the HTTP responses to &#8220;normal&#8221; anchor and form driven HTTP requests and to
htmx-powered requests like the one made by this button: in the case of htmx triggered requests, responses are often
only <em>partial</em> bits of HTML.</p>
</div>
<div class="paragraph">
<p>In htmx-powered interactions, as you will see, we are often not replacing the entire document.  Rather we are using
&#8220;transclusion&#8221; to include content <em>within</em> an existing document.  Because of this, it is often not necessary or desirable
to transfer an entire HTML document from the server to the browser.</p>
</div>
<div class="paragraph">
<p>This fact can be used to save bandwidth as well as resource loading time, since less overall content is transferred from
the server to the client and since it isn&#8217;t necessary to reprocess a <code>head</code> tag with style sheets, script tags, and so forth.</p>
</div>
    </aside>
<div class="paragraph">
<p>Let&#8217;s consider what a simple <em>partial</em> HTML response to the &#8220;Get Contacts&#8221; button might be when it is clicked.</p>
</div>
<div class="paragraph">
<p>It might look something like this:</p>
</div>
<div id="listing-3-3" class="listingblock">
<div class="title">A partial HTML Response to an htmx Request</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href="mailto:joe@example.com"&gt;Joe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="mailto:sarah@example.com"&gt;Sarah&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="mailto:fred@example.com"&gt;Fred&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is just a simple unordered list of contacts with some clickable elements in it.  Note that there is no opening
<code>html</code> tag, no <code>head</code> tag, and so forth: it is a <em>raw</em> HTML list, without any decoration around it.  A response in a
real application might of course contain more sophisticated HTML than this simple list, but even if it were more complicated
it wouldn&#8217;t need to be an entire page of HTML: it could be only the &#8220;inner&#8221; content of the HTML representation for
this resource.</p>
</div>
<div class="paragraph">
<p>Now, this simple list response is perfect for htmx.  htmx will simply take the returned content and then swap it in to
the DOM in place of some element in the page.  (More on exactly where it will be placed in the DOM in a moment.)  Swapping
in HTML content in this manner is fast and efficient because it leverages the existing native HTML parser in the browser,
rather than requiring a significant amount of client-side JavaScript to be executed.</p>
</div>
<div class="paragraph">
<p>This small HTML response might not look like much, but it shows how htmx stays within the hypermedia
paradigm: just like in a &#8220;normal&#8221; hypermedia control in a &#8220;normal&#8221; web application, we see hypermedia being transferred
to the client in a stateless and uniform manner.</p>
</div>
<div class="paragraph">
<p>This button just gives us a slightly more sophisticated mechanism for building a web application using hypermedia.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_targeting_other_elements">5.4. Targeting Other Elements</h3>
<div class="paragraph">
<p>Now, given that htmx has issued a request and gotten back some HTML as a response, and that we are going to swap this
content into the existing page (rather than replacing the entire page), the question becomes: where should this new
content be placed?</p>
</div>
<div class="paragraph">
<p>It turns out that the default htmx behavior is to simply put the returned content inside the element that triggered the
request.  That&#8217;s obviously <em>not</em> a good thing in this situation: we will end up with a list of contacts awkwardly embedded within
the button element.  That will look pretty silly and is obviously not what we want.</p>
</div>
<div class="paragraph">
<p>Fortunately htmx provides another attribute, <code>hx-target</code> which can be used to specify exactly where in the DOM the
new content should be placed.  The value of the <code>hx-target</code> attribute is a Cascading Style Sheet (CSS) <em>selector</em> that
allows you to specify the element to put the new hypermedia content into.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add a <code>div</code> tag that encloses the button with the id <code>main</code>.  We will then target this <code>div</code> with the response:</p>
</div>
<div id="listing-3-4" class="listingblock">
<div class="title">A Simple htmx-Powered Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt; <b class="conum">(1)</b>

  &lt;button hx-get="/contacts" hx-target="#main"&gt; <b class="conum">(2)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A <code>div</code> element that wraps the button</p>
</li>
<li>
<p>The <code>hx-target</code> attribute that specifies the target of the response</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have added <code>hx-target="#main"</code> to our button, where <code>#main</code> is a CSS selector that says &#8220;The thing with the ID &#8216;main&#8217;&#8221;.</p>
</div>
<div class="paragraph">
<p>By using CSS selectors, htmx is once again building on top of familiar and standard HTML concepts.  This keeps the
additional conceptual load beyond HTML required for working with htmx to a minimum.</p>
</div>
<div class="paragraph">
<p>Given this new configuration, what would the HTML on the client look like after a user clicks on this button and a
response has been received and processed?</p>
</div>
<div class="paragraph">
<p>It would look something like this:</p>
</div>
<div id="listing-3-5" class="listingblock">
<div class="title">Our HTML After the htmx Request Finishes</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="mailto:joe@example.com"&gt;Joe&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="mailto:sarah@example.com"&gt;Sarah&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="mailto:fred@example.com"&gt;Fred&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response HTML has been swapped into the <code>div</code>, replacing the button that triggered the request.  Transclusion!  And
this has happened &#8220;in the background&#8221; via AJAX, without a large, clunky page refresh.</p>
</div>
</div>
<div class="sect2">
<h3 id="_swap_styles">5.5. Swap Styles</h3>
<div class="paragraph">
<p>Now, perhaps we don&#8217;t want to simply load the content from the server response <em>into</em> the div, as child elements.  Perhaps,
for whatever reason, we wish to <em>replace</em> the entire div with the response.  To handle this, htmx provides another
attribute, <code>hx-swap</code>, that allows you to specify exactly <em>how</em> the content should be swapped into  the DOM.</p>
</div>
<div class="paragraph">
<p>The <code>hx-swap</code> attribute supports the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>innerHTML</code> - The default, replace the inner html of the target element</p>
</li>
<li>
<p><code>outerHTML</code> - Replace the entire target element with the response</p>
</li>
<li>
<p><code>beforebegin</code> - Insert the response before the target element</p>
</li>
<li>
<p><code>afterbegin</code> - Insert the response before the first child of the target element</p>
</li>
<li>
<p><code>beforeend</code> - Insert the response after the last child of the target element</p>
</li>
<li>
<p><code>afterend</code> - Insert the response after the target element</p>
</li>
<li>
<p><code>delete</code> - Deletes the target element regardless of the response</p>
</li>
<li>
<p><code>none</code> - No swap will be performed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two values, <code>innerHTML</code> and <code>outerHTML</code>, are taken from the standard DOM properties that allow you to replace content
within an element or in place of an entire element respectively.</p>
</div>
<div class="paragraph">
<p>The next four values are taken from the <code>Element.insertAdjacentHTML()</code> DOM API, which allow you to place an element or
elements around a given element in various ways.</p>
</div>
<div class="paragraph">
<p>The last two values, <code>delete</code> and <code>none</code> are specific to htmx.  The first option will remove the target element from the
DOM, while the second option will do nothing (you may want to only work with response headers, an advanced technique we
will look at later in the book.)</p>
</div>
<div class="paragraph">
<p>Again, you can see htmx stays as close as possible to the existing web standards in order to keep the conceptual load
necessary to use it to a minimum.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s consider that case where, rather than replacing the <code>innerHTML</code> content of the main div above, we want to
replace the <em>entire div</em> with the HTML response.</p>
</div>
<div class="paragraph">
<p>To do so would require only a small change to our button, adding a new <code>hx-swap</code> attribute:</p>
</div>
<div id="listing-3-6" class="listingblock">
<div class="title">Replacing the Entire div</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;button hx-get="/contacts" hx-target="#main" hx-swap="outerHTML"&gt; <b class="conum">(1)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>hx-swap</code> attribute specifies how to swap new content in</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when a response is received, the <em>entire</em> div will be replaced with the hypermedia content:</p>
</div>
<div id="listing-3-7" class="listingblock">
<div class="title">Our HTML After the htmx Request Finishes</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href="mailto:joe@example.com"&gt;Joe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="mailto:sarah@example.com"&gt;Sarah&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="mailto:fred@example.com"&gt;Fred&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that, with this change, the target div has been entirely removed from the DOM, and the list that was returned
as the response has replaced it.</p>
</div>
<div class="paragraph">
<p>Later in the book we will see additional uses for <code>hx-swap</code>, for example when we implement infinite scrolling in our
contact management application.</p>
</div>
<div class="paragraph">
<p>Note that with the <code>hx-get</code>, <code>hx-post</code>, <code>hx-put</code>, <code>hx-patch</code> and <code>hx-delete</code> attributes, we have addressed two of the
four opportunities for improvement that we enumerated regarding plain HTML:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Opportunity 1: We can now issue an HTTP request with <em>any</em> element (in this case we are using a button)</p>
</li>
<li>
<p>Opportunity 3: We can issue <em>any sort</em> of HTTP request we want, <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code>, in particular</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And, with <code>hx-target</code> and <code>hx-swap</code> we have addressed a third opportunity:
the requirement that the entire page be replaced.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Opportunity 4: We can now replace any element we want in our page via transclusion, and we can do so in any manner want</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, with only seven relatively simple additional attributes, we have addressed most of the shortcomings of HTML as a
hypermedia that we identified earlier.</p>
</div>
<div class="paragraph">
<p>There was one remaining shortcoming of HTML that we noted: the fact that only a <code>click</code> event (on an anchor) or a <code>submit</code> event
(on a form) can trigger a HTTP request.  Let&#8217;s look at how we can address that concern next.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_events">5.6. Using Events</h3>
<div class="paragraph">
<p>Thus far we have been using a button to issue a request with htmx.  You have probably intuitively understood that the
button would issue its request when you clicked on the button since, well, since that&#8217;s what you do with buttons: you
click on them.</p>
</div>
<div class="paragraph">
<p>And, yes, by default when an <code>hx-get</code> or another request-driving annotation from htmx is placed on a button, the request
will be issued when the button is clicked.</p>
</div>
<div class="paragraph">
<p>However, htmx generalizes this notion of an event triggering a request by using, you guessed it, another attribute:
<code>hx-trigger</code>.  The <code>hx-trigger</code> attribute allows you to specify one or more events that will cause the element to
trigger an HTTP request.</p>
</div>
<div class="paragraph">
<p>Often you don&#8217;t need to use <code>hx-trigger</code> because the default triggering event will be what you want.
The default triggering event depends on the element type, but should be fairly intuitive to anyone
familiar with HTML:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Requests on <code>input</code>, <code>textarea</code> &amp; <code>select</code> elements are triggered by the <code>change</code> event</p>
</li>
<li>
<p>Requests on <code>form</code> elements are triggered on the <code>submit</code> event</p>
</li>
<li>
<p>Requests on all other elements are triggered by the <code>click</code> event</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to demonstrate how <code>hx-trigger</code> works, lets consider the following situation: we want to trigger the request
on our button when the mouse enters it.  Now, this is certainly not a <em>good</em> UX pattern, but bear with us: we are just
using this an example.</p>
</div>
<div class="paragraph">
<p>To respond to a mouse entering the button, we would add the following attribute to our button:</p>
</div>
<div id="listing-3-8" class="listingblock">
<div class="title">A Bad Idea, But It Demonstrates The Concept!</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;button hx-get="/contacts" hx-target="#main" hx-swap="outerHTML" hx-trigger="mouseenter"&gt; <b class="conum">(1)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue a request&#8230;&#8203; on the <code>mouseenter</code> event?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, with this <code>hx-trigger</code> attribute in place, whenever the mouse enters this button, a request will be triggered.  Silly,
but it works.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try something a bit more realistic and potentially useful: let&#8217;s add some support for a keyboard shortcut for
loading the contacts, <code>Ctrl-L</code> (for &#8220;Load&#8221;).  To do this we will need to take advantage of some additional syntax that
the <code>hx-trigger</code> attribute supports: event filters and additional arguments.</p>
</div>
<div class="paragraph">
<p>Event filters are a mechanism for determining if a given event should trigger a request or not.  They are applied to an
event by adding square brackets after it: <code>someEvent[someFilter]</code>.  The filter itself is a JavaScript expression that
will be evaluated when the given event occurs.  If the result is truthy, in the JavaScript sense, it will trigger the
request.  If not, the request will not be triggered.</p>
</div>
<div class="paragraph">
<p>In the case of keyboard shortcuts, we want to catch the <code>keyup</code> event in addition to the click event:</p>
</div>
<div id="listing-3-9" class="listingblock">
<div class="title">A Start</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;button hx-get="/contacts" hx-target="#main" hx-swap="outerHTML" hx-trigger="click, keyup"&gt; <b class="conum">(1)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A trigger with two events</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that we have a comma separated list of events that can trigger this element, allowing us to respond to more than
one potential triggering event.  We still want to respond to the <code>click</code> event and load the contacts, in addition
to handling the <code>Ctrl-L</code> keyboard shortcut.</p>
</div>
<div class="paragraph">
<p>There are, unfortunately, two problems with our <code>keyup</code> addition:  As it stands, it will trigger requests on <em>any</em> keyup
event that occurs.  And, worse, it will only trigger when a keyup occurs <em>within</em> this button.  This is highly unlikely (the
user would need to tab onto the button to make it active and then begin typing!)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s fix these two issues. To fix the first one, we will use a trigger filter to test that Control key and the &#8220;L&#8221; key
are pressed together:</p>
</div>
<div id="listing-3-10" class="listingblock">
<div class="title">Better!</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;button hx-get="/contacts" hx-target="#main" hx-swap="outerHTML" hx-trigger="click, keyup[ctrlKey &amp;&amp; key == 'l']"&gt; <b class="conum">(1)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>keyup</code> now has a filter, so the control key and L must be pressed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The trigger filter in this case is <code>ctrlKey &amp;&amp; key == 'l'</code>.  This can be read as &#8220;A key up event, where the ctrlKey property
is true and the key property is equal to l&#8221;.  Note that the properties <code>ctrlKey</code> and <code>key</code> are resolved against the event
rather than the global name space, so you can easily filter on the properties of a given event.  You can use any expression
you like for a filter, however: calling a global JavaScript function, for example, is perfectly acceptable.</p>
</div>
<div class="paragraph">
<p>OK, so this filter limits the keyup events that will trigger the request to only <code>Ctrl-L</code> presses.  However, we still have
the problem that, as it stands, only <code>keyup</code> events <em>within</em> the button will trigger the request.</p>
</div>
<div class="paragraph">
<p>If you are not familiar with the JavaScript event bubbling model: events typically &#8220;bubble&#8221; up to parent elements.  So an
event like <code>keyup</code> will be triggered first on the focused element, and then on its parent (enclosing) element, and so
on, until it reaches the top level <code>document</code> object that is the root of all other elements.</p>
</div>
<div class="paragraph">
<p>To support a global keyboard shortcut that works regardless of what element has focus, we will take advantage of
event bubbling and a feature that the <code>hx-trigger</code> attribute supports: the ability to listen to <em>other elements</em> for
events.  The syntax for doing this is the <code>from:</code> modifier, which is added after an event name and that allows you to
specify a specific element to listen for the given event on using a CSS selector.</p>
</div>
<div class="paragraph">
<p>In this case, we want to listen to the <code>body</code> element, which is the parent element of all visible elements on the page.</p>
</div>
<div class="paragraph">
<p>Here is what our updated <code>hx-trigger</code> attribute looks like:</p>
</div>
<div id="listing-3-11" class="listingblock">
<div class="title">Better!</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;button hx-get="/contacts" hx-target="#main" hx-swap="outerHTML" hx-trigger="click, keyup[ctrlKey &amp;&amp; key == 'L'] from:body"&gt;<b class="conum">(1)</b>
    Get The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Listen to the event on the <code>body</code> tag</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, in addition to clicks, the button will listen for <code>keyup</code> events on the body of the page.  So it will now issue a
request when it is clicked on and also whenever someone hits <code>Ctrl-L</code> within the body of the page.</p>
</div>
<div class="paragraph">
<p>A nice keyboard shortcut for our Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>The <code>hx-trigger</code> attribute supports many more modifiers, and it is more elaborate than other htmx attributes. This is because
events, in general, are complicated and require a lot of small details to get just right.  The default trigger will often
suffice, however, and you shouldn&#8217;t need to reach for complicated <code>hx-trigger</code> features too often when using htmx.</p>
</div>
<div class="paragraph">
<p>Even with more sophisticated trigger specifications like the keyboard shortcut we just added, the overall feel of htmx is
<em>declarative</em> rather than <em>imperative</em>.  That keeps htmx-powered applications &#8220;feeling like&#8221; standard web 1.0 applications
in a way that adding significant amounts of JavaScript does not.</p>
</div>
</div>
<div class="sect2">
<h3 id="_htmx_html_extended">5.7. htmx: HTML eXtended</h3>
<div class="paragraph">
<p>And hey, check it out!  With <code>hx-trigger</code> we have addressed the final opportunity for improvement of HTML that we
outlined at the start of this chapter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Opportunity 2: We can use <em>any</em> event to trigger an HTTP request</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That&#8217;s a grand total of eight, count 'em, <em>eight</em> attributes that all fall squarely within the same conceptual model as
normal HTML and that, by extending HTML as a hypermedia, open up whole new world of user interaction possibilities
within HTML.</p>
</div>
<div class="paragraph">
<p>Here is a table summarizing those opportunities and which htmx attributes exactly address them:</p>
</div>
<div class="dlist">
<div class="title">Opportunities For Improving HTML</div>
<dl>
<dt class="hdlist1">Any element should be able to make HTTP requests</dt>
<dd>
<p><code>hx-get</code>, <code>hx-post</code>, <code>hx-put</code>, <code>hx-patch</code>, <code>hx-delete</code></p>
</dd>
<dt class="hdlist1">Any event should be able to trigger an HTTP request</dt>
<dd>
<p><code>hx-trigger</code></p>
</dd>
<dt class="hdlist1">Any HTTP Action should be available</dt>
<dd>
<p><code>hx-put</code>, <code>hx-patch</code>, <code>hx-delete</code></p>
</dd>
<dt class="hdlist1">Any place on the page should be replaceable (transclusion)</dt>
<dd>
<p><code>hx-target</code>, <code>hx-swap</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_passing_request_parameters">5.8. Passing Request Parameters</h3>
<div class="paragraph">
<p>So far we have been just looking at a situation where a button makes a simple <code>GET</code> request.  This is conceptually very
close to what an anchor tag might do.  But there is that other native hypermedia control in HTML-based applications:
forms.  Forms are used to pass additional information beyond just a URL up to the server in a request.</p>
</div>
<div class="paragraph">
<p>This information is captured via input and input-like elements within the form via the various types of input tags
available in HTML.</p>
</div>
<div class="paragraph">
<p>htmx allows you include this additional information in a natural way that, as you should now expect, mirrors how HTML
itself works.</p>
</div>
<div class="sect3">
<h4 id="_enclosing_forms">Enclosing Forms</h4>
<div class="paragraph">
<p>The simplest way to pass input values up with a request in htmx is to enclose the element making a request within a form
tag.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take our original button for retrieving contacts and repurpose it for searching contacts:</p>
</div>
<div id="listing-3-12" class="listingblock">
<div class="title">A Simple htmx-Powered Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;form&gt; <b class="conum">(1)</b>
      &lt;label for="search"&gt;Search Contacts:&lt;/label&gt;
      &lt;input id="search" name="q" type="search" placeholder="Search Contacts"&gt; <b class="conum">(2)</b>
      &lt;button hx-post="/contacts" hx-target="#main"&gt; <b class="conum">(3)</b>
        Search The Contacts
      &lt;/button&gt;
  &lt;/form&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>With an enclosing form tag, all inputs values will be submitted</p>
</li>
<li>
<p>A new input that users will be able to enter search text into</p>
</li>
<li>
<p>Our button has been converted to an <code>hx-post</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here we have added a form tag surrounding the button along with a search input that can be used to enter a term to
search the contacts with.</p>
</div>
<div class="paragraph">
<p>Now, when a user clicks on the button, the value of the input with the id <code>search</code> will be included in the request.  This
is by virtue of the fact that there is a form tag enclosing both the button and the input: when an htmx-driven request
is triggered, htmx will look up the DOM hierarchy for an enclosing form, and, if one is found, it will include all
values from within that form.  (This is sometimes referred to as &#8220;serializing&#8221; the form.)</p>
</div>
<div class="paragraph">
<p>You might have noticed that the button was switched from a <code>GET</code> request to a <code>POST</code> request.  This is because, by default,
htmx does <em>not</em> include the closest enclosing form for <code>GET</code> requests, but it <em>does</em> include the form for all other types
of requests.</p>
</div>
<div class="paragraph">
<p>This may seem a little strange, but it avoids junking up URLs that are used within form when dealing with history
entries, which we will discuss in a bit.  And you can always include an enclosing form&#8217;s values with an element that
uses a <code>GET</code> by using the <code>hx-include</code> attribute, discussed next.</p>
</div>
</div>
<div class="sect3">
<h4 id="_including_inputs">Including inputs</h4>
<div class="paragraph">
<p>While enclosing all the inputs you want included in a request is the most common approach for including values from inputs
in htmx requests, it isn&#8217;t always possible or desirable: form tags can have layout consequences and simply cannot be
placed in some spots in HTML documents.  A good example of the latter situation is in table row (<code>tr</code>) elements: the
<code>form</code> tag is not a valid child or parent of table rows, so you can&#8217;t place a form within or around an entire
row of data in a table.</p>
</div>
<div class="paragraph">
<p>To address this issue, htmx provides another mechanism for including input values in requests: the <code>hx-include</code> attribute.
The <code>hx-include</code> attribute allows you to select input values that you wish to include in a request via CSS selectors.</p>
</div>
<div class="paragraph">
<p>Here is the above example reworked to include the input, dropping the form:</p>
</div>
<div id="listing-3-13" class="listingblock">
<div class="title">A Simple htmx-Powered Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="main"&gt;

  &lt;label for="search"&gt;Search Contacts:&lt;/label&gt;
  &lt;input id="search" name="q" type="search" placeholder="Search Contacts"&gt;
  &lt;button hx-post="/contacts" hx-target="#main" hx-include="#search"&gt; <b class="conum">(1)</b>
    Search The Contacts
  &lt;/button&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>hx-include</code> can be used to include values directly in a request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>hx-include</code> attribute takes a CSS selector value and allows you to specify exactly which values to send along
with the request.  This can be useful if it is difficult to colocate an element issuing a request with all the inputs
that need to be submitted with it.</p>
</div>
<div class="paragraph">
<p>It is also useful when you do, in fact, want to submit values with a <code>GET</code> request and overcome the default behavior of
htmx with respect to <code>GET</code> requests.</p>
</div>
<div class="sect4">
<h5 id="_relative_css_selectors">Relative CSS Selectors</h5>
<div class="paragraph">
<p>The <code>hx-include</code> attribute and, in fact, most attributes that take a CSS selector, also support <em>relative</em> CSS selectors,
that allow you to specify a CSS selector <em>relative</em> to the element it is declared on.  Here are some examples:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>closest</code></dt>
<dd>
<p>Find the closest parent element matching the given selector, e.g. <code>closest form</code></p>
</dd>
<dt class="hdlist1"><code>next</code></dt>
<dd>
<p>Find the next element (scanning forward) matching the given selector, e.g. <code>next input</code></p>
</dd>
<dt class="hdlist1"><code>previous</code></dt>
<dd>
<p>Find the previous element (scanning backwards) matching the given selector, e.g. <code>previous input</code></p>
</dd>
<dt class="hdlist1"><code>find</code></dt>
<dd>
<p>Find the next element within this element matching the given selector, e.g. <code>find input</code></p>
</dd>
<dt class="hdlist1"><code>this</code></dt>
<dd>
<p>the current element</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Using relative CSS selectors often allows you to avoid needing to generate ids for elements, since you can take advantage
of their local structural layout instead.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inline_values">Inline Values</h4>
<div class="paragraph">
<p>A final way to include values in htmx-driven requests is to use the <code>hx-vals</code> attribute, which allows you to include
&#8220;static&#8221; values in the request.  This can be useful if you have additional information that you want to include in
requests, but you don&#8217;t want to have this information embedded in, for example, hidden inputs (which would be the
standard mechanism for including additional, hidden information in HTML.)</p>
</div>
<div class="paragraph">
<p>Here is an example of <code>hx-vals</code>:</p>
</div>
<div class="listingblock">
<div class="title">A Simple htmx-Powered Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-vals='{"state":"MT"}'&gt; <b class="conum">(1)</b>
  Get The Contacts In Montana
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>hx-vals</code>, a JSON value to include in the request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The parameter <code>state</code> with the value <code>MT</code> will be included in the <code>GET</code> request, resulting in a path and parameters that
looks like this:  <code>/contacts?state=MT</code>.  One thing to note is that we switched the <code>hx-vals</code> attribute to use single quotes
around its value.  This is because JSON strictly requires double quotes and, therefore, to avoid escaping we needed to
use the single-quote form for the attribute value.</p>
</div>
<div class="paragraph">
<p>You can also prefix <code>hx-vals</code> with a <code>js:</code> and pass values evaluated at the time of the request, which can be useful for
including things like a dynamically maintained variable, or value from a third party JavaScript library.</p>
</div>
<div class="paragraph">
<p>For example, if the <code>state</code> variable were maintained dynamically, via some JavaScript, and there existed a JavaScript
function, <code>getCurrentState()</code>, that returned the currently selected state, it could be included dynamically in htmx
requests like so:</p>
</div>
<div class="listingblock">
<div class="title">A Dynamic Value</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-vals='js:{"state":getCurrentState()}'&gt; <b class="conum">(1)</b>
  Get The Contacts In The Selected State
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>With the <code>js:</code> prefix, this expression will evaluate at submit time</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These three mechanisms, using <code>form</code> tags, using the <code>hx-include</code> attribute and using the <code>hx-vals</code> attribute, allow you
to include values in your hypermedia requests with htmx in a manner that should feel very familiar and in keeping with
the spirit of HTML, while also giving you the flexibility to achieve what you want.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_history_support">5.9. History Support</h3>
<div class="paragraph">
<p>A final piece of functionality to discuss to close out our overview of htmx is browser history support.  When you use normal
HTML links and forms, your browser will keep track of all the pages that you have visited.  You can then use the back button
to navigate back to a previous page and, once you have done this, you can use a forward button to go forward to the
original page you were on.</p>
</div>
<div class="paragraph">
<p>This notion of history was one of the killer features of the early web.  Unfortunately it turns out that history becomes
tricky when you move to the Single Page Application paradigm.  An AJAX request does not, by itself, register a web
page in your browsers history, which is a good thing: an AJAX request may have nothing to do with the state of the
web page (perhaps it is just recording some activity in the browser), so it wouldn&#8217;t be appropriate to create a new
history entry for the interaction.</p>
</div>
<div class="paragraph">
<p>However, there are likely to be a lot of AJAX driven interactions in a Single Page Application where it <em>is</em> appropriate
to create a history entry.  And, it turns out, there is a JavaScript API for working with the history of a browser.
Unfortunately, this API is deeply annoying and difficult to work with and, thus, is often ignored by JavaScript developers.</p>
</div>
<div class="paragraph">
<p>If you have ever used a Single Page Application and accidentally clicked the back button, only to lose your entire
application state and have to start over, you have seen this problem in action.</p>
</div>
<div class="paragraph">
<p>In htmx, as with Single Page Application frameworks, you will often need to explicitly work with the history API.
Fortunately, since htmx sticks so close to the original model of the web and since it is declarative, getting web history
right is typically much easier to do in an htmx-based application.</p>
</div>
<div class="paragraph">
<p>Consider the button we have been looking at to load contacts:</p>
</div>
<div id="listing-3-14" class="listingblock">
<div class="title">Our trusty button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-target="#main"&gt;
  Get The Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As it stands, if you click this button it will retrieve the content from <code>/contacts</code> and load it into the element with the
id <code>main</code>, but it will <em>not</em> create a new history entry.</p>
</div>
<div class="paragraph">
<p>If we wanted it to create a history entry when this request happened, we would add a new attribute to the button, the
<code>hx-push-url</code> attribute:</p>
</div>
<div class="listingblock">
<div class="title">Our trusty button, now with history!</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-target="#main" hx-push-url="true"&gt; <b class="conum">(1)</b>
  Get The Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>hx-push-url</code> will create an entry in history when the button is clicked</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when the button is clicked, the <code>/contacts</code> path will be put into the browser&#8217;s navigation bar and a history entry
will be created for it.  Furthermore, if the user clicks the back button, the original content for the page will be
restored, along with the original URL.</p>
</div>
<div class="paragraph">
<p>Now, the name <code>hx-push-url</code> for this attribute might sound a little obscure, but it is based on the JavaScript API,
<code>history.pushState()</code>.  This notion of &#8220;pushing&#8221; derives from the fact that history entries are modeled as a stack, and
so you are &#8220;pushing&#8221; new entries onto the top of the stack of history entries.</p>
</div>
<div class="paragraph">
<p>With this relatively simple, declarative mechanism, htmx allows you to integrate with the back button in a way that mimics the
&#8220;normal&#8221; behavior of HTML.  Not bad if you look at what other JavaScript libraries want you to do to make history work!</p>
</div>
<div class="paragraph">
<p>Now, there is one additional thing we need to handle to get history &#8220;just right&#8221;: we have &#8220;pushed&#8221; the <code>/contacts</code> path
into the browsers location bar successfully, and the back button works.  But what if someone refreshes their browser while
on the <code>/contacts</code> page?</p>
</div>
<div class="paragraph">
<p>In this case, you will need to handle the htmx-based &#8220;partial&#8221; response as well as the non-htmx &#8220;full page&#8221; response.  You
can do this using HTTP headers, a topic we will go into in detail later in the book.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_2">5.10. Conclusion</h3>
<div class="paragraph">
<p>So that&#8217;s our whirlwind introduction to htmx.  We&#8217;ve only seen about ten attributes from the library, but we think you
can probably see a hint of just how powerful these attributes can be: by adopting htmx you will be able to create a much
more sophisticated web application than is possible in plain HTML, but your conceptual load will not be nearly as high
as it is for most JavaScript-based approaches.</p>
</div>
<div class="paragraph">
<p>htmx is a very pure extension to HTML, aiming to incrementally improve the language as a hypermedia in a manner that is
conceptually coherent with the underlying markup language.  Like any technical choice, this is not without
trade-offs: by staying so close to HTML, htmx does not give developers a lot of infrastructure that many might feel
should be there &#8220;by default&#8221;.</p>
</div>
<div class="paragraph">
<p>A good example is the concept of modal dialogs. Many web applications today make heavy use of modal dialogs, effectively
in-page pop-ups that sit &#8220;on top&#8221; of the existing page.  (Of course, in reality, this is an optical illusion and it is
all just a web page: the web has no notion of &#8220;modals&#8221; in this regard.)</p>
</div>
<div class="paragraph">
<p>A web developer might expect htmx, as a front end library, to provide some sort of modal dialog component out of the box.</p>
</div>
<div class="paragraph">
<p>htmx, however, has no such notion of modals.  That&#8217;s not to say you can&#8217;t use modals with htmx, and we will look at how you
can do so later.  But htmx, like HTML itself, won&#8217;t give you an API specifically for creating modals.  You
would need to use a 3rd party library or roll your own modal implementation and then integrate htmx into it if you want
to use modals within an htmx-based application.</p>
</div>
<div class="paragraph">
<p>By staying closer to the original model of the web, htmx aims to strike a balance between simplicity and functionality,
deferring to other libraries for more elaborate front-end extensions on top of the existing web platform.  The good news
is that htmx plays well with others, so when these needs arise it is often easy enough to bring in another library to handle
them.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_htmx_patterns">6. htmx Patterns</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we&#8217;ve seen how htmx extends HTML as a hypermedia, it&#8217;s time to put it into action.  As we use htmx, we will still
be using hypermedia: we will issue HTTP requests and get back HTML.  But, with the additional functionality that htmx provides,
we will have a more <em>powerful hypermedia</em> to work with, allowing us to accomplish much more sophisticated interfaces.</p>
</div>
<div class="paragraph">
<p>This will allow us to address user experience issues, such as long feedback cycles or painful page refreshes, without
needing to write much, if any, JavaScript, and without creating a JSON API.  Everything will be implemented in hypermedia,
using the core concepts of the original web.</p>
</div>
<div class="sect2">
<h3 id="_installing_htmx">6.1. Installing htmx</h3>
<div class="paragraph">
<p>The first thing we need to do is install htmx in our web application.  We are going to do this by downloading the
source and saving it locally in our application, so we aren&#8217;t dependent on any external systems.  This is known as &#8220;vendoring&#8221;
the library.  We can grab the latest version of htmx by navigating our browser to <code><a href="https://unpkg.com/htmx.org" class="bare">https://unpkg.com/htmx.org</a></code>, which will
redirect us to the source of the latest version of the library.</p>
</div>
<div class="paragraph">
<p>We can save the content from this URL into the <code>static/js/htmx.js</code> file in our project.</p>
</div>
<div class="paragraph">
<p>You can, of course, use a more sophisticated JavaScript package manager such as Node Package Manager (NPM) or yarn to install
htmx.  You do this by referring to its package name, <code>htmx.org</code>, in the manner appropriate for your tool.  However,
htmx is very small (approximately 12kb when compressed and zipped) and is dependency free, so using it does not require
an elaborate mechanism or build tool.</p>
</div>
<div class="paragraph">
<p>With htmx downloaded locally to our applications <code>/static/js</code> directory, we can now load it in to our application.
We do this by adding the following <code>script</code> tag to the <code>head</code> tag in our <code>layout.html</code> file, which will make htmx
available and active on every page in our application:</p>
</div>
<div id="listing-4-1" class="listingblock">
<div class="title">Installing htmx</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;head&gt;
    &lt;script src="/js/htmx.js"&gt;&lt;/script&gt;
    ...
  &lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recall that the <code>layout.html</code> file is a <em>layout</em> file included in most templates that wraps the content of those templates
in common HTML, including a <code>head</code> element that we are using here to install htmx.</p>
</div>
<div class="paragraph">
<p>Believe it or not, that&#8217;s it!  This simple script tag will make htmx&#8217;s functionality available across our entire application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ajax_ifying_our_application">6.2. AJAX-ifying Our Application</h3>
<div class="paragraph">
<p>To get our feet wet with htmx, the first feature we are going to take advantage of, is what is known as &#8220;boosting&#8221;.  This is
a bit of a &#8220;cheater&#8221; feature of htmx in that we don&#8217;t need to do much beyond adding a single attribute, <code>hx-boost</code>, to the
application.  This <code>hx-boost</code> attribute is unlike most other attributes in htmx: whereas other htmx attributes tend to be
very focused on one aspect of improving HTML (e.g. <code>hx-trigger</code> focuses on the events that trigger a request, <code>hx-swap</code> focuses on how responses
are swapped into the DOM, etc.) the <code>hx-boost</code> attribute, in contrast, is a high-level attribute.</p>
</div>
<div class="paragraph">
<p>When you put <code>hx-boost</code> on a given element with the value <code>true</code>, it will &#8220;boost&#8221; all anchor and form elements within that
element.  &#8220;Boost&#8221;, here, means that htmx will convert all those anchors and forms from &#8220;normal&#8221; hypermedia controls
into AJAX-powered hypermedia controls.  Rather than issuing &#8220;normal&#8221; HTTP requests that replace the whole page, the links
and forms will issue AJAX requests and then htmx will swap the inner content of the <code>&lt;body&gt;</code> tag in the response to these
requests into the existing pages <code>&lt;body&gt;</code> tag.</p>
</div>
<div class="paragraph">
<p>This makes navigation feel faster because the browser will not be re-interpreting most of the tags in the response
<code>&lt;head&gt;</code> and so forth.</p>
</div>
<div class="sect3">
<h4 id="_boosted_links">Boosted Links</h4>
<div class="paragraph">
<p>Let&#8217;s take a look at an example of a boosted link.  Below is a link to a hypothetical settings page for a web application.
Because it has <code>hx-boost="true"</code> on it, htmx will halt the normal link behavior of issuing a request to the <code>/settings</code> path and replacing
the entire page with the response.  Instead, htmx will issue an AJAX request to <code>/settings</code>, taking the result and replacing
the <code>body</code> element with the new content.</p>
</div>
<div class="listingblock">
<div class="title">A Boosted Link</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="/settings" hx-boost="true"&gt;Settings&lt;/a&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A simple attribute makes this link AJAX-powered</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You might reasonably ask: what&#8217;s the advantage here?  We are issuing an AJAX request and simply replacing the entire body.</p>
</div>
<div class="paragraph">
<p>Is that significantly different from just issuing a normal link request?</p>
</div>
<div class="paragraph">
<p>Yes, it is in fact different: with a boosted link, the browser is able to avoid any processing associated with the head tag.  The head
tag often contains many scripts and CSS file references.  In the boosted scenario, it is not necessary to re-process those
resources: the scripts and styles have already been processed and will continue to apply to the new content.  This can
often be a very easy way to speed up your hypermedia application.</p>
</div>
<div class="paragraph">
<p>A second question you might have is: does the response need to be formatted specially to work with <code>hx-boost</code>?  After all,
the settings page would normally render an <code>html</code> tag, with a <code>head</code> tag and so forth.  Do you need to handle &#8220;boosted&#8221;
requests specially?</p>
</div>
<div class="paragraph">
<p>The answer is no: htmx is smart enough to pull out only the content of the <code>body</code> tag to swap in to the new page.
The <code>head</code> tag is mostly ignored: only the title tag, if it is present, will be processed.  This means you don&#8217;t need to
do anything special on the server side to render templates that <code>hx-boost</code> can handle: just return the normal HTML for
your page, and it should work fine.</p>
</div>
<div class="paragraph">
<p>Note that boosted links (and forms) will also continue to update the navigation bar and history, just like normal links,
so users will be able to use the browser back button, will be able to copy and paste URLs (or &#8220;deep links&#8221;) and so on.
Links will act pretty much like &#8220;normal&#8221;, they will just be faster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_boosted_forms">Boosted Forms</h4>
<div class="paragraph">
<p>Boosted form tags work in a similar way to boosted anchor tags: a boosted form will use an AJAX request rather than the
usual browser-issued request, and will replace the entire body with the response:</p>
</div>
<div class="paragraph">
<p>Here is an example of a form that posts messages to the <code>/messages</code> end point using an HTTP <code>POST</code> request.  By adding
<code>hx-boost</code> to it, those requests will be done in AJAX, rather than the normal browser behavior.</p>
</div>
<div id="listing-4-2" class="listingblock">
<div class="title">A Boosted Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/messages" method="post" hx-boost="true"&gt;<b class="conum">(1)</b>
  &lt;input type="text" name="message" placeholder="Enter A Message..."&gt;
  &lt;button&gt;Post Your Message&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>As with the link, a simple attribute makes this form AJAX-powered</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A big advantage of the AJAX-based request that <code>hx-boost</code> uses (and the lack of head processing that occurs) is that it
avoids what is known as a <em>flash of unstyled content</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Flash Of Unstyled Content (FOUC)</dt>
<dd>
<p>A situation where a browser renders a web page before all the styling information is
available for the page.  A FOUC causes a disconcerting momentary &#8220;flash&#8221; of the unstyled content, which is then restyled
when all the style information is available.  You will notice this as a flicker when you move around the internet: text,
images and other content can &#8220;jump around&#8221; on the page as styles are applied to it.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>With <code>hx-boost</code> the site&#8217;s styling is already loaded <em>before</em> the new content is retrieved, so there is no such flash of
unstyled content.  This can make a &#8220;boosted&#8221; application feel both smoother and also snappier in general.</p>
</div>
</div>
<div class="sect3">
<h4 id="_attribute_inheritance">Attribute Inheritance</h4>
<div class="paragraph">
<p>Let&#8217;s expand on our previous example of a boosted link, and add a few more boosted links alongside it.  We add links
such that we have one to the <code>/contacts</code> page, the one to the <code>/settings</code> page, and one to the <code>/help</code> page.  All these
links are boosted and will behave in the manner that we have described above.</p>
</div>
<div class="paragraph">
<p>This feels a little redundant, doesn&#8217;t it?  It seems silly to annotate all three links with the <code>hx-boost="true"</code> attribute
right next to one another.</p>
</div>
<div id="listing-4-3" class="listingblock">
<div class="title">A Set of Boosted Links</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="/contacts" hx-boost="true"&gt;Contacts&lt;/a&gt;
&lt;a href="/settings" hx-boost="true"&gt;Settings&lt;/a&gt;
&lt;a href="/help" hx-boost="true"&gt;Help&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>htmx offers a feature to help reduce this redundancy: attribute inheritance.  With most attributes in htmx, if you
place it on a parent, the attribute will also apply to children elements.  This is how Cascading Style Sheets work, and
that idea inspired htmx to adopt a similar &#8220;cascading htmx attributes&#8221; feature.</p>
</div>
<div class="paragraph">
<p>To avoid the redundancy in this example, let&#8217;s introduce a <code>div</code> element that encloses all the links and then &#8220;hoist&#8221; the
<code>hx-boost</code> attribute up to that parent <code>div</code>. This will let us remove the redundant <code>hx-boost</code> attributes but ensure all the links are
still boosted, inheriting that functionality from the parent <code>div</code>.</p>
</div>
<div class="paragraph">
<p>Note that any legal HTML element could be used here, we just use a <code>div</code> out of habit.</p>
</div>
<div class="listingblock">
<div class="title">Boosting Links Via The Parent</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div hx-boost="true"&gt; <b class="conum">(1)</b>
    &lt;a href="/contacts"&gt;Contacts&lt;/a&gt;
    &lt;a href="/settings"&gt;Settings&lt;/a&gt;
    &lt;a href="/help"&gt;Help&lt;/a&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>hx-boost</code> has been moved to the parent div</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now we don&#8217;t have to put an <code>hx-boost="true"</code> on every link and, in fact, we can add more links alongside the
existing ones, and they, too, will be boosted, without us needing to explicitly annotate them.</p>
</div>
<div class="paragraph">
<p>That&#8217;s fine, but what if you have a link that you <em>don&#8217;t</em> want boosted within an element that has <code>hx-boost="true"</code> on
it?  A good example of this situation is when a link is to a resource to be downloaded, such as a PDF.  Downloading a
file can&#8217;t be handled well by an AJAX request, so you probably want that link to behave &#8220;normally&#8221;, issuing a full
page request for the PDF, which the browser will then offer to save as a file on the user&#8217;s local system.</p>
</div>
<div class="paragraph">
<p>To handle this situation, you would simply override the parent <code>hx-boost</code> value with <code>hx-boost="false"</code> on the
anchor tag that you didn&#8217;t want to be boosted:</p>
</div>
<div class="listingblock">
<div class="title">Disabling Boosting</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div hx-boost="true"&gt; <b class="conum">(1)</b>
    &lt;a href="/contacts"&gt;Contacts&lt;/a&gt;
    &lt;a href="/settings"&gt;Settings&lt;/a&gt;
    &lt;a href="/help"&gt;Help&lt;/a&gt;
    &lt;a href="/help/documentation.pdf" hx-boost="false"&gt;Download Docs&lt;/a&gt; <b class="conum">(2)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>hx-boost</code> is still on the parent div</p>
</li>
<li>
<p>The boosting behavior is overridden for this link</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here we have a new link to a documentation PDF that we wish to function like a regular link.  We have added
<code>hx-boost="false"</code> to the link and this declaration will override the <code>hx-boost="true"</code> on the parent <code>div</code>, reverting
it to regular link behavior and, thus, allowing for the file download behavior that we want.</p>
</div>
</div>
<div class="sect3">
<h4 id="_progressive_enhancement">Progressive Enhancement</h4>
<div class="paragraph">
<p>A nice aspect of <code>hx-boost</code> is that it is an example of <em>progressive enhancement</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Progressive Enhancement</dt>
<dd>
<p>A software design philosophy that aims to provide as much essential content and functionality
to as many users as possible, while delivering a better experience to users with more advanced web browsers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Consider the links in the example above.  What would happen if someone did not have JavaScript enabled?</p>
</div>
<div class="paragraph">
<p>Nothing much!</p>
</div>
<div class="paragraph">
<p>The application would continue to work, but it would issue regular HTTP requests, rather than AJAX-based
HTTP requests.  This means that your web application will work for the maximum number of users, with users of more modern
browsers (or users who have not turned off JavaScript) able to take advantage of the benefits of the AJAX-style navigation
that htmx offers, but other people will still able to use the app just fine.</p>
</div>
<div class="paragraph">
<p>Compare the behavior of htmx&#8217;s <code>hx-boost</code> attribute with a JavaScript heavy Single Page Application: such an application
often won&#8217;t function <em>at all</em> without JavaScript enabled. It is often very difficult to adopt a progressive enhancement
approach when you adopt an SPA framework.</p>
</div>
<div class="paragraph">
<p>This is <em>not</em> to say that every htmx feature offers progressive enhancement.  It is certainly possible to build features that
do not offer a &#8220;No JS&#8221; fallback in htmx, and, in fact, many of the features we will build later in the book will fall
into this category.  We will note when a feature is progressive enhancement friendly and when it is not.</p>
</div>
<div class="paragraph">
<p>Ultimately, it is up to you, the developer, to decide if the trade-offs of progressive enhancement (a more basic UX,
limited improvements over plain HTML) are worth the benefits for your application users.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_hx_boost_to_contact_app">Adding <code>hx-boost</code> to Contact.app</h4>
<div class="paragraph">
<p>For the contact app we are building, we want this htmx &#8220;boost&#8221; behavior&#8230;&#8203; well, everywhere.</p>
</div>
<div class="paragraph">
<p>Right?  Why not?</p>
</div>
<div class="paragraph">
<p>How could we accomplish that?</p>
</div>
<div class="paragraph">
<p>Well, it&#8217;s pretty darned easy (and pretty common in htmx-powered web applications): we can just add <code>hx-boost</code> on the
<code>body</code> tag of our <code>layout.html</code> template, and we are done.</p>
</div>
<div class="listingblock">
<div class="title">Boosting The Entire Contact.app</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
...
&lt;body hx-boost="true"&gt;<b class="conum">(1)</b>
...
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>All links and forms will be boosted now!</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now every link and form in our application will use AJAX by default, making it feel much snappier.  Consider the
&#8220;New Contact&#8221; link that we created on the main page:</p>
</div>
<div class="listingblock">
<div class="title">A Newly Boosted &#8220;Add Contact&#8221; Link</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;a href="/contacts/new"&gt;Add Contact&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though we haven&#8217;t touched anything on this link or on the server-side handling of the URL it targets, it will
now &#8220;just work&#8221; as a boosted link, using AJAX for a snappier user experience, including updating history, back button
support and so on.  And, if JavaScript isn&#8217;t enabled, it will fall back to the normal link behavior.</p>
</div>
<div class="paragraph">
<p>All this with one, single htmx attribute.</p>
</div>
<div class="paragraph">
<p><code>hx-boost</code> is more &#8220;magic&#8221; than other attributes in htmx, which generally are lower level and require a bit more explicit
annotation work, in order to specify exactly what you want htmx to do.  In general, this is the design philosophy of htmx:
prefer explicit to implicit and obvious to &#8220;magic&#8221;.  However, the <code>hx-boost</code> attribute is too useful to allow dogma to
override practicality, and so it is included as a feature in the library.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_second_step_deleting_contacts_with_an_http_delete">6.3. A Second Step: Deleting Contacts With an HTTP DELETE</h3>
<div class="paragraph">
<p>For our next step with htmx, recall that Contact.app has a small form on the edit page of a contact that is
used to delete the contact:</p>
</div>
<div class="listingblock">
<div class="title">Plain HTML Form To Delete A Contact</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;form action="/contacts/{{ contact.id }}/delete" method="post"&gt;
        &lt;button&gt;Delete Contact&lt;/button&gt;
    &lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form issued an HTTP <code>POST</code> to, for example, <code>/contacts/42/delete</code>, in order to delete the contact with the ID 42.</p>
</div>
<div class="paragraph">
<p>We mentioned previously that one of the annoying things about HTML is that you can&#8217;t issue an HTTP <code>DELETE</code>
(or <code>PUT</code> or <code>PATCH</code>) request directly, even though these are all part of HTTP and HTTP is <em>obviously designed</em> for
transferring HTML.</p>
</div>
<div class="paragraph">
<p>Thankfully, now, with htmx, we have a chance to rectify this situation.</p>
</div>
<div class="paragraph">
<p>The &#8220;right thing&#8221;, from a RESTful, resource oriented perspective is, rather than issuing an HTTP <code>POST</code> to
<code>/contacts/42/delete</code>, to issue an HTTP <code>DELETE</code> to <code>/contacts/42</code>.  We want to delete the contact.  The contact is
a resource.  The URL for that resource is <code>/contacts/42</code>.  So the ideal is a <code>DELETE</code> request to <code>/contacts/42/</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s update our application to do this by adding the htmx <code>hx-delete</code> attribute to the &#8220;Delete Contact&#8221; button:</p>
</div>
<div class="listingblock">
<div class="title">An htmx Powered Button For Deleting A Contact</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;button hx-delete="/contacts/{{ contact.id }}"&gt;Delete Contact&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, when a user clicks this button, htmx will issue an HTTP <code>DELETE</code> request via AJAX to the URL for the contact
in question.</p>
</div>
<div class="paragraph">
<p>A couple of things to notice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We no longer need a <code>form</code> tag to wrap the button, because the button itself carries the hypermedia action that
it performs directly on itself.</p>
</li>
<li>
<p>We no longer need to use the somewhat awkward <code>"/contacts/{{ contact.id }}/delete"</code> route, but can simply use the
<code>"/contacts/{{ contact.id }}</code> route, since we are issuing a <code>DELETE</code>.  By using a <code>DELETE</code> we disambiguate between
a request intended to update the contact and a request intended to delete it, using the native HTTP tools available
for exactly this reason.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that we have done something pretty magical here: we have turned this button into a <em>hypermedia control</em>.  It is no
longer necessary that this button be placed within a larger <code>form</code> tag in order to trigger an HTTP request: it is a
stand-alone, and fully featured hypermedia control on its own.  This is the crux of htmx, allowing any element to become
a hypermedia control and fully participate in the Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>We should note that, unlike with the <code>hx-boost</code> examples above, this solution will <em>not</em> degrade gracefully.  To make
this solution degrade gracefully, we would need to wrap the button in a form element and handle a <code>POST</code> on the server
side as well.</p>
</div>
<div class="paragraph">
<p>In the interest of keeping our application simple, we are going to omit that more elaborate solution.</p>
</div>
<div class="sect3">
<h4 id="_updating_the_server_side">Updating The Server Side</h4>
<div class="paragraph">
<p>We have updated the client-side code (if HTML can be considered code) so it now issues a <code>DELETE</code> request to the appropriate
URL, but we still have some work to do.  Since we updated both the route and the HTTP method we are using, we are going to
need to update the server-side implementation as well to handle this new HTTP Request.</p>
</div>
<div class="paragraph">
<p>Here is the original code for deleting a contact on the server side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;/delete", methods=["POST"])
def contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete()
    flash("Deleted Contact!")
    return redirect("/contacts")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are going to have to make two changes to our handler: first we need to update the route for our handler to the new
location and then, secondly, we need to update the HTTP method we are using to delete contacts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;", methods=["DELETE"]) <b class="conum">(1)</b>
def contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete()
    flash("Deleted Contact!")
    return redirect("/contacts")</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An update path and method for the handler</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Pretty simple, and much cleaner.</p>
</div>
<div class="sect4">
<h5 id="_a_response_code_gotcha">A Response Code Gotcha</h5>
<div class="paragraph">
<p>Unfortunately, there is a problem with our updated handler: by default, in Flask the <code>redirect()</code> method responds with
a <code>302 Found</code> HTTP Response Code.</p>
</div>
<div class="paragraph">
<p>According to the Mozilla Developer Network (MDN) web docs on the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302"><code>302 Found</code></a>
response, this means that the HTTP <em>method</em> of the request <em>will be unchanged</em> when the redirected HTTP request is issued.</p>
</div>
<div class="paragraph">
<p>We are now issuing a <code>DELETE</code> request with htmx and then being redirected to the <code>/contacts</code> path by flask.  According to this
logic, that would mean that the redirected HTTP request would still be a <code>DELETE</code> method.  This means that, as it stands,
the browser will issue a <code>DELETE</code> request to <code>/contacts</code>.</p>
</div>
<div class="paragraph">
<p>This is definitely <em>not</em> what we want: we would like the HTTP redirect to issue a <code>GET</code> request, slightly modifying the
Post/Redirect/Get behavior we discussed earlier to be a Delete/Redirect/Get.</p>
</div>
<div class="paragraph">
<p>Fortunately, there is a different response code, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303"><code>303 See Other</code></a>,
that does what we want: when a browser receives a <code>303 See Other</code> redirect response, it will issue a <code>GET</code> to the new
location.</p>
</div>
<div class="paragraph">
<p>So we want to update our code to use the <code>303</code> response code in controller.</p>
</div>
<div class="paragraph">
<p>Thankfully, this is very easy: there is a second parameter to <code>redirect()</code> that takes the numeric response code you wish
to send.</p>
</div>
<div class="paragraph">
<p>Here is the updated code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;", methods=["DELETE"]) <b class="conum">(1)</b>
def contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete()
    flash("Deleted Contact!")
    return redirect("/contacts", 303) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A slightly different path and method for the handler</p>
</li>
<li>
<p>The response code is now a 303</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when you want to remove a given contact, you can simply issue a <code>DELETE</code> to the same URL as you used to access the
contact in the first place.</p>
</div>
<div class="paragraph">
<p>This is a much more natural HTTP-based approach to deleting a resource!</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_targeting_the_right_element">Targeting The Right Element</h4>
<div class="paragraph">
<p>We aren&#8217;t quite finished with our updated delete button yet, however.  Recall that, by default, htmx &#8220;targets&#8221; the element
that triggers a request, and will place the HTML returned by the server inside that element.  Right now, the &#8220;Delete Contact&#8221;
button is targeting itself.</p>
</div>
<div class="paragraph">
<p>That means that, since the redirect to the <code>/contacts</code> URL is going to re-render the entire contact list, we will end up
with that contact list placed <em>inside</em> the &#8220;Delete Contact&#8221; button.</p>
</div>
<div class="paragraph">
<p>Mis-targeting like this comes up from time to time when you are working with htmx and can lead to some pretty funny situations.</p>
</div>
<div class="paragraph">
<p>The fix for this is easy: add an explicit target to the button, and target the <code>body</code> element with the response:</p>
</div>
<div class="listingblock">
<div class="title">A fixed htmx Powered Button For Deleting A Contact</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;button hx-delete="/contacts/{{ contact.id }}"
          hx-target="body"&gt; <b class="conum">(1)</b>
    Delete Contact
  &lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We have added an explicit target to the button now</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now our button behaves as expected: clicking on the button will issue an HTTP <code>DELETE</code> to the server against the URL for
the current contact, delete the contact and redirect back to the contact list page, with a nice flash message.  We&#8217;ve
got everything working smoothly now.</p>
</div>
</div>
<div class="sect3">
<h4 id="_updating_the_location_bar_url_properly">Updating The Location Bar URL Properly</h4>
<div class="paragraph">
<p>Well, almost.</p>
</div>
<div class="paragraph">
<p>If you click on the button you will notice that, despite the redirect, the URL in the location bar is
not correct.  It still points to <code>/contacts/{{ contact.id }}</code>.  That&#8217;s because we haven&#8217;t told htmx to update
the URL: it just issues the <code>DELETE</code> request and then updates the DOM with the response.</p>
</div>
<div class="paragraph">
<p>As we mentioned, boosting will naturally update the location bar for you, mimicking normal anchors and forms, but in
this case we are building a custom button hypermedia control because we want to issue a <code>DELETE</code>.  So, in this case, we
need to let htmx know that we want the resulting URL from this request &#8220;pushed&#8221; into the location bar.</p>
</div>
<div class="paragraph">
<p>We can achieve this by adding the <code>hx-push-url</code> attribute with the value <code>true</code> to our button:</p>
</div>
<div class="listingblock">
<div class="title">Deleting A Contact, Now With Proper Location Information</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;button hx-delete="/contacts/{{ contact.id }}"
          hx-push-url="true" <b class="conum">(1)</b>
          hx-target="body"&gt;
    Delete Contact
  &lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We tell htmx to push the redirected URL up into the location bar</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>Now</em> we are done.</p>
</div>
<div class="paragraph">
<p>We have a button that, all by itself, is able to issue a properly formatted HTTP <code>DELETE</code> request to
the correct URL, and the UI and location bar are all updated correctly.  This was accomplished with three declarative
attributes placed directly on the button <code>hx-delete</code>, <code>hx-target</code> and <code>hx-push-url</code>.</p>
</div>
<div class="paragraph">
<p>This is definitely more work than the <code>hx-boost</code> change was, but it is explicit and easy to see what the button is doing
as a custom hypermedia control.  And the resulting solution feels a lot cleaner as a total solution, taking advantage of
the built-in features of the web as a hypermedia system without any URL hacks.</p>
</div>
</div>
<div class="sect3">
<h4 id="_one_more_thing">One More Thing&#8230;&#8203;</h4>
<div class="paragraph">
<p>There is one additional &#8220;bonus&#8221; feature we can add to our &#8220;Delete Contact&#8221; button: a confirmation dialog.  Deleting
a contact is a destructive operation and as it stands right now, if the user inadvertently clicked the &#8220;Delete Contact&#8221;
button, the application would just delete that contact.  Too bad, so sad for the user.</p>
</div>
<div class="paragraph">
<p>Fortunately htmx has an easy mechanism for adding a confirmation message on destructive operations like this: the
<code>hx-confirm</code> attribute.  You can place this attribute on an element, with a message as its value, and the JavaScript
method <code>confirm()</code> will be called before a request is issued, which will show a simple confirmation dialog to the user
asking them to confirm the action. Very easy and a great way to prevent accidents.</p>
</div>
<div class="paragraph">
<p>Here is how we would add confirmation of the contact delete operation:</p>
</div>
<div class="listingblock">
<div class="title">Confirming Deletion</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;button hx-delete="/contacts/{{ contact.id }}"
          hx-push-url="true"
          hx-confirm="Are you sure you want to delete this contact?" <b class="conum">(1)</b>
          hx-target="body"&gt;
    Delete Contact
  &lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This message will be shown to the user, asking them to confirm the delete</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when someone clicks on the &#8220;Delete Contact&#8221; button, they will be presented with a prompt that asks &#8220;Are you sure
you want to delete this contact?&#8221; and they will have an opportunity to cancel if they clicked the button in error.  Very
nice.</p>
</div>
<div class="paragraph">
<p>With this final change we now have a pretty solid &#8220;delete contact&#8221; mechanism: we are using the correct RESTful routes
and HTTP Methods, we are confirming the deletion, and we have removed a lot of the cruft that normal HTML imposes on us,
all while using declarative attributes in our HTML and staying firmly within the normal hypermedia model of the web.</p>
</div>
</div>
<div class="sect3">
<h4 id="_progressive_enhancement_2">Progressive Enhancement?</h4>
<div class="paragraph">
<p>One thing to note about this solution, however, is that it is <em>not</em> a progressive enhancement to our web application: if
someone has disabled JavaScript then this &#8220;Delete Contact&#8221; button will no longer work.  We could do additional work to keep
the older mechanism working in a JavaScript-disabled environment.</p>
</div>
<div class="paragraph">
<p>Progressive Enhancement can be a hot-button topic in web development, with lots of passionate opinions and perspectives.
Like nearly all JavaScript libraries, htmx makes it possible to create applications that do not function in the absence of
JavaScript. Retaining support for non-JavaScript clients requires additional work and complexity in your application.  It
is important to determine exactly how important supporting non-JavaScript clients is before you begin using htmx, or any
other JavaScript framework, for improving your web applications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_next_steps_validating_contact_emails">6.4. Next Steps: Validating Contact Emails</h3>
<div class="paragraph">
<p>Let&#8217;s move on to another improvement in our application: a big part of any web app is validating the data that is
submitted to the server: ensuring emails are correctly formatted and unique, numeric values are valid, dates are
acceptable, and so forth.</p>
</div>
<div class="paragraph">
<p>Currently, our application has a small amount of validation that is done entirely server-side and that displays an error
message when an error is detected.</p>
</div>
<div class="paragraph">
<p>We are not going to go into the details of how validation works in the model objects, but recall what
the code for updating a contact looks like from Chapter 4:</p>
</div>
<div class="listingblock">
<div class="title">Server Side Validation On Contact Update</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def contacts_edit_post(contact_id=0):
    c = Contact.find(contact_id)
    c.update(request.form['first_name'], request.form['last_name'], request.form['phone'], request.form['email'])
    if c.save(): <b class="conum">(1)</b>
        flash("Updated Contact!")
        return redirect("/contacts/" + str(contact_id))
    else:
        return render_template("edit.html", contact=c) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We attempt to save the contact</p>
</li>
<li>
<p>If the save does not succeed we re-render the form to display error messages</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So we attempt to save the contact, and, if the <code>save()</code> method returns true, we redirect to the contact&#8217;s detail page.
If the <code>save()</code> method does not return true, that indicates that there was a validation error and so, instead of redirecting
we re-render the HTML for editing the contact.  This gives the user a chance to correct the errors, which are displayed
alongside the inputs.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the HTML for the email input:</p>
</div>
<div class="listingblock">
<div class="title">Validation Error Messages</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="text" placeholder="Email" value="{{ contact.email }}"&gt;
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;<b class="conum">(1)</b>
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Display any errors associated with the email field</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have a label for the input, an input of type <code>text</code> and then a bit of HTML to display any error messages associated
with the email.  When the template is rendered on the server, if there are errors associated with the contact&#8217;s email, they will
be displayed in this span, which will be highlighted red.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Server Side Validation Logic</div>
        <div class="paragraph">
<p>Right now there is a bit of logic in the contact class that checks if there are any other contacts with
the same email address, and adds an error to the contact model if so, since we do not want to have duplicate emails in the
database.  This is a very common validation example: emails are usually unique and adding two contacts with the same email
is almost certainly a user error.</p>
</div>
<div class="paragraph">
<p>Again, we are not going to go into the details of how validation works in our models, in the interest of staying focused
on hypermedia, but whatever server-side framework you are using almost certainly has some sort of infrastructure available
for validating data and collecting errors to display to the user.  This sort of infrastructure is very common in
Web 1.0 server-side frameworks.</p>
</div>
    </aside>
<div class="paragraph">
<p>The error message shown when a user attempts to save a contact with a duplicate email is "Email Must Be Unique":</p>
</div>
<div id="figure-4-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_validation_error.png" alt="screenshot validation error">
</div>
<div class="title">Figure 3. Email Validation Error</div>
</div>
<div class="paragraph">
<p>All of this is done using plain HTML and using Web 1.0 techniques, and it works well.</p>
</div>
<div class="paragraph">
<p>However, as the application currently stands, there are two annoyances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, there is no email format validation: you can enter whatever characters you&#8217;d like as an email and,
as long as they are unique, the system will allow it</p>
</li>
<li>
<p>Second, if a user has entered a duplicate email, they will not find this fact out until they have filled in
all the fields because we only check the email&#8217;s uniqueness when all the data is submitted.  This could be
quite annoying if the user was accidentally reentering a contact and had to put all the contact information in
before being made aware of this fact.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_updating_our_input_type">Updating Our Input Type</h4>
<div class="paragraph">
<p>For the first issue, we have a pure HTML mechanism for improving our application: HTML 5 supports inputs of
type <code>email</code>.  All we need to do is switch our input from type <code>text</code> to type <code>email</code>, and the browser will
enforce that the value entered properly matches the email format:</p>
</div>
<div class="listingblock">
<div class="title">Changing The Input To Type <code>email</code></div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email" placeholder="Email" value="{{ contact.email }}"&gt; <b class="conum">(1)</b>
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A simple change of the <code>type</code> attribute to <code>email</code> ensures that values entered are valid emails</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this change, when the user enters a value that isn&#8217;t a valid email, the browser will display an
error message asking for a properly formed email in that field.</p>
</div>
<div class="paragraph">
<p>So a simple single-attribute change done in pure HTML improves our validation and addresses the first problem
we noted.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Server Side vs. Client Side Validations</div>
        <div class="paragraph">
<p>More experienced web developers might be grinding their teeth a bit at the code above: this validation
is done on <em>the client side</em>.  That is, we are relying on the browser to detect the malformed
email and correct the user.  Unfortunately, the client side is not trustworthy: a browser may have a
bug in it that allows the user to circumvent this validation code.  Or, worse, the user may be malicious
and figure out a mechanism around our validation entirely, such as using the developer console to edit the HTML.</p>
</div>
<div class="paragraph">
<p>This is a perpetual danger in web development: all validations done on the client side cannot be trusted
and, if the validation is important, <em>must be redone</em> on the server side.  This is less of a problem in
Hypermedia-Driven Applications than in Single Page Applications, because the focus of HDAs is the server
side, but it is worth bearing in mind as you build your application.</p>
</div>
    </aside>
</div>
<div class="sect3">
<h4 id="_inline_validation">Inline Validation</h4>
<div class="paragraph">
<p>While we have improved our validation experience a bit, the user must still submit the form to get any feedback
on duplicate emails.  We can next use htmx to improve this user experience.</p>
</div>
<div class="paragraph">
<p>It would be better if the user were able to see a duplicate email error immediately after entering the email value.  It
turns out that inputs fire a <code>change</code> event and, in fact, the <code>change</code> event is the <em>default trigger</em> for inputs in htmx.
So, putting this feature to work, we can implement the following behavior: when the user enters an email, immediately
issue a request to the server and validate that email, and render an error message if necessary.</p>
</div>
<div class="paragraph">
<p>Recall the current HTML for our email input:</p>
</div>
<div class="listingblock">
<div class="title">The Initial Email Configuration</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email" placeholder="Email" value="{{ contact.email }}"&gt; <b class="conum">(1)</b>
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt; <b class="conum">(2)</b>
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is the input that we want to have drive an HTTP request to validate the email</p>
</li>
<li>
<p>This is the span we want to put the error message, if any, into</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So we want to add an <code>hx-get</code> attribute to this input.  This will cause the input to issue an HTTP <code>GET</code> request to a
given URL to validate the email.  We then want to target the error span following the input with any error message
returned from the server.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s make those changes to our HTML:</p>
</div>
<div class="listingblock">
<div class="title">Our Updated HTML</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email"
           hx-get="/contacts/{{ contact.id }}/email" <b class="conum">(1)</b>
           hx-target="next .error" <b class="conum">(2)</b>
           placeholder="Email" value="{{ contact.email }}"&gt; <b class="conum">(1)</b>
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue an HTTP <code>GET</code> to the <code>email</code> endpoint for the contact</p>
</li>
<li>
<p>Target the next element with the class <code>error</code> on it</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that in the <code>hx-target</code> attribute we are using a <em>relative positional</em> selector.  This is a feature of htmx and
an extension to normal CSS.  htmx supports prefixes that will find targets <em>relative</em> to the current element.  Here
is a table of relative positional expressions available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>next</code></dt>
<dd>
<p>Scan forward in the DOM for the next matching element, e.g. <code>next .error</code></p>
</dd>
<dt class="hdlist1"><code>previous</code></dt>
<dd>
<p>Scan backwards in the DOM for the closest previous matching element, e.g. <code>previous .alert</code></p>
</dd>
<dt class="hdlist1"><code>closest</code></dt>
<dd>
<p>Scan the parents of this element for matching element, e.g. <code>closest table</code></p>
</dd>
<dt class="hdlist1"><code>find</code></dt>
<dd>
<p>Scan the children of this element for matching element, e.g. <code>find span</code></p>
</dd>
<dt class="hdlist1"><code>this</code></dt>
<dd>
<p>the current element is the target (default)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>By using relative positional expressions we can avoid adding explicit ids to elements and take advantage of the local
structure of HTML.</p>
</div>
<div class="paragraph">
<p>So, with these two attributes in place, whenever someone changes the value of the input (remember, <code>change</code> is the
<em>default</em> trigger for inputs in htmx) an HTTP <code>GET</code> request will be issued to the given URL and, if there are any errors, they
will be loaded into the error span.</p>
</div>
</div>
<div class="sect3">
<h4 id="_validating_emails_server_side">Validating Emails Server Side</h4>
<div class="paragraph">
<p>Next, let&#8217;s look at the server-side implementation.  We are going to add another end point, similar to our edit
end point in some ways: it is going to look up the contact based on the ID encoded in the URL.  In this case, however,
we only want to update the email of the contact, and we obviously don&#8217;t want to save it!  Instead, we will call the
<code>validate()</code> method on it.</p>
</div>
<div class="paragraph">
<p>That method will validate the email is unique and so forth.  At that point we can return any errors associated with the
email directly, or the empty string if none exist.</p>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="listingblock">
<div class="title">Our Email Validation End-Point</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;/email", methods=["GET"])
def contacts_email_get(contact_id=0):
    c = Contact.find(contact_id) <b class="conum">(1)</b>
    c.email = request.args.get('email') <b class="conum">(2)</b>
    c.validate() <b class="conum">(3)</b>
    return c.errors.get('email') or "" <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Look up the contact by id</p>
</li>
<li>
<p>Update its email (note that since this is a <code>GET</code>, we use the <code>args</code> property rather than the <code>form</code> property)</p>
</li>
<li>
<p>Validate the contact</p>
</li>
<li>
<p>Return a string, either the errors associated with the email field or, if there are none, the empty string</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this small bit of server-side code in place, we now have the following user experience: when a user enters an email
and tabs to the next input field, they are immediately notified if the email is already taken.</p>
</div>
<div class="paragraph">
<p>Note that the email validation is <em>still</em> done when the entire contact is submitted for an update, so there is no danger
of allowing duplicate email contacts to slip through: we have simply made it possible for users to catch this situation
earlier by use of htmx.</p>
</div>
<div class="paragraph">
<p>It is also worth noting that this particular email validation <em>must</em> be done on the server side: you cannot
determine that an email is unique across all contacts unless you have access to the data store of record.  This is another
simplifying aspect of Hypermedia-Driven Applications: since validations are done server-side, you have access to all
the data you might need to do any sort of validation you&#8217;d like.</p>
</div>
<div class="paragraph">
<p>Here again we want to stress that this interaction is done entirely within the hypermedia model: we are using declarative
attributes and exchanging hypermedia with the server in a manner very similar to how links or forms work, but we have managed
to improve our user experience dramatically.</p>
</div>
</div>
<div class="sect3">
<h4 id="_taking_the_user_experience_further">Taking The User Experience Further</h4>
<div class="paragraph">
<p>Despite the fact that we haven&#8217;t added a lot of code here, we have a fairly sophisticated user interface, at
least when compared with plain HTML-based applications.  However, if you have used more advanced Single Page Applications
you have probably seen the pattern where an email field (or a similar sort of input) is validated <em>as you type</em>.</p>
</div>
<div class="paragraph">
<p>This seems like the sort of interactivity that is only possible with a sophisticated, complex JavaScript framework, right?</p>
</div>
<div class="paragraph">
<p>Well, no.</p>
</div>
<div class="paragraph">
<p>It turns out that you can implement this functionality in htmx, using pure HTML attributes.</p>
</div>
<div class="paragraph">
<p>In fact, all we need to do is to change our trigger.  Currently, we are using the default trigger for inputs, which is the
<code>change</code> event.  To validate as the user types, we would want to capture the <code>keyup</code> event as well:</p>
</div>
<div class="listingblock">
<div class="title">Triggering With <code>keyup</code> Events</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email"
           hx-get="/contacts/{{ contact.id }}/email"
           hx-target="next .error"
           hx-trigger="change, keyup" <b class="conum">(1)</b>
           placeholder="Email" value="{{ contact.email }}"&gt;
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An explicit trigger has been declared, and it triggers on both the <code>change</code> and <code>keyup</code> events</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this tiny change, every time a user types a character we will issue a request and validate the email.  Simple as.</p>
</div>
</div>
<div class="sect3">
<h4 id="_debouncing_our_validation_requests">Debouncing Our Validation Requests</h4>
<div class="paragraph">
<p>Simple as, yes, but probably not what we want: issuing a new request on every key up event would be very wasteful
and could potentially overwhelm your server.  What we want instead is only issue the request if the user has paused for
a small amount of time.  This is called &#8220;debouncing&#8221; the input, where requests are delayed until things have &#8220;settled down&#8221;.</p>
</div>
<div class="paragraph">
<p>htmx supports a <code>delay</code> modifier for triggers that allows you to debounce a request by adding a delay before the request
is sent. If another event of the same kind appears within that interval, htmx will not issue the request and will reset
the timer.</p>
</div>
<div class="paragraph">
<p>This turns out to be exactly what we want for our email input: if the user is busy typing in an email we won&#8217;t interrupt them,
but as soon as they pause or leave the field, we&#8217;ll issue a request.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add a delay of 200 milliseconds to the <code>keyup</code> trigger, which is long enough to detect that the user has stopped
typing.:</p>
</div>
<div class="listingblock">
<div class="title">Debouncing the <code>keyup</code> Event</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email"
           hx-get="/contacts/{{ contact.id }}/email"
           hx-target="next .error"
           hx-trigger="change, keyup delay:200ms" <b class="conum">(1)</b>
           placeholder="Email" value="{{ contact.email }}"&gt;
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We debounce the <code>keyup</code> event by adding a <code>delay</code> modifier</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now we no longer issue a stream of validation requests as the user types.  Instead, we wait until the user pauses for
a bit and then issue the request.  Much better for our server, and still a great user experience.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ignoring_non_mutating_keys">Ignoring Non-Mutating Keys</h4>
<div class="paragraph">
<p>There is one last issue we should address with the keyup event: as it stands we will issue a request no matter <em>which</em> keys
are pressed, even if they are keys that have no effect on the value of the input, such as arrow keys.  It would be better
if there were a way to only issue a request if the input value has changed.</p>
</div>
<div class="paragraph">
<p>And it turns out that htmx has support for that exact pattern, by using the <code>changed</code> modifier for events.  (Not to be
confused with the <code>change</code> event triggered by the DOM on input elements.)</p>
</div>
<div class="paragraph">
<p>By adding <code>changed</code> to our <code>keyup</code> trigger, the input will not issue validation requests unless the keyup event actually
updates the inputs value:</p>
</div>
<div class="listingblock">
<div class="title">Only Sending Requests When The Input Value Changes</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input name="email" id="email" type="email"
           hx-get="/contacts/{{ contact.id }}/email"
           hx-target="next .error"
           hx-trigger="change, keyup delay:200ms changed" <b class="conum">(1)</b>
           placeholder="Email" value="{{ contact.email }}"&gt;
    &lt;span class="error"&gt;{{ contact.errors['email'] }}&lt;/span&gt;
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We do away with pointless requests by only issuing them when the input&#8217;s value has actually changed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That&#8217;s some pretty good-looking and powerful HTML, providing an experience that most developers would think requires
a complicated client-side solution.</p>
</div>
<div class="paragraph">
<p>With a total of three attributes and a simple new server-side end point, we have added a fairly sophisticated user
experience to our web application.   Even better, any email validation rules we add on the server side will
<em>automatically</em> just work using this model: because we are using hypermedia as our communication mechanism there is no
need to keep a client-side and server-side model in sync with one another.</p>
</div>
<div class="paragraph">
<p>A great demonstration of the power of the hypermedia architecture.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_another_application_improvement_paging">6.5. Another Application Improvement: Paging</h3>
<div class="paragraph">
<p>Let&#8217;s move on from the contact editing page for a bit and improve the root page of the application, found
at the <code>/contacts</code> path and rendering the <code>index.html</code> template.</p>
</div>
<div class="paragraph">
<p>Currently, Contact.app does not support paging: if there are 10,000 contacts in the database we will show
all 10,000 contacts on the root page.  Showing so much data can bog a browser (and a server) down, so most web applications
adopt a concept of &#8220;paging&#8221; to deal with data sets this large, where only one &#8220;page&#8221; of a smaller number of items is
shown, with the ability to navigate around the pages in the data set.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s fix our application, so that we only show ten contacts at a time with a &#8220;Next&#8221; and &#8220;Previous&#8221; link if there are more
than 10 contacts in the contact database.</p>
</div>
<div class="paragraph">
<p>The first change we will need to make is to add a simple paging widget to our <code>index.html</code> template.</p>
</div>
<div class="paragraph">
<p>We will conditionally include two links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If we are beyond the &#8220;first&#8221; page, we will include a link to the previous page</p>
</li>
<li>
<p>If there are ten contacts in the current result set, we will include a link to the next page</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This isn&#8217;t a perfect paging widget: ideally we&#8217;d show the number of pages and offer the ability to do more
specific page navigation, and there is the possibility that the next page might have 0 results in it since
we aren&#8217;t checking the total results count, but it will do for now for our simple application.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the jinja template code for this in <code>index.html</code></p>
</div>
<div class="listingblock">
<div class="title">Adding Paging Widgets To Our List of Contacts</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div&gt;
    &lt;span style="float: right"&gt; <b class="conum">(1)</b>
        {% if page &gt; 1 %}
          &lt;a href="/contacts?page={{ page - 1 }}"&gt;Previous&lt;/a&gt; <b class="conum">(2)</b>
        {% endif %}
        {% if contacts|length == 10 %}
          &lt;a href="/contacts?page={{ page + 1 }}"&gt;Next&lt;/a&gt; <b class="conum">(3)</b>
        {% endif %}
    &lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Include a new div under the table to hold our navigation links</p>
</li>
<li>
<p>If we are beyond page 1, include an anchor tag with the page decremented by one</p>
</li>
<li>
<p>If there are 10 contacts in the current page, include an anchor tag linking to the next page by incrementing it by one</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that here we are using a special jinja filter syntax <code>contacts|length</code> to compute the length of the contacts
list.  The details of this filter syntax is beyond the scope of this book, but in this case you can think of it as
invoking the <code>contacts.length</code> property and then comparing that with <code>10</code>.</p>
</div>
<div class="paragraph">
<p>Now that we have these links in place to support paging, let&#8217;s address the server-side implementation of paging.</p>
</div>
<div class="paragraph">
<p>We are using the <code>page</code> request parameter to encode the paging state of the UI.  So, in our handler, we need to look for
that <code>page</code> parameter and pass that through to our model, as an integer, so the model knows which page of contacts to return:</p>
</div>
<div class="listingblock">
<div class="title">Adding Paging To Our Request Handler</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    page = int(request.args.get("page", 1)) <b class="conum">(1)</b>
    if search is not None:
        contacts_set = Contact.search(search)
    else:
        contacts_set = Contact.all(page) <b class="conum">(2)</b>
    return render_template("index.html", contacts=contacts_set, page=page)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Resolve the page parameter, defaulting to page 1 if no page is passed in</p>
</li>
<li>
<p>Pass the page through to the model when loading all contacts so it knows which page of 10 contacts to
return</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is fairly straightforward: we just need to get another parameter, like the <code>q</code> parameter we passed in for
searching contacts earlier, convert it to an integer and then pass it through to the <code>Contact</code> model, so it
knows which page to return.</p>
</div>
<div class="paragraph">
<p>And, with that small change, we are done: we now have a very basic paging mechanism for our web application.</p>
</div>
<div class="paragraph">
<p>And, believe it or not, it is already using AJAX, thanks to our use of <code>hx-boost</code> in the application.  Easy.</p>
</div>
<div class="sect3">
<h4 id="_click_to_load">Click To Load</h4>
<div class="paragraph">
<p>This paging mechanism is fine for a basic web application, and it is used extensively on the internet.  But it has some
drawbacks associated with it: every time you click the &#8220;Next&#8221; or &#8220;Previous&#8221; buttons you get a whole new page of contacts
and lose any context you had on the previous page.</p>
</div>
<div class="paragraph">
<p>Sometimes a more advanced paging UI pattern might be better.  Maybe, rather than loading in a new page of elements and
replacing the current elements, it would be nicer to append the next page of elements <em>inline</em>, after the current
elements.</p>
</div>
<div class="paragraph">
<p>This is the common &#8220;click to load&#8221; UX pattern, found in more advanced web applications.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_click_to_load.txt.svg" alt="screenshot click to load.txt">
</div>
<div class="title">Figure 4. A Click To Load UI</div>
</div>
<div class="paragraph">
<p>Here, you have a button that you can click, and it will load the next set of contacts directly into the page, rather
than &#8220;paging&#8221; to the next page.  This allows you to keep the current contacts &#8220;in context&#8221; visually on the page, but
still progress through them as you would in a normal, paged user interface.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how we can implement this UX pattern in htmx.</p>
</div>
<div class="paragraph">
<p>It&#8217;s actually surprisingly simple: we can just take the existing &#8220;Next&#8221; link and repurpose it a bit using
nothing but a few htmx attributes!</p>
</div>
<div class="paragraph">
<p>We want to have a button that, when clicked, appends the rows from the next page of contacts to the current,
exiting table, rather than re-rendering the whole table.  This can be achieved by adding a new row to our table
that has just such a button in it:</p>
</div>
<div class="listingblock">
<div class="title">Changing To &#8220;Click To Load&#8221;</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">        &lt;tbody&gt;
        {% for contact in contacts %}
            &lt;tr&gt;
                &lt;td&gt;{{ contact.first }}&lt;/td&gt;
                &lt;td&gt;{{ contact.last }}&lt;/td&gt;
                &lt;td&gt;{{ contact.phone }}&lt;/td&gt;
                &lt;td&gt;{{ contact.email }}&lt;/td&gt;
                &lt;td&gt;&lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt; &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        {% endfor %}
        {% if contacts|length == 10 %} <b class="conum">(1)</b>
            &lt;tr&gt;
                &lt;td colspan="5" style="text-align: center"&gt;
                    &lt;button hx-target="closest tr" <b class="conum">(2)</b>
                            hx-swap="outerHTML"   <b class="conum">(3)</b>
                            hx-select="tbody &gt; tr" <b class="conum">(4)</b>
                            hx-get="/contacts?page={{ page + 1 }}"&gt;
                      Load More
                    &lt;/button&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        {% endif %}
        &lt;/tbody&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only show &#8220;Load More&#8221; if there are 10 contact results in the current page</p>
</li>
<li>
<p>Target the closest enclosing row</p>
</li>
<li>
<p>Replace the entire row with the response from the server</p>
</li>
<li>
<p>Select out the table rows from the response</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s go through each attribute in detail here.</p>
</div>
<div class="paragraph">
<p>First, we are using <code>hx-target</code> to target the &#8220;closest&#8221; <code>tr</code> element, that is, the closest <em>parent</em> table row.</p>
</div>
<div class="paragraph">
<p>Second, we want to replace this <em>entire</em> row with whatever content comes back from the server.</p>
</div>
<div class="paragraph">
<p>Third, we want to yank out only the <code>tr</code> elements in the response.  We are replacing this <code>tr</code> element with a new set
of <code>tr</code> elements, which will have additional contact information in them, as well as, if necessary, a new &#8220;Load More&#8221;
button that points to the <em>next</em> next page.  To do this, we use a CSS selector <code>tbody &gt; tr</code> to ensure we only pull
out the rows in the body of the table in the response.  This avoids including rows in the table header, for example.</p>
</div>
<div class="paragraph">
<p>Finally, we issue an HTTP <code>GET</code> to the url that will serve the next page of contacts, which looks just like the &#8220;Next&#8221;
link from above.</p>
</div>
<div class="paragraph">
<p>Somewhat surprisingly, no server-side changes are necessary for this new functionality.  This is because of the flexibility
that htmx gives you with respect to how it processes server responses.</p>
</div>
<div class="paragraph">
<p>So, four attributes, and we now have a sophisticated &#8220;Click To Load&#8221; UX, via htmx.</p>
</div>
</div>
<div class="sect3">
<h4 id="_infinite_scroll">Infinite Scroll</h4>
<div class="paragraph">
<p>Another common pattern for dealing with large sets of things is known as the &#8220;Infinite Scroll&#8221; pattern.  In this pattern,
as the last item of a list or table of elements is scrolled into view, more elements are loaded and appended to the list
or table.</p>
</div>
<div class="paragraph">
<p>Now, this behavior makes more sense in situations where a user is exploring a category or series of social media posts, rather
than in the context of a contact application.  However, for completeness, and to just show off what you can do with
htmx, we will show how to implement this pattern as well.</p>
</div>
<div class="paragraph">
<p>It turns out that we can repurpose the &#8220;Click To Load&#8221; code to implement this new pattern quite easily: if you think
about it for a moment, infinite scroll is really just the &#8220;Click To Load&#8221; logic, but rather than loading when a click
event occurs, we want to load when an element is &#8220;revealed&#8221; in the view portal of the browser.</p>
</div>
<div class="paragraph">
<p>As luck would have it, htmx offers a synthetic (non-standard) DOM event, <code>revealed</code> that can be used in tandem
with the <code>hx-trigger</code> attribute, to trigger a request when, well, when an element is revealed.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s convert our button to a span and take advantage of this event:</p>
</div>
<div class="listingblock">
<div class="title">Changing To &#8220;Infinite Scroll&#8221;</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{% if contacts|length == 10 %} <b class="conum">(1)</b>
    &lt;tr&gt;
        &lt;td colspan="5" style="text-align: center"&gt;
            &lt;span&lt;1&gt;hx-target="closest tr"
                    hx-trigger="revealed" <b class="conum">(2)</b>
                    hx-swap="outerHTML"
                    hx-select="tbody &gt; tr"
                    hx-get="/contacts?page={{ page + 1 }}"&gt;Loading More...&lt;/span&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
{% endif %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We have converted our element from a button to a span, since the user will not be clicking on it</p>
</li>
<li>
<p>We trigger the request when the element is revealed, that is when it comes into view in the portal</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All we needed to do to convert from &#8220;Click to Load&#8221; to &#8220;Infinite Scroll&#8221; was to update our element to be
a span and then add the <code>revealed</code> event trigger.</p>
</div>
<div class="paragraph">
<p>The fact that switching to infinite scroll was so easy shows how well htmx generalizes HTML: just a few attributes allow
us to dramatically expand what we can achieve in the hypermedia.</p>
</div>
<div class="paragraph">
<p>And, again, we note that we are doing all this within the original, RESTful model of the web: despite all this new
behavior, we are still exchanging hypermedia with the server, no JSON API response to be seen.</p>
</div>
<div class="paragraph">
<p>As the web was designed.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_htmx_patterns">7. More htmx Patterns</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_active_search">7.1. Active Search</h3>
<div class="paragraph">
<p>So far so good with Contact.app: we have a nice little web application with some significant improvements over a plain
HTML-based application. We&#8217;ve added a proper &#8220;Delete Contact&#8221; button, done some dynamic validation of input and looked
as some different approaches to add paging to the application.  As we have said, many web developers would expect that
we would have needed to add a lot of JavaScript-based scripting to get these features, but we&#8217;ve done it all in relatively
pure HTML, using only htmx attributes.</p>
</div>
<div class="paragraph">
<p>We <em>will</em> eventually add some client-side scripting to our application: hypermedia is powerful, but it isn&#8217;t <em>all powerful</em> and
sometimes scripting might be the best (or only) way to achieve a given goal.  For now, however, let&#8217;s see what we can accomplish
with hypermedia.</p>
</div>
<div class="paragraph">
<p>The first advanced htmx feature we will create is known as the &#8220;Active Search&#8221; pattern.  Active Search is when, as a
user types text into a search box, the results of that search are dynamically shown.  This pattern was made popular
when Google adopted it for search results, and many applications now implement it.</p>
</div>
<div class="paragraph">
<p>To implement Active Search, we are going to use techniques closely related to the way we did email validation in the
previous chapter.  If you think about it, the two features are similar in many ways: in both cases we want to issue
a request as the user types into an input and then update some other element with a response.  The server-side implementations
will, of course, be very different, but the front end code will look fairly similar, a testament to how general the &#8220;issue
a request on an event and replace something on the screen&#8221; approach that htmx takes really is.</p>
</div>
<div class="sect3">
<h4 id="_our_current_search_ui">Our Current Search UI</h4>
<div class="paragraph">
<p>Let&#8217;s recall what the current search field in our application currently looks like:</p>
</div>
<div class="listingblock">
<div class="title">Our Search Form</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/contacts" method="get" class="tool-bar"&gt;
    &lt;label for="search"&gt;Search Term&lt;/label&gt;
    &lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"/&gt; <b class="conum">(1)</b>
    &lt;input type="submit" value="Search"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>q</code> or &#8220;query&#8221; parameter our client-side code uses to search</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Recall that we have some server-side code that looks for the <code>q</code> parameter and, if it is present, searches the contacts
for that term.</p>
</div>
<div class="paragraph">
<p>As it stands right now, the user must hit enter when the search input is focused, or click the &#8220;Search&#8221; button.  Both
of these events will trigger a <code>submit</code> event on the form, causing it to issue an HTTP <code>GET</code> and re-rendering the whole
page.</p>
</div>
<div class="paragraph">
<p>Currently, thanks to <code>hx-boost</code>, the form will use an AJAX request for this <code>GET</code>, but we currently don&#8217;t get that nice
search-as-you-type behavior that we want.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_active_search">Adding Active Search</h4>
<div class="paragraph">
<p>To add active search behavior, we will need to add a few htmx attributes to the search input.  We will leave the current
form as it is, with an <code>action</code> and <code>method</code>, so that, in case a user does not have JavaScript enabled, the normal
search behavior continues to work.  This will make our &#8220;Active Search&#8221; improvement a nice &#8220;progressive enhancement&#8221;.</p>
</div>
<div class="paragraph">
<p>So, in addition to the regular form behavior, we <em>also</em> want to issue an HTTP <code>GET</code> request when a key up occurs.  We want
to issue this request to the same URL as the normal form submission.  Finally, we only want to do this after a small
pause in typing has occurred.</p>
</div>
<div class="paragraph">
<p>As we said, this functionality is very similar to what we needed for email validation isn&#8217;t it? We can, in fact copy
the <code>hx-trigger</code> attribute directly from our email validation example, with its small 200-millisecond delay, to allow a
user to stop typing before a request is triggered.</p>
</div>
<div class="paragraph">
<p>Again, a great example of how common patterns come up again and again when you are using htmx.</p>
</div>
<div class="listingblock">
<div class="title">Adding Active Search Behavior</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/contacts" method="get" class="tool-bar"&gt;
    &lt;label for="search"&gt;Search Term&lt;/label&gt;
    &lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}" <b class="conum">(1)</b>
           hx-get="/contacts" <b class="conum">(2)</b>
           hx-trigger="search, keyup delay:200ms changed"/&gt; <b class="conum">(3)</b>
    &lt;input type="submit" value="Search"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Keep the original attributes, so search will work if JavaScript is not available</p>
</li>
<li>
<p>Issue a <code>GET</code> to the same URL as the form</p>
</li>
<li>
<p>Nearly the same <code>hx-trigger</code> specification as for the email input validation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We did make a small change to the <code>hx-trigger</code> attribute: we switched out the <code>change</code> event for the <code>search</code> event.
The <code>search</code> event is triggered when someone clears the search or hits the enter key.  It is a non-standard event, but
it doesn&#8217;t hurt to include here.  The main functionality of the feature is provided by the second triggering event, the <code>keyup</code>
which, as with the email example, is delayed with the <code>delay:200ms</code> modifier to &#8220;debounce&#8221; the input requests and
avoid hammering our server with requests on every keyup.</p>
</div>
</div>
<div class="sect3">
<h4 id="_targeting_the_correct_element">Targeting The Correct Element</h4>
<div class="paragraph">
<p>What we have is already pretty close to what we want, but we need to set up the correct target.  Recall that the default
target for an element is itself.  As things currently stand, an HTTP <code>GET</code> request will be issued to the <code>/contacts</code> path,
which will, as of now, return an entire HTML document of search results, and then this whole document will be inserted
into the <em>inner</em> HTML of the search input.</p>
</div>
<div class="paragraph">
<p>This is, in fact, nonsense: <code>input</code> elements aren&#8217;t allowed to have any HTML inside of them. The browser will,
sensibly, just ignore the htmx request to put the response HTML inside the input.  So, at this point, when a user
types anything into our input, a request will be issued (you can see it in your browser development console if you try
it out) but, unfortunately, it will appear to the user as if nothing has happened at all.</p>
</div>
<div class="paragraph">
<p>To fix this issue, what do we want to target with the update instead?  Ideally we&#8217;d like to just target the actual
results: there is no reason to update the header or search input, and that could cause an annoying flash as focus jumps
around.</p>
</div>
<div class="paragraph">
<p>The <code>hx-target</code> attribute allows us to do exactly that.  Let&#8217;s use it to target the results body, the <code>tbody</code> element in
the table of contacts:</p>
</div>
<div class="listingblock">
<div class="title">Adding Active Search Behavior</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/contacts" method="get" class="tool-bar"&gt;
    &lt;label for="search"&gt;Search Term&lt;/label&gt;
    &lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"
           hx-get="/contacts"
           hx-trigger="change, keyup delay:200ms changed"
           hx-target="tbody"/&gt; <b class="conum">(1)</b>
    &lt;input type="submit" value="Search"/&gt;
&lt;/form&gt;
&lt;table&gt;
    ...
    &lt;tbody&gt;
       ...
    &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Target the <code>tbody</code> tag on the page</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Because there is only one <code>tbody</code> on the page, we can use the general CSS selector <code>tbody</code> and htmx will target the
body of the table on the page.</p>
</div>
<div class="paragraph">
<p>Now if you try typing something into the search box, we&#8217;ll see some results: a request is made and the results are inserted
into the document within the <code>tbody</code>.  Unfortunately, the content that is coming back is still an entire HTML document.</p>
</div>
<div class="paragraph">
<p>Here we end up with a &#8220;double render&#8221; situation, where an entire document has been inserted <em>inside</em> another element, with
all the navigation, headers and footers and so forth re-rendered within that element.  This is an example of one of those
silly mis-targeting issues we mentioned earlier.</p>
</div>
<div class="paragraph">
<p>Thankfully, it is pretty easy to fix.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paring_down_our_content">Paring Down Our Content</h4>
<div class="paragraph">
<p>Now, we could use the same trick we reached for in the &#8220;Click To Load&#8221; and &#8220;Infinite Scroll&#8221; features: the <code>hx-select</code>
attribute.  Recall that the <code>hx-select</code> attribute allows us to pick out the part of the response we are interested in using
a CSS selector.</p>
</div>
<div class="paragraph">
<p>So we could add this to our input:</p>
</div>
<div class="listingblock">
<div class="title">Using <code>hx-select</code> for Active Search</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"
       hx-get="/contacts"
       hx-trigger="change, keyup delay:200ms changed"
       hx-target="tbody"
       hx-select="tbody tr"/&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Adding an <code>hx-select</code> that picks out the table rows in the <code>tbody</code> of the response</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>However, that isn&#8217;t the only fix for this problem, and, in this case, it isn&#8217;t the most efficient one.  Instead, let&#8217;s
change the <em>server-side</em> of our Hypermedia-Driven Application to serve <em>only the HTML content needed</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_http_request_headers_in_htmx">HTTP Request Headers In htmx</h4>
<div class="paragraph">
<p>In this section, we&#8217;ll look at another, more advanced technique for dealing with a situation where we only want a <em>partial
bit</em> of HTML, rather than a full document. Currently, we are letting the server create the full HTML document as response
and then, on the client side, we filter the HTML down to the bits that we want.  This is easy to do, and, in fact, might
be necessary if we don&#8217;t control the server side or can&#8217;t easily modify responses.</p>
</div>
<div class="paragraph">
<p>In our application, however, since we are doing &#8220;Full Stack&#8221; development (that is: we control both the front end <em>and</em> the back end
code, and can easily modify either) we have another option: we can modify our server responses to return only the content
necessary, and remove the need to do client-side filtering.</p>
</div>
<div class="paragraph">
<p>This turns out to be more efficient, since we aren&#8217;t returning all the content surrounding the bit we are interested in,
saving bandwidth as well as CPU and memory on the server side.  So let&#8217;s take this opportunity to explore returning
different HTML content based on the context information that htmx provides with the HTTP requests it makes.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a look again at the current server-side code for our search logic:</p>
</div>
<div class="listingblock">
<div class="title">Server Side Search</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    if search is not None:
        contacts_set = Contact.search(search) <b class="conum">(1)</b>
    else:
        contacts_set = Contact.all()
    return render_template("index.html", contacts=contacts_set) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is where the search logic happens</p>
</li>
<li>
<p>We simply re-render the <code>index.html</code> template every time, no matter what</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>How do we want to change this?  We want to render two different bits of HTML content <em>conditionally</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If this is a &#8220;normal&#8221; request for the entire page, we want to render the <code>index.html</code> template in the current
manner.  In fact, we don&#8217;t want anything to change if this is a &#8220;normal&#8221; request.</p>
</li>
<li>
<p>However, if this is an &#8220;Active Search&#8221; request, we only want to render the content that is within the <code>tbody</code>,
that is, just the table rows of the page.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So we need some way to determine exactly which of these two different types of requests to the <code>/contact</code> URL is being
made, in order to know exactly which content we want to render.</p>
</div>
<div class="paragraph">
<p>It turns out that htmx helps us distinguish between these two cases by including a number of HTTP <em>Request Headers</em> when
it makes requests.  Request Headers are a feature of HTTP, allowing clients (e.g. web browsers) to include name/value pairs
of metadata associated with requests to help the server understand what the client is requesting.</p>
</div>
<div class="paragraph">
<p>Here is an example of (some of) the headers the FireFox browser issues when requesting <code><a href="https://manning.com" class="bare">https://manning.com</a></code>:</p>
</div>
<div class="listingblock">
<div class="title">HTTP Headers</div>
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">GET / HTTP/2
Host: www.manning.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:103.0) Gecko/20100101 Firefox/103.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
DNT: 1
Connection: keep-alive
Cookie: ...
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Sec-GPC: 1
TE: trailers</code></pre>
</div>
</div>
<div class="paragraph">
<p>htmx takes advantage of this feature of HTTP and adds additional headers and, therefore, additional <em>context</em> to the
HTTP requests that it makes.  This allows you to inspect those headers and make smarter decisions with respect to exactly
what logic to execute on the server, and what sort of HTML response you want to send to the client.</p>
</div>
<div class="paragraph">
<p>Here is a table of the HTTP headers that htmx includes in HTTP requests:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>HX-Boosted</code></dt>
<dd>
<p>This will be the string &#8220;true&#8221; if the request is made via an element using hx-boost</p>
</dd>
<dt class="hdlist1"><code>HX-Current-URL</code></dt>
<dd>
<p>This will be the current URL of the browser</p>
</dd>
<dt class="hdlist1"><code>HX-History-Restore-Request</code></dt>
<dd>
<p>This will be the string &#8220;true&#8221; if the request is for history restoration after a miss in the local history cache</p>
</dd>
<dt class="hdlist1"><code>HX-Prompt</code></dt>
<dd>
<p>This will contain the user response to an hx-prompt</p>
</dd>
<dt class="hdlist1"><code>HX-Request</code></dt>
<dd>
<p>This value is always &#8220;true&#8221; for htmx-based requests</p>
</dd>
<dt class="hdlist1"><code>HX-Target</code></dt>
<dd>
<p>This value will be the id of the target element if it exists</p>
</dd>
<dt class="hdlist1"><code>HX-Trigger-Name</code></dt>
<dd>
<p>This value will be the name of the triggered element if it exists</p>
</dd>
<dt class="hdlist1"><code>HX-Trigger</code></dt>
<dd>
<p>This value will be the id of the triggered element if it exists</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Looking through this list of headers, the last one stands out: we have an id, <code>search</code> on our search input.  So the
value of the <code>HX-Trigger</code> header should be set to <code>search</code> when the request is coming from the search input, which
has the id <code>search</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add some conditional logic to our controller to look for that header and, if the value is <code>search</code>, we render
only the rows rather than the whole <code>index.html</code> template:</p>
</div>
<div class="listingblock">
<div class="title">Updating Our Server Side Search</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    if search is not None:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search': <b class="conum">(1)</b>
          # TODO: render only the rows here <b class="conum">(2)</b>
    else:
        contacts_set = Contact.all()
    return render_template("index.html", contacts=contacts_set) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the request header <code>HX-Trigger</code> is equal to &#8220;search&#8221;, we want to do something different</p>
</li>
<li>
<p>We need to learn how to render just the table rows</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>OK, so how do we render only the result rows?</p>
</div>
</div>
<div class="sect3">
<h4 id="_factoring_your_templates">Factoring Your Templates</h4>
<div class="paragraph">
<p>Now we come to what is a common pattern in htmx: we want to <em>factor</em> our server-side templates.  This means that we want to
break our templates up a bit so that they can be called from multiple contexts.  In this case, we want to break the rows of
the results table out to a separate template.  We will call this new template <code>rows.html</code> and we will include it from
the original <code>index.html</code> template, and also use it in our controller to render it by itself when we want to respond with only the
rows for Active Search requests.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what the table in our <code>index.html</code> file currently looks like:</p>
</div>
<div class="listingblock">
<div class="title">The Contacts Table</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;First&lt;/th&gt; &lt;th&gt;Last&lt;/th&gt; &lt;th&gt;Phone&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for contact in contacts %}
            &lt;tr&gt;
                &lt;td&gt;{{ contact.first }}&lt;/td&gt;
                &lt;td&gt;{{ contact.last }}&lt;/td&gt;
                &lt;td&gt;{{ contact.phone }}&lt;/td&gt;
                &lt;td&gt;{{ contact.email }}&lt;/td&gt;
                &lt;td&gt;&lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
                    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>for</code> loop in this template is what produces all the rows in the final content generated by <code>index.html</code>.
What we want to do is to move the <code>for</code> loop and, therefore, the rows it creates out to a <em>separate template file</em> so that
only that small bit of HTML can be rendered independently from <code>index.html</code>.</p>
</div>
<div class="paragraph">
<p>Again, let&#8217;s call this new template <code>rows.html</code>:</p>
</div>
<div class="listingblock">
<div class="title">Our New <code>rows.html</code> file</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{% for contact in contacts %} <b class="conum">(2)</b>
    &lt;tr&gt;
        &lt;td&gt;{{ contact.first }}&lt;/td&gt;
        &lt;td&gt;{{ contact.last }}&lt;/td&gt;
        &lt;td&gt;{{ contact.phone }}&lt;/td&gt;
        &lt;td&gt;{{ contact.email }}&lt;/td&gt;
        &lt;td&gt;&lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
            &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
{% endfor %}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this template we can render only the <code>tr</code> elements for a given collection of contacts.</p>
</div>
<div class="paragraph">
<p>Of course, we still want to include this content in the <code>index.html</code> template: we are <em>sometimes</em> going to be
rendering the entire page, and sometimes only rendering the rows.  In order to keep the <code>index.html</code> template rendering
properly, we can include the <code>rows.html</code> template by using the jinja <code>include</code> directive at the position we want the content
from <code>rows.html</code> inserted:</p>
</div>
<div class="listingblock">
<div class="title">Including The New File</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;table&gt;
        &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;First&lt;/th&gt;
            &lt;th&gt;Last&lt;/th&gt;
            &lt;th&gt;Phone&lt;/th&gt;
            &lt;th&gt;Email&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% include 'rows.html' %} <b class="conum">(1)</b>
        &lt;/tbody&gt;
    &lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This directive &#8220;includes&#8221; the <code>rows.html</code> file, inserting its content into the current template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So far, so good: our <code>/contacts</code> page is still rendering properly, just as it did before we split the rows out of the
<code>index.html</code> template.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_our_new_template">Using Our New Template</h4>
<div class="paragraph">
<p>The last step in factoring our templates is to modify our web controller to take advantage of the new <code>rows.html</code> template
file when it responds to an active search request.</p>
</div>
<div class="paragraph">
<p>Since <code>rows.html</code> is just another template, just like <code>index.html</code>, all we need to do is call the <code>render_template</code>
function with <code>rows.html</code> rather than <code>index.html</code>, and we will render <em>only</em> the row content rather than the entire
page:</p>
</div>
<div class="listingblock">
<div class="title">Updating Our Server Side Search</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    if search is not None:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search':
          return render_template("rows.html", contacts=contacts_set) <b class="conum">(1)</b>
    else:
        contacts_set = Contact.all()
    return render_template("index.html", contacts=contacts_set)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Render the new template in the case of an active search</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when an Active Search request is made, rather than getting an entire HTML document back, we only get a partial
bit of HTML, the table rows for the contacts that match the search.  These rows are then inserted into the <code>tbody</code> on
the index page, without any need for an <code>hx-select</code> or any other client-side processing.</p>
</div>
<div class="paragraph">
<p>And, as a bonus, the old form-based search still works as well, thanks to the fact that we conditionally render the rows
only when the <code>search</code> input issues the HTTP request via htmx.  Again, this is a progressive enhancement to our
application.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">HTTP Headers &amp; Caching</div>
        <div class="paragraph">
<p>One subtle aspect of the approach we are taking here, using headers to determine the content of what we return, is
a feature baked into HTTP: caching.  In our request handler, we are now returning different content depending on the
value of the <code>HX-Trigger</code> header.  If we were to use HTTP Caching, we might get into a situation where someone makes
a <em>non-htmx</em> request (e.g. refreshing a page) and yet the <em>htmx</em> content is returned from the HTTP cache, resulting
in a partial page of content for the user.</p>
</div>
<div class="paragraph">
<p>The solution to this problem is to use the HTTP Response <code>Vary</code> header and call out the htmx headers that you are using
to determine what content you are returning.  A full explanation of HTTP Caching is beyond the scope of this book, but the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN article on the topic</a> is quite good, and the <a href="https://htmx.org/docs/#caching">htmx
documentation</a> discusses this issue as well.</p>
</div>
    </aside>
</div>
<div class="sect3">
<h4 id="_updating_the_navigation_bar_with_hx_push_url">Updating The Navigation Bar With <code>hx-push-url</code></h4>
<div class="paragraph">
<p>One shortcoming of our current Active Search implementation, when compared with the normal form submission, is that when
you submit the form version it updates the navigation bar of the browser to include the search term.  So, for example, if
you search for &#8220;joe&#8221; in the search box, you will end up with a url that looks like this in your browser&#8217;s nav bar:</p>
</div>
<div class="listingblock">
<div class="title">The Updated Location After A Form Search</div>
<div class="content">
<pre>https://example.com/contacts?q=joe</pre>
</div>
</div>
<div class="paragraph">
<p>This is a nice feature of browsers: it allows you to bookmark this search or to copy the URL and send it to someone else.
All they have to do is to click on the link, and they will repeat the exact same search.  This is also tied in with
the browser&#8217;s notion of history: if you click the back button it will take you to the previous URL that you came
from.  If you submit two searches and want to go back to the first one, you can simply hit back and the browser
will &#8220;return&#8221; to that search.</p>
</div>
<div class="paragraph">
<p>As it stands right now, during our Active Search, we are not updating the browser&#8217;s navigation bar, so users aren&#8217;t getting
nice copy-and-pasteable links and you aren&#8217;t getting history entries either, so no back button support.  Fortunately, htmx
provides a way for fixing this that we&#8217;ve already seen: the <code>hx-push-url</code> attribute.</p>
</div>
<div class="paragraph">
<p>The <code>hx-push-url</code> attribute lets you tell htmx &#8220;Please push the URL of this request into the browser&#8217;s navigation bar&#8221;.
Push might seem like an odd verb to use here, but that&#8217;s the term that the underlying browser history API uses, which
stems from the fact that it models browser history as a &#8220;stack&#8221; of locations: when you go to a new location, that
location is &#8220;pushed&#8221; onto the stack of history elements, and when you click &#8220;back&#8221;, that location is &#8220;popped&#8221; off
the history stack.</p>
</div>
<div class="paragraph">
<p>So, to get proper history support for our Active Search, all we need to do is to set the <code>hx-push-url</code> attribute to
<code>true</code>.  Let&#8217;s update our search input:</p>
</div>
<div class="listingblock">
<div class="title">Updating The URL During Active Search</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"
       hx-get="/contacts"
       hx-trigger="change, keyup delay:200ms changed"
       hx-target="tbody"
       hx-push-url="true"/&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>By adding the <code>hx-push-url</code> attribute with the value <code>true</code>, htmx will update the URL when it makes a request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, as Active Search requests are sent, the URL in the browser&#8217;s navigation bar is updated to have the proper query in
it, just like when the form is submitted.</p>
</div>
<div class="paragraph">
<p>Now, you might not <em>want</em> this behavior.  You might feel it would be confusing to users to see the navigation bar updated
and have history entries for every Active Search made, for example.  Which is fine: you can simply omit the <code>hx-push-url</code>
attribute and it will go back to the behavior you want.  Htmx tries to be flexible enough that you can achieve the UX
that <em>you</em> want, while staying within the declarative HTML model.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_a_request_indicator">Adding A Request Indicator</h4>
<div class="paragraph">
<p>A final touch for our Active Search pattern is to add a request indicator to let the user know that a search is in
progress.  As it stands the user has to know that the active search functionality is doing a request implicitly and,
if the search takes a bit, may end up thinking that the feature isn&#8217;t working.  By adding a request indicator we let
the user know that the hypermedia application is busy and they should wait (hopefully not too long!) for the request to
complete.</p>
</div>
<div class="paragraph">
<p>htmx provides support for request indicators via the <code>hx-indicator</code> attribute.  This attribute takes, you guessed it,
a CSS selector that points to the indicator for a given element.  The indicator can be anything, but it is typically
some sort of animated image, such as a gif or svg file, that spins or otherwise communicates visually that &#8220;something
is happening&#8221;.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add a spinner after our search input:</p>
</div>
<div class="listingblock">
<div class="title">Updating The URL During Active Search</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"
       hx-get="/contacts"
       hx-trigger="change, keyup delay:200ms changed"
       hx-target="tbody"
       hx-push-url="true"
       hx-indicator="#spinner"/&gt; <b class="conum">(1)</b>
&lt;img id="spinner" class="htmx-indicator" src="/static/img/spinning-circles.svg" alt="Request In Flight..."/&gt; <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>hx-indicator</code> attribute points to the indicator image after the input</p>
</li>
<li>
<p>The indicator is a spinning circle svg file, and has the <code>htmx-indicator</code> class on it</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have added the spinner right after the input.  This visually co-locates the request indicator with the element
making the request, and makes it easy for a user to see that something is in fact happening.</p>
</div>
<div class="paragraph">
<p>Note that the indicator <code>img</code> tag has the <code>htmx-indicator</code> class on it.  <code>htmx-indicator</code> is a CSS class that is
automatically injected into the page by htmx.  This class sets the default <code>opacity</code> of an element to <code>0</code>, which hides
the element from view, while at the same time not disrupting the layout of the page.</p>
</div>
<div class="paragraph">
<p>When an htmx request is triggered that points to this indicator, another class, <code>htmx-request</code> is added to the indicator
which transitions its opacity to 1.  So you can use just about anything as an indicator, and it will be hidden by default,
and then, when a request is in flight, will be shown.  This is all done via standard CSS classes, allowing you to control
the transitions and even the mechanism by which the indicator is shown (e.g. you might use <code>display</code> rather than
<code>opacity</code>).  htmx is flexible in this regard.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Use Request Indicators!</div>
        <div class="paragraph">
<p>Request indicators are an important UX aspect of any distributed application.  It is unfortunate that browsers have
de-emphasized their native request indicators over time, and it is doubly unfortunate that request indicators are not
part of the JavaScript ajax APIs.</p>
</div>
<div class="paragraph">
<p>Be sure not to neglect this significant aspect of your application.  Even though requests might seem instant when you are
working on your application locally, in the real world they can take quite a bit longer due to network latency.  It&#8217;s
often a good idea to take advantage of browser developer tools that allow you to throttle your local browser&#8217;s response
times.  This will give you a better idea of what real world users are seeing, and show you where indicators might help
users understand exactly what is going on.</p>
</div>
    </aside>
<div class="paragraph">
<p>With this request indicator, we now have a pretty sophisticated user experience built out when compared with plain HTML, but
we&#8217;ve built it all as a hypermedia-driven feature.  No JSON or JavaScript to be seen.  And this particular implementation also
has the benefit of being a progressive enhancement, so this aspect of our application will continue to work for clients
that don&#8217;t have JavaScript enabled.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_loading">7.2. Lazy Loading</h3>
<div class="paragraph">
<p>With Active Search behind us, let&#8217;s move on to a very different sort of problem: lazy loading.  Lazy loading is
when the loading of a particular bit of content is deferred until later, when needed.  This is commonly used as a
performance enhancement: you avoid the processing resources necessary to produce some data until that data is actually
needed.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add a count of the total number of contacts to Contact.app, just below the bottom of our contacts table.  This will
give us a potentially expensive operation that we can use to demonstrate how easy it is to add lazy loading to our
application with htmx.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s update our server code in the <code>/contacts</code> request handler to get a count of the total number of contacts.
We will pass that count through to the template to render some new HTML.</p>
</div>
<div class="listingblock">
<div class="title">Adding A Count To The UI</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    page = int(request.args.get("page", 1))
    count = Contact.count() <b class="conum">(1)</b>
    if search is not None:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search':
            return render_template("rows.html", contacts=contacts_set, page=page, count=count)
    else:
        contacts_set = Contact.all(page)
    return render_template("index.html", contacts=contacts_set, page=page, count=count) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the total count of contacts from the Contact model</p>
</li>
<li>
<p>Pass the count out to the <code>index.html</code> template to use when rendering</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As with the rest of the application, in the interest of staying focused on the <em>hypermedia</em> part of Contact.app, we are
not going to look into the details of how <code>Contact.count()</code> works.  We just need to know that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It returns the total count of contacts in the contact database</p>
</li>
<li>
<p>It may potentially be slow</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next lets add some HTML to our <code>index.html</code> that takes advantage of this new bit of data, showing a message next
to the "Add Contact" link with the total count of users.  Here is what our HTML looks like:</p>
</div>
<div class="listingblock">
<div class="title">Adding A Contact Count Element To The Application</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;a href="/contacts/new"&gt;Add Contact&lt;/a&gt; &lt;span&gt;({{ count }} total Contacts)&lt;/span&gt;<b class="conum">(1)</b>
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A simple span with some text showing the total number of contacts.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Well that was easy, wasn&#8217;t it?  Now our users will see the total number of contacts next to the link to add new
contacts, to give them a sense of how large the contact database is.  This sort of rapid development is one of the
joys of developing web applications the old way.</p>
</div>
<div class="paragraph">
<p>Here is what the feature looks like in our application:</p>
</div>
<div id="figure-5-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_total_contacts.png" alt="screenshot total contacts">
</div>
<div class="title">Figure 5. Total Contact Count Display</div>
</div>
<div class="paragraph">
<p>Beautiful.</p>
</div>
<div class="paragraph">
<p>Of course, as you probably suspected, all is not perfect.  Unfortunately, upon shipping this feature to production, we
start getting some complaints from the users that the application &#8220;feels slow&#8221;.  Like all good developers faced with
a performance issue, rather than guessing what the issue might be, we try to get a performance profile of the application
to see what exactly is causing the problem.</p>
</div>
<div class="paragraph">
<p>It turns out, surprisingly, that the problem is that innocent looking <code>Contacts.count()</code> call, which is taking up to
a second and a half to complete.  Unfortunately, for reasons beyond the scope of this book, it is not possible to improve
that load time, nor is possible to cache the result.</p>
</div>
<div class="paragraph">
<p>This leaves us with two choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove the feature</p>
</li>
<li>
<p>Come up with some other way to mitigate the performance issue</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we can&#8217;t remove the feature, and therefore look at how we can mitigate this performance issue by
using htmx instead.</p>
</div>
<div class="sect3">
<h4 id="_pulling_the_expensive_code_out">Pulling The Expensive Code Out</h4>
<div class="paragraph">
<p>The first step in implementing the Lazy Load pattern is to pull the expensive code, that is, the call to <code>Contacts.count()</code>
out of request handler for the <code>/contacts</code> end point.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s pull this function call into its own HTTP request handler as a new HTTP end point that we will put at <code>/contacts/count</code>.
For this new end point, we won&#8217;t need to render a template at all: its sole job is going to be to render that small bit of text
that is in the span, &#8220;(22 total Contacts)&#8221;</p>
</div>
<div class="paragraph">
<p>Here is what the new code will look like:</p>
</div>
<div class="listingblock">
<div class="title">Pulling The Expensive Code Out</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    page = int(request.args.get("page", 1)) <b class="conum">(1)</b>
    if search is not None:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search':
            return render_template("rows.html", contacts=contacts_set, page=page)
    else:
        contacts_set = Contact.all(page)
    return render_template("index.html", contacts=contacts_set, page=page) <b class="conum">(2)</b>

@app.route("/contacts/count")
def contacts_count():
    count = Contact.count() <b class="conum">(3)</b>
    return "(" + str(count) + " total Contacts)" <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We no longer call <code>Contacts.count()</code> in this handler</p>
</li>
<li>
<p><code>count</code> is no longer passed out to the template to render in the <code>/contacts</code> handler</p>
</li>
<li>
<p>We create a new handler at the <code>/contacts/count</code> path that does the expensive calculation</p>
</li>
<li>
<p>Return the string with the total number of contacts in it</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So now we have moved the performance issue out of the <code>/contacts</code> handler code, which renders the main contacts table,
and created a new HTTP end point that will produce this expensive-to-create count string for us.</p>
</div>
<div class="paragraph">
<p>Now we need to get the content from this new handler <em>into</em> the span, somehow.  As we said earlier, the default behavior
of htmx is to place any content it receives for a given request into the <code>innerHTML</code> of an element, and that turns out
to be exactly what we want here: we want to retrieve this text and put it into the <code>span</code>.  So we can simply place an
<code>hx-get</code> attribute on the span, pointing to this new path, and do exactly that.</p>
</div>
<div class="paragraph">
<p>However, recall that the default <em>event</em> that will trigger a request for a <code>span</code> element in htmx is the <code>click</code> event.
Well, that&#8217;s not what we want!  Instead, we want this request to trigger immediately, when the page loads.</p>
</div>
<div class="paragraph">
<p>To do this, we can add the <code>hx-trigger</code> attribute to update the trigger of the requests for the element, and use the
<code>load</code> event.</p>
</div>
<div class="paragraph">
<p>The <code>load</code> event is a special event that htmx triggers on all content when it is loaded into the DOM.  By setting <code>hx-trigger</code>
to <code>load</code>, we will cause htmx to issue the <code>GET</code> request when the <code>span</code> element is loaded into the page.</p>
</div>
<div class="paragraph">
<p>Here is our updated template code:</p>
</div>
<div class="listingblock">
<div class="title">Adding A Contact Count Element To The Application</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;p&gt;
    &lt;a href="/contacts/new"&gt;Add Contact&lt;/a&gt; &lt;span hx-get="/contacts/count" hx-trigger="load"&gt;&lt;/span&gt;<b class="conum">(1)</b>
&lt;/p&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue a <code>GET</code> to <code>/contacts/count</code> when the <code>load</code> event occurs</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that the <code>span</code> starts empty: we have removed the content from it, and we are allowing the request to <code>/contacts/count</code>
to populate it instead.</p>
</div>
<div class="paragraph">
<p>And, check it out, our <code>/contacts</code> page is fast again!  When you navigate to the page it feels very snappy and
profiling shows that yes, indeed, the page is loading much more quickly.  Why is that?  Well, we&#8217;ve deferred the
expensive calculation to a secondary request, allowing the initial request to finish loading much more quickly.</p>
</div>
<div class="paragraph">
<p>You might say &#8220;OK, great, but it&#8217;s still taking a second or two to get the total count on the page.&#8221;  True, but
often the user may not be particularly interested in the total count.  They may just want to come to the page and
search for an existing user, or perhaps they may want to edit or add a user.  The total count of contacts
is just a &#8220;nice to have&#8221; bit of information in these cases.</p>
</div>
<div class="paragraph">
<p>By deferring the calculation of the count in this manner we let users get on with their use of the application while we
perform the expensive calculation.</p>
</div>
<div class="paragraph">
<p>Yes, the total time to get all the information on the screen takes just as long.  It actually will be a bit longer, since
we now need two HTTP requests to get all the information for the page.  But the <em>perceived performance</em> for the end user will
be much better: they can do what they want nearly immediately, even if some information isn&#8217;t available instantaneously.</p>
</div>
<div class="paragraph">
<p>Lazy Loading is a great tool to have in your tool belt when optimizing your web application performance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_an_indicator">Adding An Indicator</h4>
<div class="paragraph">
<p>A shortcoming of the current implementation is that currently there is no indication that the count request is in flight,
it just appears at some point when the request finishes.</p>
</div>
<div class="paragraph">
<p>This isn&#8217;t ideal.  What we want here is an indicator, just like we added in our Active Search example.  And, in fact, we can
simply reuse that same exact spinner image, copy-and-pasted into the new HTML we have created.</p>
</div>
<div class="paragraph">
<p>Now, in this case, we have a one-time request and, once the request is over, we are not going to need the spinner anymore.
So it doesn&#8217;t make sense to use the exact same approach we did with the active search example.  Recall that in that
case we placed a spinner <em>after</em> the span and using the <code>hx-indicator</code> attribute to point to it.</p>
</div>
<div class="paragraph">
<p>In this case, since the spinner is only used once, we can put it <em>inside</em> the content of the span.  When the request
completes the content in the response will be placed inside the span, replacing the spinner with the computed contact
count.  It turns out that htmx allows you to place indicators with the <code>htmx-indicator</code> class on them inside of elements
that issue htmx-powered requests.  In the absence of an <code>hx-indicator</code> attribute, these internal indicators will be shown
when a request is in flight.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s add that spinner from the active search example as the initial content in our span:</p>
</div>
<div class="listingblock">
<div class="title">Adding An Indicator To Our Lazily Loaded Content</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;span hx-get="/contacts/count" hx-trigger="load"&gt;
  &lt;img id="spinner" class="htmx-indicator" src="/static/img/spinning-circles.svg"/&gt;<b class="conum">(1)</b>
&lt;/span&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Yep, that&#8217;s it</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now when the user loads the page, rather than having the total contact count sprung on them like a surprise,
there is a nice spinner indicating that something is coming.  Much better.</p>
</div>
<div class="paragraph">
<p>Note that all we had to do was copy and paste our indicator from the active search example into the <code>span</code>.  Once again
we see a great demonstration of how htmx provides flexible, composable features and building blocks for you to
work with: implementing a new feature is often just copy-and-paste, maybe a tweak or two, and you are done.</p>
</div>
</div>
<div class="sect3">
<h4 id="_but_thats_not_lazy">But That&#8217;s Not Lazy!</h4>
<div class="paragraph">
<p>You might say &#8220;OK, but that&#8217;s not really lazy.  We are still loading the count immediately when the page is loaded,
we are just doing it in a second request.  You aren&#8217;t really waiting until the value is actually needed.&#8221;</p>
</div>
<div class="paragraph">
<p>Fine.  Let&#8217;s make it <em>lazy</em> lazy: we&#8217;ll only issue the request when the <code>span</code> scrolls into view.</p>
</div>
<div class="paragraph">
<p>To do that, lets recall how we set up the infinite scroll example: we used the <code>revealed</code> event for our trigger.  That&#8217;s
all we want here, right?  When the element is revealed we issue the request?</p>
</div>
<div class="paragraph">
<p>Yep, that&#8217;s it.  Once again, we can mix and match concepts across various UX patterns to come up with solutions to
new problems in htmx.</p>
</div>
<div class="listingblock">
<div class="title">Making It Lazy Lazy</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;span hx-get="/contacts/count" hx-trigger="revealed"&gt; <b class="conum">(1)</b>
  &lt;img id="spinner" class="htmx-indicator" src="/static/img/spinning-circles.svg"/&gt;
&lt;/span&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Change the <code>hx-trigger</code> to <code>revealed</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now we have a truly lazy implementation, deferring the expensive computation until we are absolutely sure we need it. A
pretty cool trick, and, again, a simple one-attribute change demonstrates the flexibility of both htmx and the hypermedia
approach.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inline_delete">7.3. Inline Delete</h3>
<div class="paragraph">
<p>For our next hypermedia trick, we are going to implement the &#8220;Inline Delete&#8221; pattern.  With this feature, a contact can
be deleted directly from the table of all contacts, rather than requiring the user to navigate all the way to the edit view
of particular contact, in order to access the &#8220;Delete Contact&#8221; button we added in the last chapter.</p>
</div>
<div class="paragraph">
<p>Recall that we already have &#8220;Edit&#8221; and &#8220;View&#8221; links for each row, in the <code>rows.html</code> template:</p>
</div>
<div class="listingblock">
<div class="title">The Existing Row Actions</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;td&gt;
    &lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;
&lt;/td&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we want to add a &#8220;Delete&#8221; link as well.  And, thinking on it, we want that link to act an awful lot like the
&#8220;Delete Contact&#8221; button from <code>edit.html</code>, don&#8217;t we?  We&#8217;d like to issue an HTTP <code>DELETE</code> to the URL for the given
contact and we want a confirmation dialog to ensure the user doesn&#8217;t accidentally delete a contact.</p>
</div>
<div class="paragraph">
<p>Here is the &#8220;Delete Contact&#8221; button html:</p>
</div>
<div class="listingblock">
<div class="title">The Existing Row Actions</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-delete="/contacts/{{ contact.id }}"
        hx-push-url="true"
        hx-confirm="Are you sure you want to delete this contact?"
        hx-target="body"&gt;
    Delete Contact
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you may suspect by now, this is going to be another copy-and-paste job.</p>
</div>
<div class="paragraph">
<p>One thing to note is that, in the case of the &#8220;Delete Contact&#8221; button, we wanted to re-render the whole screen and update
the URL, since we are going to be returning from the edit view for the contact to the list view of all contacts.  In
the case of this link, however, we are already on the list of contacts, so there is no need to update the URL, and
we can omit the <code>hx-push-url</code> attribute.</p>
</div>
<div class="paragraph">
<p>Here is the code for our inline &#8220;Delete&#8221; link:</p>
</div>
<div class="listingblock">
<div class="title">The Existing Row Actions</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;td&gt;
    &lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;
    &lt;a href="#" hx-delete="/contacts/{{ contact.id }}"
        hx-confirm="Are you sure you want to delete this contact?"
        hx-target="body"&gt;Delete&lt;/a&gt; <b class="conum">(1)</b>
&lt;/td&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Almost a straight copy of the &#8220;Delete Contact&#8221; button</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, we have added a new anchor tag and given it a blank target (the <code>#</code> value in its <code>href</code> attribute) to
retain the correct mouse-over styling behavior of the link.  We&#8217;ve also copied the <code>hx-delete</code>, <code>hx-confirm</code> and
<code>hx-target</code> attributes from the &#8220;Delete Contact&#8221; button, but omitted the <code>hx-push-url</code> attributes since we don&#8217;t want
to update the URL of the browser.</p>
</div>
<div class="paragraph">
<p>We now have inline delete working, even with a confirmation dialog.  A user can click on the &#8220;Delete&#8221; link and the
row will disappear from the UI as the entire page is re-rendered.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">A Style Sidebar</div>
        <div class="paragraph">
<p>One side effect of adding this delete link is that we are starting to pile up the actions in a contact row:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_stacked_actions.png" alt="screenshot stacked actions">
</div>
<div class="title">Figure 6. That&#8217;s a Lot of Actions</div>
</div>
<div class="paragraph">
<p>It would be nice if we didn&#8217;t show the actions all in a row, and, additionally, it would be nice if we only showed the
actions when the user indicated interest in a given row.  We will return to this problem after we look at the relationship
between scripting and a Hypermedia Driven Application in a later chapter.</p>
</div>
<div class="paragraph">
<p>For now, let&#8217;s just tolerate this less-than-ideal user interface, knowing that we will fix it up later.</p>
</div>
    </aside>
<div class="sect3">
<h4 id="_narrowing_our_target">Narrowing Our Target</h4>
<div class="paragraph">
<p>We can get even fancier here, however.  What if, rather than re-rendering the whole page, we just removed the row
for the contact?  The user is looking at the row anyway, so is there really a need to re-render the whole page?</p>
</div>
<div class="paragraph">
<p>To do this, we&#8217;ll need to do a couple of things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We&#8217;ll need to update this link to target the row that it is in</p>
</li>
<li>
<p>We&#8217;ll need to change the swap to <code>outerHTML</code>, since we want to replace (really, remove) the entire row</p>
</li>
<li>
<p>We&#8217;ll need to update the server side to render empty content when the <code>DELETE</code> is issued from a &#8220;Delete&#8221; link rather
than from the &#8220;Delete Contact&#8221; button on the contact edit page</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>First things first, update the target of our &#8220;Delete&#8221; link to be the row that the link is in, rather than the entire
body.  We can once again take advantage of the relative positional <code>closest</code> feature to target the closest <code>tr</code>, like
we did in our &#8220;Click To Load&#8221; and &#8220;Infinite Scroll&#8221; features:</p>
</div>
<div class="listingblock">
<div class="title">The Existing Row Actions</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;td&gt;
    &lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;
    &lt;a href="#" hx-delete="/contacts/{{ contact.id }}"
        hx-swap="outerHTML"
        hx-confirm="Are you sure you want to delete this contact?"
        hx-target="closest tr"&gt;Delete&lt;/a&gt; <b class="conum">(1)</b>
&lt;/td&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Updated to target the closest enclosing <code>tr</code> (table row) of the link</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_updating_the_server_side_2">Updating The Server Side</h4>
<div class="paragraph">
<p>Now we need to update the server side as well.  We want to keep the &#8220;Delete Contact&#8221; button working as well, and in
that case the current logic is correct.  So we&#8217;ll need some way to differentiate between <code>DELETE</code> requests that are
triggered by the button and <code>DELETE</code> requests that come from this anchor.</p>
</div>
<div class="paragraph">
<p>The cleanest way to do this is to add an <code>id</code> attribute to the &#8220;Delete Contact&#8221; button, so that we can inspect the
<code>HX-Trigger</code> HTTP Request header to determine if the delete button was the cause of the request.  This is a simple
change to the existing HTML:</p>
</div>
<div class="listingblock">
<div class="title">Adding an <code>id</code> to the &#8220;Delete Contact&#8221; button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;button id="delete-btn" <b class="conum">(1)</b>
            hx-delete="/contacts/{{ contact.id }}"
            hx-push-url="true"
            hx-confirm="Are you sure you want to delete this contact?"
            hx-target="body"&gt;
        Delete Contact
    &lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An <code>id</code> attribute has been added to the button</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By giving this button an id attribute, we now have a mechanism for differentiating between the delete button in the
<code>edit.html</code> template and the delete links in the <code>rows.html</code> template.  When this button issues a request, it will now
look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">DELETE http://example.org/contacts/42 HTTP/1.1
Accept: text/html,*/*
Host: example.org
...
HX-Trigger: delete-btn
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that the request now includes the <code>id</code> of the button. This allows us to write code very similar to what we did
for the active search pattern, using a conditional on the <code>HX-Trigger</code> header to determine what we want to do.  If that
header has the value <code>delete-btn</code>, then we know the request came from the button on the edit page, and we can do what we
are currently doing: delete the contact and redirect to <code>/contacts</code> page.</p>
</div>
<div class="paragraph">
<p>If it <em>does not</em> have that value, then we can simply delete the contact and return an empty string.  This empty string
will replace the target, in this case the row for the given contact, thereby removing the row from the UI.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s refactor our server-side code to do this:</p>
</div>
<div class="listingblock">
<div class="title">Updating Our Server Code To Handle Two Different Delete Patterns</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/&lt;contact_id&gt;", methods=["DELETE"])
def contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete()
    if request.headers.get('HX-Trigger') == 'delete-btn': <b class="conum">(1)</b>
        flash("Deleted Contact!")
        return redirect("/contacts", 303)
    else:
        return "" <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the delete button on the edit page submitted this request, then continue to do the logic we had previous</p>
</li>
<li>
<p>If not, simply return an empty string, which will delete the row</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And that&#8217;s our server-side implementation:  when a user clicks &#8220;Delete&#8221; on a contact row and confirms the delete, the row will
disappear from the UI.  Once again, we have a situation where just changing a few lines of simple code gives us a
dramatically different behavior.  Hypermedia is very powerful in this manner.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_htmx_swapping_model">The htmx Swapping Model</h4>
<div class="paragraph">
<p>This is pretty cool, but there is another improvement we can make if we take some time to understand the htmx content
swapping model: it sure would be exciting if, rather than just instantly deleting the row, we faded it out before we removed
it.  That easement makes it more obvious that the row is being removed, giving the user some nice visual feedback on the
deletion.</p>
</div>
<div class="paragraph">
<p>It turns out we can do this pretty easily with htmx, but to do so we&#8217;ll need to dig in to exactly how htmx swaps content.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The htmx Swapping Model</div>
        <div class="paragraph">
<p>You might think that htmx simply puts the new content into the DOM, but that&#8217;s not in fact how it works.  Instead, content
goes through a series of steps as it is added to the DOM:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When content is received and about to be swapped into the DOM, the <code>htmx-swapping</code> CSS class is added to the target
element</p>
</li>
<li>
<p>A small delay then occurs (we will discuss why this delay exists in a moment)</p>
</li>
<li>
<p>Next, the <code>htmx-swapping</code> class is removed from the target and the <code>htmx-settling</code> class is added</p>
</li>
<li>
<p>The new content is swapped into the DOM</p>
</li>
<li>
<p>Another small delay occurs</p>
</li>
<li>
<p>Finally, the <code>htmx-settling</code> class is removed from the target</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is more to the swap mechanic (settling, for example, is a more advanced topic that we will discuss in a later chapter)
but for now this is all you need to know about it.</p>
</div>
<div class="paragraph">
<p>Now, there are small delays in the process here, typically on the order of a few milliseconds.  Why so?  It turns out
that these small delays allow <em>CSS transitions</em> to occur.</p>
</div>
<div class="paragraph">
<p>CSS transitions are a technology that allow you to animate a transition from one style to another.  So, for example, if
you changed the height of something from 10 pixels to 20 pixels, by using a CSS transition you can make the element
smoothly animate to the new height.  These sorts of animations are fun, often increase application usability, and are
a great mechanism to add polish and fit-and-finish to your web application.</p>
</div>
<div class="paragraph">
<p>Unfortunately, CSS transitions are difficult to access in plain HTML: you usually have to use JavaScript and add or remove classes
to get them to trigger.  This is why the htmx swap model is more complicated than you might initially think: by swapping
in classes and adding small delays, you can access CSS transitions purely within HTML, without needing to write any
JavaScript!</p>
</div>
    </aside>
</div>
<div class="sect3">
<h4 id="_taking_advantage_of_htmx_swapping">Taking Advantage of <code>htmx-swapping</code></h4>
<div class="paragraph">
<p>OK, so, let&#8217;s go back and look at our inline delete mechanic:  we click an htmx enhanced link which deletes the contact
and then swaps some empty content in for the row.  We know that, before the <code>tr</code> element is removed, it will have the
<code>htmx-swapping</code> class added to it.  We can take advantage of that to write a CSS transition that fades the opacity of
the row to 0.  Here is what that CSS looks like:</p>
</div>
<div class="listingblock">
<div class="title">Adding A Fade Out Transition</div>
<div class="content">
<pre class="highlight"><code class="language-css" data-lang="css">tr.htmx-swapping { <b class="conum">(1)</b>
  opacity: 0; <b class="conum">(2)</b>
  transition: opacity 1s ease-out; <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We want this style to apply to <code>tr</code> elements with the <code>htmx-swapping</code> class on them</p>
</li>
<li>
<p>The <code>opacity</code> will be 0, making it invisible</p>
</li>
<li>
<p>The <code>opacity</code> will transition to 0 over a 1 second time period, using the <code>ease-out</code> function</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Again, this is not a CSS book and we are not going to go deeply into the details of CSS transitions, but hopefully the
above makes sense to you, even if this is the first time you&#8217;ve seen CSS transitions.</p>
</div>
<div class="paragraph">
<p>So, think about what this means from the htmx swapping model:  when htmx gets content back to swap into the row it will
put the <code>htmx-swapping</code> class on the row and wait a bit.  This will allow the transition to a zero opacity to occur,
fading the row out.  Then the new (empty) content will be swapped in, which will effectively removing the row.</p>
</div>
<div class="paragraph">
<p>Sounds good, and we are nearly there.  There is one more thing we need to do: the default &#8220;swap delay&#8221; for htmx is very
short, a few milliseconds.  That makes sense in most cases: you don&#8217;t want to have much of a delay before you put the
new content into the DOM.  But, in this case, we want to give the CSS animation time to complete before we do the swap,
we want to give it a second, in fact.</p>
</div>
<div class="paragraph">
<p>Fortunately htmx has an option for the <code>hx-swap</code> annotation that allows you to set the swap delay: following the swap
type you can add <code>swap:</code> followed by a timing value to tell htmx to wait a specific amount of time before it swaps.  Let&#8217;s
update our HTML to allow a one second delay before the swap is done for the delete action:</p>
</div>
<div class="listingblock">
<div class="title">The Existing Row Actions</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;td&gt;
    &lt;a href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt;
    &lt;a href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;
    &lt;a href="#" hx-delete="/contacts/{{ contact.id }}"
        hx-swap="outerHTML swap:1s" <b class="conum">(1)</b>
        hx-confirm="Are you sure you want to delete this contact?"
        hx-target="closest tr"&gt;Delete&lt;/a&gt;
&lt;/td&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A swap delay changes how long htmx waits before it swaps in new content</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this modification, the existing row will stay in the DOM for an additional second, with the <code>htmx-swapping</code> class
on it.  This will give the row time to transition to an opacity of zero, giving the fade out effect we want.</p>
</div>
<div class="paragraph">
<p>Now, when a user clicks on a &#8220;Delete&#8221; link and confirms the delete, the row will slowly fade out and then, once it has
faded to a 0 opacity, it will be removed.  Pretty fancy, and all done in a declarative, hypermedia oriented manner, no
JavaScript required.  (Well, obviously htmx is written in JavaScript, but you know what we mean: we didn&#8217;t have to write
any JavaScript to implement the feature.)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bulk_delete">7.4. Bulk Delete</h3>
<div class="paragraph">
<p>The final feature we are going to implement in this chapter is a &#8220;Bulk Delete&#8221;.  The current mechanism for deleting users
is nice, but it would be annoying if a user wanted to delete five or ten contacts at a time, wouldn&#8217;t it?  For the bulk
delete feature, we want to add the ability to select rows via a checkbox input and delete them all in a single go by clicking
a &#8220;Delete Selected Contacts&#8221; button.</p>
</div>
<div class="paragraph">
<p>To get started with this feature, we&#8217;ll need to add a checkbox input to each row in the <code>rows.html</code> template.  This input
will have the name <code>selected_contact_ids</code> and its value will be the <code>id</code> of the contact for the current row.</p>
</div>
<div class="paragraph">
<p>Here is what the updated code for <code>rows.html</code> looks like:</p>
</div>
<div class="listingblock">
<div class="title">Adding A Checkbox To Each Row</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{% for contact in contacts %}
&lt;tr&gt;
  &lt;td&gt;&lt;input type="checkbox" name="selected_contact_ids" value="{{ contact.id }}"&gt;&lt;/td&gt; <b class="conum">(1)</b>
  &lt;td&gt;{{ contact.first }}&lt;/td&gt;
  ... omitted
&lt;/tr&gt;
{% endfor %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A new cell with the checkbox input whose value is set to the current contact&#8217;s id</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;ll also need to add an empty column in the header for the table to accommodate the checkbox column.  With that
done we now get a series of check boxes, one for each row, a pattern no doubt familiar to you from the web:</p>
</div>
<div id="figure-5-2" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_checkboxes.png" alt="screenshot checkboxes">
</div>
<div class="title">Figure 7. Checkboxes For Our Contact Rows</div>
</div>
<div class="paragraph">
<p>If you are not familiar with or have forgotten the way checkboxes work in HTML: a checkbox will submit its value associated
with the name of the input if and only if it is checked.  So if, for example, you checked the contacts with the ids 3,
7 and 9, then those three values would all be submitted to the server.  Since all the checkboxes in this case have
the same name, <code>selected_contact_ids</code>, all three values would be submitted with the name <code>selected_contact_ids</code>.</p>
</div>
<div class="sect3">
<h4 id="_the_delete_selected_contacts_button">The &#8220;Delete Selected Contacts&#8221; button</h4>
<div class="paragraph">
<p>The next step is to add a button below the table that will delete all the selected contacts.  We want this button, like
our delete links in each row, to issue an HTTP <code>DELETE</code>, but rather than issuing it to the URL for a given contact, like
we do with the inline delete links and with the delete button on the edit page, here we want to issue the <code>DELETE</code> to
the <code>/contacts</code> URL.</p>
</div>
<div class="paragraph">
<p>As with the other delete elements, we want to confirm that the user wishes to delete the contacts,
and, for this case, we are going to target the body of page, since we are going to re-render the whole table.</p>
</div>
<div class="paragraph">
<p>Here is what the button code looks like:</p>
</div>
<div class="listingblock">
<div class="title">The Delete Selected Contacts Button.</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-delete="/contacts" <b class="conum">(1)</b>
        hx-confirm="Are you sure you want to delete these contacts?" <b class="conum">(2)</b>
        hx-target="body"&gt; <b class="conum">(3)</b>
    Delete Selected Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue a <code>DELETE</code> to <code>/contacts</code></p>
</li>
<li>
<p>Confirm that the user wants to delete the selected contacts</p>
</li>
<li>
<p>Target the body</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Pretty easy.  One question though: how are we going to include the values of all the selected checkboxes in the
request?  As it stands right now, this is just a stand-alone button, and it doesn&#8217;t have any information indicating that
it should include any other information in the <code>DELETE</code> request it makes.</p>
</div>
<div class="paragraph">
<p>Fortunately, htmx has a few different ways to include values of inputs with a request.</p>
</div>
<div class="paragraph">
<p>One way would be to use the <code>hx-include</code> attribute, which allows you to use a CSS selector to specify the elements
you want to include in the request.  That would work fine here, but we are going to use another approach that is a bit
simpler in this case.</p>
</div>
<div class="paragraph">
<p>By default, if an element is a child of a <code>form</code> element and makes a non-<code>GET</code> request, htmx will include all the values of
inputs within that form.  In situations like this, where there is a bulk operation for a table, it is common to enclose
the whole table in a form tag, so that it is easy to add buttons that operate on the selected items.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add that form tag around the form, and be sure to enclose the button in it as well:</p>
</div>
<div class="listingblock">
<div class="title">The Delete Selected Contacts Button.</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;form&gt; <b class="conum">(1)</b>
        &lt;table&gt;
          ... omitted
        &lt;/table&gt;
        &lt;button hx-delete="/contacts"
                hx-confirm="Are you sure you want to delete these contacts?"
                hx-target="body"&gt;
            Delete Selected Contacts
        &lt;/button&gt;
    &lt;/form&gt; <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The form tag encloses the entire table</p>
</li>
<li>
<p>And also encloses the button</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when the button issues a <code>DELETE</code>, it will include all the contact ids that have been selected as the
<code>selected_contact_ids</code> request variable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_server_side_for_delete_selected_contacts">The Server Side for Delete Selected Contacts</h4>
<div class="paragraph">
<p>The server-side implementation is going to look an awful lot like our original server-side code for deleting a contact.
In fact, once again, we can just copy and paste, and fix a bit of stuff up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We want to change the URL to <code>/contacts</code></p>
</li>
<li>
<p>We want the handler to get <em>all</em> the ids submitted as <code>selected_contact_ids</code> and iterate over each one, deleting the
given contact</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Those are really the only changes we need to make!  Here is what the server-side code looks like:</p>
</div>
<div class="listingblock">
<div class="title">The Delete Selected Contacts Button.</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/", methods=["DELETE"]) <b class="conum">(1)</b>
def contacts_delete_all():
    contact_ids = list(map(int, request.form.getlist("selected_contact_ids"))) <b class="conum">(2)</b>
    for contact_id in contact_ids: <b class="conum">(3)</b>
        contact = Contact.find(contact_id)
        contact.delete() <b class="conum">(4)</b>
    flash("Deleted Contacts!") <b class="conum">(5)</b>
    contacts_set = Contact.all()
    return render_template("index.html", contacts=contacts_set)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We handle a <code>DELETE</code> request to the <code>/contacts/</code> path</p>
</li>
<li>
<p>We convert the <code>selected_contact_ids</code> values submitted to the server from a list of strings to a list integers</p>
</li>
<li>
<p>We iterate over all of the ids</p>
</li>
<li>
<p>And delete the given contact with each id</p>
</li>
<li>
<p>Beyond that, it&#8217;s the same code as our original delete handler: flash a message and render the <code>index.html</code> template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So, as you can see, we just took the original delete logic and slightly modified it to deal with an array of ids, rather
than a single id.</p>
</div>
<div class="paragraph">
<p>Readers with sharp eyes might notice one other small change: we did away with the redirect that was  in the original
delete code.  We did so because we are already on the page we want to re-render, so there is no reason
to redirect and have the URL update to something new.  We can just re-render the page, and the new list of contacts (sans the
contacts that were deleted) will be re-rendered.</p>
</div>
<div class="paragraph">
<p>And there we go, we now have a bulk delete feature for our application.  Once again, not a huge amount of code, and we
are implementing these features entirely by exchanging hypermedia with a server in the traditional, RESTful manner of
the web.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_dynamic_archive_ui">8. A Dynamic Archive UI</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_dynamic_archive_ui_2">8.1. A Dynamic Archive UI</h3>
<div class="paragraph">
<p>Contact.app has come a long way from the traditional web 1.0-style web application it started life as, at this point:
we&#8217;ve added active search, bulk delete (with some nice animations) and a slew of other features.  We have reached a level
of interactivity that most web developers would assume requires some sort of Single-Page Application JavaScript framework,
but we&#8217;ve done nearly all of it using htmx-powered hypermedia instead.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how we can add a final significant feature to Contact.app: downloading an archive of all the contacts.</p>
</div>
<div class="paragraph">
<p>From a hypermedia perspective, downloading a file isn&#8217;t exactly rocket science: using the HTTP <code>Content-Disposition</code>
response header, we can easily tell the browser to download and save a file to the local computer.</p>
</div>
<div class="paragraph">
<p>However, let&#8217;s make this problem a bit more interesting: let&#8217;s add in the fact that the export can take a bit of time,
from five to ten seconds, or sometimes even longer, to complete.</p>
</div>
<div class="paragraph">
<p>This means that if we implemented the download as a &#8220;normal&#8221; HTTP request, driven by a link or a button, the user might
sit with very little visual feedback, wondering if the download is actually happening, while the export is being completed.
They might even give up in frustration and click the download hypermedia control again, causing a <em>second</em> archive
request.  Not good.</p>
</div>
<div class="paragraph">
<p>This turns out to be a classic problem in web app development.  When faced with potentially long-running process like this,
we ultimately have two options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the user triggers the action, block until it is complete and then respond with the result</p>
</li>
<li>
<p>Begin the action and return immediately, showing some sort of UI indicating that things are in progress</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Blocking and waiting for the action to complete is certainly the simpler way to handle it, but it can be a bad user
experience, especially if the action takes a while to complete.  If you&#8217;ve ever clicked on something in a web 1.0-style
application and then had to sit there for what seems like an eternity before anything happens, you&#8217;ve seen the
practical results of this choice.</p>
</div>
<div class="paragraph">
<p>The second option, starting the action asynchronously (say, by creating a thread, or submitting it
to a job runner system) is much nicer from a user experience perspective: the server can respond immediately and the user
doesn&#8217;t need to sit there wondering what&#8217;s going on.</p>
</div>
<div class="paragraph">
<p>But the question is, what do you respond <em>with</em>?  The job probably isn&#8217;t complete yet, so you can&#8217;t provide a link
to the results.</p>
</div>
<div class="paragraph">
<p>We have seen a few different &#8220;simple&#8221; approaches in this scenario in various web applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Let the user know that the process has started and that they will be emailed a link to the completed process
results when it is finished</p>
</li>
<li>
<p>Let the user know that the process has started and recommend that they should manually refresh the page to see the
status of the process</p>
</li>
<li>
<p>Let the user know that the process has started and automatically refresh the page every few seconds using some JavaScript</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these will work, but none of them is a great user experience.</p>
</div>
<div class="paragraph">
<p>What we&#8217;d <em>really</em> like in this scenario is something more like what you see when, for example, you download a large file via the
browser: a nice progress bar indicating where in the process you are, and, when the process is complete, a link to click immediately
to view the result of the process.</p>
</div>
<div class="paragraph">
<p>This may sound like something impossible to implement with hypermedia, and, to be honest, we&#8217;ll need to push htmx pretty hard
to make this all work, but, when it is done, it won&#8217;t be <em>that</em> much code, and we will be able to achieve the user experience
we want for this archiving feature.</p>
</div>
<div class="sect3">
<h4 id="_ui_requirements">UI Requirements</h4>
<div class="paragraph">
<p>Before we dive into the implementation, let&#8217;s discuss in broad terms what our new UI should look like:  we want a button
in the application labeled &#8220;Download Contact Archive&#8221;.  When a user clicks on that button, we want to replace that
button with a UI that shows the progress of the archiving process, ideally with a progress bar.  As the archive job makes
progress, we want to move the progress bar along towards completion.  Then, when the archive job is done, we want to
show a link to the user to download the contact archive file.</p>
</div>
<div class="paragraph">
<p>In order to actually do the archiving, we are going to use a python class, <code>Archiver</code>, that implements all the
functionality that we need.  As with the <code>Contact</code> class, we aren&#8217;t going to go into the implementation details of <code>Archiver</code>
, because that&#8217;s beyond the scope of this book.  All you, the reader, need to know is that it provides all the server-side
behavior necessary to start a contact archive process and get the results when that process is done.</p>
</div>
<div class="paragraph">
<p><code>Archiver</code> gives us the following methods to work with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>status()</code> - A string representing the status of the download, either <code>Waiting</code>, <code>Running</code> or <code>Complete</code></p>
</li>
<li>
<p><code>progress()</code> - A number between 0 and 1, indicating how much progress the archive job has made</p>
</li>
<li>
<p><code>run()</code> - Starts a new archive job (if the current status is <code>Waiting</code>)</p>
</li>
<li>
<p><code>reset()</code> - Cancels the current archive job, if any, and resets to the &#8220;Waiting&#8221; state</p>
</li>
<li>
<p><code>archive_file()</code> - The path to the archive file that has been created on the server, so we can send it to the client</p>
</li>
<li>
<p><code>get()</code> - A class method that lets us get the Archiver for the current user</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Not a terribly sophisticated API.</p>
</div>
<div class="paragraph">
<p>The only somewhat tricky aspect to the whole API is that the <code>run()</code> method
is <em>non-blocking</em>. This means that it does not <em>immediately</em> create the archive file, but rather it starts a background job
(as a thread) to do the actual archiving.  This can be confusing if you aren&#8217;t used to multithreading in code: you might
be expecting the <code>run()</code> method to &#8220;block&#8221;, that is, to actually execute the entire export and only return when it is
finished.  But, if it did that, we wouldn&#8217;t be able to start the archive process and immediately render our desired
archive progress UI.</p>
</div>
</div>
<div class="sect3">
<h4 id="_beginning_our_implementation">Beginning Our Implementation</h4>
<div class="paragraph">
<p>We now have everything we need to begin implementing our UI: a reasonable outline of what it is going to look like, and
the domain logic to support it.</p>
</div>
<div class="paragraph">
<p>So, in getting down to building the UI, the first thing we want to note is that this UI is largely self-contained: we
want to replace the button with the download progress bar, and then the progress bar with a link to download the results
of the completed archive process.</p>
</div>
<div class="paragraph">
<p>The fact that our archive user interface is all going to be within a specific part of the UI is a strong hint
that we will want to create a new template to handle it.  Let&#8217;s call this template <code>archive_ui.html</code>.</p>
</div>
<div class="paragraph">
<p>Another thing that jumps out at us is that we are going to want to replace the entire download UI in multiple cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we start the download, we will want to replace the button with a progress bar</p>
</li>
<li>
<p>As the archive process proceeds, we will want to replace/update the progress bar</p>
</li>
<li>
<p>When the archive process completes, we will want to replace the progress bar with a download link</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Given we are going to be updating the UI in this way, it makes sense to have a good target for the updates.  So, let&#8217;s
wrap the entire UI in a <code>div</code> tag, and then use that <code>div</code> as the target for all our operations.</p>
</div>
<div class="paragraph">
<p>Here is the start of the template content for our new archive user interface:</p>
</div>
<div class="listingblock">
<div class="title">Our Initial Archive UI Template</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui"
    hx-target="this" <b class="conum">(1)</b>
    hx-swap="outerHTML"&gt; <b class="conum">(2)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This div will be the target for all elements within it</p>
</li>
<li>
<p>Replace the entire div every time using <code>outerHTML</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, lets add the &#8220;Download Contact Archive&#8221; button to the <code>div</code> that will kick off the archive-then-download
process.  We&#8217;ll use a <code>POST</code> to the path <code>/contacts/archive</code> to trigger the start of the archiving process:</p>
</div>
<div class="listingblock">
<div class="title">Adding The Archive Button</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui" hx-target="this" hx-swap="outerHTML"&gt;
  &lt;button hx-post="/contacts/archive"&gt; <b class="conum">(1)</b>
      Download Contact Archive
  &lt;/button&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This button will issue a <code>POST</code> to <code>/contacts/archive</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s include this new template in our main <code>index.html</code> template, above the contacts table:</p>
</div>
<div class="listingblock">
<div class="title">Our Initial Archive UI Template</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{% block content %}

    {% include 'archive_ui.html' %} <b class="conum">(1)</b>

    &lt;form action="/contacts" method="get" class="tool-bar"&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This template will now be included in the main template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With that done, we now have a button showing up in our web application to get the download going.  Since the enclosing
<code>div</code> has an <code>hx-target="this"</code> on it, the button will inherit that target and replace that enclosing <code>div</code> with whatever HTML
comes back from the <code>POST</code> to <code>/contacts/archive</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_the_archiving_end_point">Adding the Archiving End Point</h4>
<div class="paragraph">
<p>Our next step is to handle the <code>POST</code> that our button is making.  What we are going to want to do is to get the
<code>Archiver</code> for the current user and invoke the <code>run()</code> method on it.  This will start the archive process running.  Then
we will want to render some new content indicating that the process is running.</p>
</div>
<div class="paragraph">
<p>To do that, what we want to do is reuse the <code>archive_ui</code> template to handle rendering the archive UI for both states,
when the archiver is &#8220;Waiting&#8221; and when it is &#8220;Running&#8221;.  (We will handle the &#8220;Complete&#8221; state in a bit.)</p>
</div>
<div class="paragraph">
<p>This is a very common pattern: we put all the different potential UIs for a given chunk of the user interface into
a single template, and conditionally render the appropriate interface.  By keeping everything in one file, it makes
it much easier for other developers (or for us, if we come back after a while!) to understand exactly how the UI
works on the client side.</p>
</div>
<div class="paragraph">
<p>Since we are going to conditionally render different user interfaces based on the state of the archiver, we will need
to pass the archiver out to the template as a parameter.  So, again: we need to invoke <code>run()</code> on the archiver in our
controller and then pass the archiver along to the template, so it can render the UI appropriate for the current
status of the archive process.</p>
</div>
<div class="paragraph">
<p>Here is what the code looks like:</p>
</div>
<div class="listingblock">
<div class="title">Server Side Code To Start The Archive Process</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/archive", methods=["POST"]) <b class="conum">(1)</b>
def start_archive():
    archiver = Archiver.get() <b class="conum">(2)</b>
    archiver.run() <b class="conum">(3)</b>
    return render_template("archive_ui.html", archiver=archiver) <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle <code>POST</code> to <code>/contacts/archive</code></p>
</li>
<li>
<p>Look up the Archiver</p>
</li>
<li>
<p>Invoke the non-blocking <code>run()</code> method on it</p>
</li>
<li>
<p>Render the <code>archive_ui.html</code> template, passing in the archiver</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_conditionally_rendering_a_progress_ui">Conditionally Rendering A Progress UI</h4>
<div class="paragraph">
<p>Now let&#8217;s turn our attention to updating our archiving UI by setting <code>archive_ui.html</code> to conditionally render different
content depending on the state of the archive process.  We are passing the archiver through
as a variable to the template, and recall that the archiver has a <code>status()</code> method that we can consult to see what
the status of the archive process is.</p>
</div>
<div class="paragraph">
<p>We want to render the &#8220;Download Contact Archive&#8221; button if the archiver has the status <code>Waiting</code>, and we want to render
some sort of message indicating that progress is happening if the status is <code>Running</code>.  Let&#8217;s update our template code
to do just that:</p>
</div>
<div class="listingblock">
<div class="title">Adding Conditional Rendering</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui" hx-target="this" hx-swap="outerHTML"&gt;
    {% if archiver.status() == "Waiting" %} <b class="conum">(1)</b>
        &lt;button hx-post="/contacts/archive"&gt;
            Download Contact Archive
        &lt;/button&gt;
    {% elif archiver.status() == "Running" %}<b class="conum">(2)</b>
       Running...<b class="conum">(3)</b>
    {% end %}

&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only render button if the status is &#8220;Waiting&#8221;</p>
</li>
<li>
<p>Render different content when status is &#8220;Running&#8221;</p>
</li>
<li>
<p>For now, just some text saying things are Running</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>OK, great, we have some conditional logic in our template view, and the server-side logic to support kicking off the
archive process.  We don&#8217;t have a progress bar yet, but we&#8217;ll get there!  Let&#8217;s see how this works as it stands, and
refresh the main page of our application&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="title">Something Went Wrong</div>
<div class="content">
<pre>UndefinedError
jinja2.exceptions.UndefinedError: 'archiver' is undefined</pre>
</div>
</div>
<div class="paragraph">
<p>Ouch!</p>
</div>
<div class="paragraph">
<p>We get an error message right out of the box.  Why?  Ah, of course, we are including the <code>archive_ui.html</code> in the
<code>index.html</code> template, but now the <code>archive_ui.html</code> template expects the archiver to be passed through to it, so
it can conditionally render the correct UI.</p>
</div>
<div class="paragraph">
<p>That&#8217;s an easy fix: we just need to pass the archiver through when we render the <code>index.html</code> template as well:</p>
</div>
<div class="listingblock">
<div class="title">Including The Archiver When We Render index.html</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    if search is not None:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search':
            return render_template("rows.html", contacts=contacts_set)
    else:
        contacts_set = Contact.all()
    return render_template("index.html", contacts=contacts_set, archiver=Archiver.get())<b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Pass through archiver to the main template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now with that done, we can load up the page.  And, sure enough, we can see the &#8220;Download Contact Archive&#8221; button.</p>
</div>
<div class="paragraph">
<p>When we click on it, the button is replaced with the content &#8220;Running&#8230;&#8203;&#8221;, and we can see in our development console
on the server-side that the job is indeed getting kicked off properly.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_polling">8.2. Polling</h3>
<div class="paragraph">
<p>That&#8217;s definitely progress, but we don&#8217;t exactly have the best progress indicator here: just some static text telling
the user that the process is running.</p>
</div>
<div class="paragraph">
<p>Next we want to make the content update as the process makes progress and, ideally, show a progress bar indicating
how far along it is.  How can we do that in htmx using plain old hypermedia?</p>
</div>
<div class="paragraph">
<p>The technique we want to use here is called &#8220;polling&#8221;, where we issue a request on an interval and update the UI based
on the new state of the server.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Polling?  Really?</div>
        <div class="paragraph">
<p>Polling has a bit of a bad rap, and it isn&#8217;t the sexiest technique in the world: today
developers might look at a more advanced technique like WebSockets or Server Sent Events (SSE) to address this situation.</p>
</div>
<div class="paragraph">
<p>But, say what one will, polling <em>works</em> and it is drop-dead simple.  You need to be careful to make sure you don&#8217;t overwhelm
you system with polling requests, but, with a bit of care, you can create a reliable, passively updated component in
your UI using it.</p>
</div>
    </aside>
<div class="paragraph">
<p>htmx offers two types of polling.  The first is &#8220;fixed rate polling&#8221;, which uses a special <code>hx-trigger</code> syntax to indicate
that something should be polled on a fixed interval.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="title">Fixed Interval Polling</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div hx-get="/messages" hx-trigger="every 3s"&gt; <b class="conum">(1)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>trigger a <code>GET</code> to <code>/messages</code> every three seconds</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This works great in situations when you want to poll indefinitely, for example if you want to constantly poll for new
messages to display to the user.  However, fixed rate polling isn&#8217;t ideal when you have a definite process after which
you want to stop polling: it keeps polling forever, until the element it is on is removed from the DOM.</p>
</div>
<div class="paragraph">
<p>In our case, we have a definite process with an ending to it.  So, in our case, it will be better to use the second polling
technique, known as "load polling".  In load polling, you take advantage of the fact that htmx triggers a <code>load</code> event
when content is loaded into the DOM.  So you can create a trigger on the <code>load</code> event, but then add a bit of a delay so that
the request doesn&#8217;t trigger immediately.</p>
</div>
<div class="paragraph">
<p>When you do this, then you can conditionally render the <code>hx-trigger</code> on every request: when a process has completed you
can simply not include the <code>load</code> trigger and the load polling stops.  A nice and simple way to poll until a definite
process finishes.</p>
</div>
<div class="sect3">
<h4 id="_using_polling_to_update_the_archive_ui">Using Polling To Update The Archive UI</h4>
<div class="paragraph">
<p>Let&#8217;s use load polling to update our UI as the archiver makes progress.  To show the progress, let&#8217;s use
a CSS-based progress bar, taking advantage of the <code>progress()</code> method which returns a number between 0 and 1 indicating
how close the archive process is to completion.</p>
</div>
<div class="paragraph">
<p>Here is the snippet of HTML we will use:</p>
</div>
<div class="listingblock">
<div class="title">A CSS-based Progress Bar</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="progress" &gt;
    &lt;div class="progress-bar" style="width:{{ archiver.progress() * 100 }}%"&gt;&lt;/div&gt; <b class="conum">(1)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The width of the inner element corresponds to the progress</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This CSS-based progress bar has two components: an outer <code>div</code> that provides the wire frame for the progress bar,
 and an inner <code>div</code> that is the actual progress bar indicator.  We set the width of the inner progress bar to some percentage
(note we need to multiply the <code>progress()</code> result by 100 to get a percentage) and that will make the progress
indicator the appropriate width within the parent div.</p>
</div>
<div class="paragraph">
<p>As we have mentioned before, this is not a book on CSS, but, for completeness, here is the CSS for this progress bar:</p>
</div>
<div class="listingblock">
<div class="title">The CSS For Our Progress Bar</div>
<div class="content">
<pre class="highlight"><code class="language-css" data-lang="css">.progress {
    height: 20px;
    margin-bottom: 20px;
    overflow: hidden;
    background-color: #f5f5f5;
    border-radius: 4px;
    box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
}

.progress-bar {
    float: left;
    width: 0%;
    height: 100%;
    font-size: 12px;
    line-height: 20px;
    color: #fff;
    text-align: center;
    background-color: #337ab7;
    box-shadow: inset 0 -1px 0 rgba(0,0,0,.15);
    transition: width .6s ease;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which ends up rendering like this:</p>
</div>
<div id="figure-8-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_progress_bar.png" alt="screenshot progress bar">
</div>
<div class="title">Figure 8. Our CSS-Based Progress Bar</div>
</div>
<div class="paragraph">
<p>Let&#8217;s add the code for our progress bar into our <code>archive_ui.html</code> template for the case when the archiver is
running, and let&#8217;s update the copy to say &#8220;Creating Archive&#8230;&#8203;&#8221;:</p>
</div>
<div class="listingblock">
<div class="title">Adding The Progress Bar</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui" hx-target="this" hx-swap="outerHTML"&gt;
    {% if archiver.status() == "Waiting" %}
        &lt;button hx-post="/contacts/archive"&gt;
            Download Contact Archive
        &lt;/button&gt;
    {% elif archiver.status() == "Running" %}
        &lt;div&gt;
            Creating Archive...
            &lt;div class="progress" &gt; <b class="conum">(1)</b>
                &lt;div class="progress-bar" style="width:{{ archiver.progress() * 100 }}%"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    {% endif %}
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Our shiny new progress bar</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now when we click the &#8220;Download Contact Archive&#8221; button, we get the progress bar.  But it still doesn&#8217;t update
because we haven&#8217;t implemented load polling yet: it just sits there, at zero.</p>
</div>
<div class="paragraph">
<p>To get the progress bar updating dynamically, we&#8217;ll need to implement load polling using <code>hx-trigger</code>.  We can add this
to pretty much any element inside the conditional block for when the archiver is running, so let&#8217;s add it to that <code>div</code> that is
wrapping around the &#8220;Creating Archive&#8230;&#8203;&#8221; text and the progress bar.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s make it poll by issuing an HTTP <code>GET</code> to the same path that the <code>POST</code> was issued too: <code>/contacts/archive</code>.</p>
</div>
<div class="listingblock">
<div class="title">Implementing Load Polling</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui" hx-target="this" hx-swap="outerHTML"&gt;
    {% if archiver.status() == "Waiting" %}
        &lt;button hx-post="/contacts/archive"&gt;
            Download Contact Archive
        &lt;/button&gt;
    {% elif archiver.status() == "Running" %}
        &lt;div hx-get="/contacts/archive" hx-trigger="load delay:500ms"&gt; <b class="conum">(1)</b>
            Creating Archive...
            &lt;div class="progress" &gt;
                &lt;div class="progress-bar" style="width:{{ archiver.progress() * 100 }}%"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    {% endif %}
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Issue a <code>GET</code> to <code>/contacts/archive</code> 500 milliseconds after the content loads</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Again, it is important to realize that, when this <code>GET</code> is issued to <code>/contacts/archive</code>, it is going to replace
the <code>div</code> with the id <code>archive-ui</code>, not just itself.  The <code>hx-target</code> attribute on the <code>div</code> with the id <code>archive-ui</code> is
<em>inherited</em> by all child elements within that <code>div</code>, so the children will all target that outermost <code>div</code> in the
<code>archive_ui.html</code> file.</p>
</div>
<div class="paragraph">
<p>Now we need to handle the <code>GET</code> to <code>/contacts/archive</code> on the server.  Thankfully, this is quite easy: all we
want to do is re-render <code>archive_ui.html</code> with the archiver:</p>
</div>
<div class="listingblock">
<div class="title">Handling Progress Updates</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/archive", methods=["GET"]) <b class="conum">(1)</b>
def archive_status():
    archiver = Archiver.get()
    return render_template("archive_ui.html", archiver=archiver) <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>handle <code>GET</code> to the <code>/contacts/archive</code> path</p>
</li>
<li>
<p>just re-render the <code>archive_ui.html</code> template</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Simple, like so much else with hypermedia.</p>
</div>
<div class="paragraph">
<p>Now, when we click the &#8220;Download Contact Archive&#8221;, sure enough, we get a progress bar that updates every 500
milliseconds.  And, as the result of the call to <code>archiver.progress()</code> incrementally updates from 0 to 1, the
progress bar moves across the screen for us.  Very cool.</p>
</div>
</div>
<div class="sect3">
<h4 id="_downloading_the_result">Downloading The Result</h4>
<div class="paragraph">
<p>We have one final state to handle, the case when <code>achiver.status()</code> is set to &#8220;Complete&#8221;, and there is a JSON
archive of the data ready to download.  When the archiver is complete, we can get the local JSON file on the server
from the archiver via the <code>archive_file()</code> call.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add another case to our if statement to handle the &#8220;Complete&#8221; state, and, when the archive job is complete, lets
render a link to a new path, <code>/contacts/archive/file</code>, which will respond with the archived JSON file.  Here is
the new code:</p>
</div>
<div class="listingblock">
<div class="title">Rendering A Download Link When Archiving Completes</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="archive-ui" hx-target="this" hx-swap="outerHTML"&gt;
    {% if archiver.status() == "Waiting" %}
        &lt;button hx-post="/contacts/archive"&gt;
            Download Contact Archive
        &lt;/button&gt;
    {% elif archiver.status() == "Running" %}
        &lt;div hx-get="/contacts/archive" hx-trigger="load delay:500ms"&gt;
            Creating Archive...
            &lt;div class="progress" &gt;
                &lt;div class="progress-bar" style="width:{{ archiver.progress() * 100 }}%"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    {% elif archiver.status() == "Complete" %} <b class="conum">(1)</b>
        &lt;a hx-boost="false" href="/contacts/archive/file"&gt;Archive Ready!  Click here to download. &amp;downarrow;&lt;/a&gt; <b class="conum">(2)</b>
    {% endif %}
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the status is &#8220;Complete&#8221;, render a download link</p>
</li>
<li>
<p>The link will issue a <code>GET</code> to <code>/contacts/archive/file</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that the link has a <code>hx-boost</code> set to <code>false</code>.  It has this so that the link will not inherit the boost behavior
that is present for other links and, thus, will not be issued via AJAX.  We want this &#8220;normal&#8221; link behavior because an
AJAX request cannot download a file directly, whereas a plain anchor tag can.</p>
</div>
</div>
<div class="sect3">
<h4 id="_downloading_the_completed_archive">Downloading The Completed Archive</h4>
<div class="paragraph">
<p>The final step is to handle the <code>GET</code> request to <code>/contacts/archive/file</code>.  We want to send the file that the
archiver created down to the client.  We are in luck: Flask has a very simple mechanism for sending a file as
a downloaded response: the <code>send_file()</code> method.</p>
</div>
<div class="paragraph">
<p>We can pass this method the path to the archive file that the archiver
created, the name of the file that we want the browser to create, and if we want it sent &#8220;as an attachment&#8221;.
This last argument will which will tell Flask to set the  HTTP response header <code>Content-Disposition</code> to <code>attachment</code>
with the given filename, which will trigger the browsers file-downloading behavior.</p>
</div>
<div class="listingblock">
<div class="title">Sending A File To The Client</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/archive/file", methods=["GET"])
def archive_content():
    manager = Archiver.get()
    return send_file(manager.archive_file(), "archive.json", as_attachment=True) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>send the file to the client</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Perfect.  Now we have an archive UI that is very slick.  You click the &#8220;Download Contacts Archive&#8221; button and a progress
bar appears.  When the progress bar reaches 100%, it disappears and a link to download the archive file appears.  The user
can then click on that link and download their archive.  A nice, polished user experience when compared with the common
click-and-wait experience of many websites.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_smoothing_things_out_animations_in_htmx">8.3. Smoothing Things Out: Animations in htmx</h3>
<div class="paragraph">
<p>As nice as this UI is, there is one minor annoyance with it: as the progress bar updates it &#8220;jumps&#8221; from one position
to the next.  This looks jerky and is reminiscent of the feel of a full page refresh in web 1.0 style applications.  It
turns out that there is a native HTML technology for smoothing out changes on an element from one state to another
that we discussed in Chapter 5: the CSS Transitions API.</p>
</div>
<div class="paragraph">
<p>Using CSS Transitions, you can smoothly animate an element between different styling by using the <code>transition</code> property.</p>
</div>
<div class="paragraph">
<p>If you look back at our CSS definition of the <code>.progress-bar</code> class, you will see the following transition definition
in it: <code>transition: width .6s ease;</code>.  This means that when the width of the progress bar is changed from, say 20% to
30%, the browser will animate over a period of .6 seconds using the &#8220;ease&#8221; function (which has a nice accelerate/decelerate
effect).</p>
</div>
<div class="paragraph">
<p>Unfortunately that nice transition isn&#8217;t being applied in our current UI.  This is because, in our example, htmx is
<em>replacing</em> the progress bar with new one every time it polls.  It isn&#8217;t updating the width
of the <em>existing</em> element.  CSS transitions, unfortunately, only apply when the properties of an existing element change,
not when the element is replaced.  This is a reason why pure HTML-based applications can feel jerky and unpolished when compared
with their SPA counterparts: it is hard to use CSS transitions without using some JavaScript.</p>
</div>
<div class="paragraph">
<p>This is unfortunate, but htmx rectifies this situation with its swapping model.  Let&#8217;s look at how.</p>
</div>
<div class="sect3">
<h4 id="_the_settling_step_in_htmx">The &#8220;Settling&#8221; Step in htmx</h4>
<div class="paragraph">
<p>When we discussed the htmx swap model in Chapter 5, we focused on the classes that htmx adds and removes, but we skipped
over the idea of &#8220;settling&#8221;.  What is &#8220;settling&#8221; in htmx terms?  Settling is the following process:  when htmx is
about to replace a chunk of content, it looks through the new content and finds all elements with an <code>id</code> on it.  It then
looks in the <em>existing</em> content for elements with the same <code>id</code>.  If there is one, it does the following shuffle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>new</em> content gets the attributes of the <em>old</em> content temporarily</p>
</li>
<li>
<p>The new content is inserted</p>
</li>
<li>
<p>After a small delay, the new content has its attributes reverted to their actual values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, what is this strange little dance supposed to achieve?  Well, what this ends up meaning is that, if an element
has a stable id between swaps, you <em>can</em> write CSS transitions between various states.  Since the new content briefly
has the <em>old</em> attributes, the normal CSS mechanism will kick in when the actual values are restored.</p>
</div>
<div class="paragraph">
<p>So, in our case, all we need to do is to add a stable ID to our <code>progress-bar</code> element, and, rather than jumping
on every update, the progress bar should smoothly move across the screen as it is updating, using the CSS transition
defined in our style sheet:</p>
</div>
<div class="listingblock">
<div class="title">Smoothing Things Out</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="progress" &gt;
    &lt;div id="archive-progress" class="progress-bar" style="width:{{ archiver.progress() * 100 }}%"&gt;&lt;/div&gt; <b class="conum">(1)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The progress bar div now has a stable id across requests</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So, despite all the complicated mechanics going on behind the scenes in htmx, all we have to do, as an htmx user,
is add a stable <code>id</code> attribute to the element we want to animate.</p>
</div>
<div class="paragraph">
<p>With that done, voila: we get a nice, smooth progress bar as the contact archiving process proceeds.  Because of
the htmx swapping model, we get this nice animation even though we are replacing the content with new HTML.  So we get
the simplicity of the HTML-based approach, but the look and feel of a more sophisticated JavaScript-based approach.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dismissing_the_download_ui">8.4. Dismissing The Download UI</h3>
<div class="paragraph">
<p>Next, let&#8217;s make it possible for the user to dismiss the download link and return to the original export UI state.  To
do this, we&#8217;ll add a button that issues a <code>DELETE</code> to the path <code>/contacts/archive</code>, indicating that the current archive
can be removed or cleaned up.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll add it after the download link, like so:</p>
</div>
<div class="listingblock">
<div class="title">Clearing The Download</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;a hx-boost="false" href="/contacts/archive/file" _="on load click() me"&gt;Archive Ready!  Click here to download. &amp;downarrow;&lt;/a&gt;
    &lt;button hx-delete="/contacts/archive"&gt;Clear Download&lt;/button&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A simple button that issues a <code>DELETE</code> to <code>/contacts/archive</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now the user has a button that they can click on to dismiss the archive download link.  But we will need to hook it up
on the server side.  As usual, this is pretty straight forward: we simply create a new handler for the <code>DELETE</code> HTTP Action,
invoke the <code>reset()</code> method on the archiver, and re-render the <code>archive_ui.html</code> template.</p>
</div>
<div class="paragraph">
<p>Since this button is picking up the same <code>hx-target</code> and <code>hx-swap</code> configuration as everything else, it &#8220;just works&#8221;.</p>
</div>
<div class="paragraph">
<p>Here is the server-side code:</p>
</div>
<div class="listingblock">
<div class="title">Resetting The Download</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/contacts/archive", methods=["DELETE"])
def reset_archive():
    archiver = Archiver.get()
    archiver.reset() <b class="conum">(1)</b>
    return render_template("archive_ui.html", archiver=archiver)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Call <code>reset()</code> on the archiver</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This looks pretty similar to our other handlers, doesn&#8217;t it?  Yep, that&#8217;s the idea.</p>
</div>
</div>
<div class="sect2">
<h3 id="_an_alternative_ux_auto_download">8.5. An Alternative UX: Auto-Download</h3>
<div class="paragraph">
<p>While we prefer the current user experience for archiving contacts, where a progress bar shows the progress of
the process and, when it completes, the user is presented with a link to actually download the file, there are other
alternatives to it.  Another pattern that we see on the web is "auto-downloading", where the file downloads immediately
without the user needing to click a link.</p>
</div>
<div class="paragraph">
<p>We can add this functionality quite easily to our application with just a bit of scripting.  We will discuss scripting
in a Hypermedia-Driven Application in more depth in a few chapters, but as a quick introduction: scripting is perfectly
acceptable in an HDA, as long as it doesn&#8217;t replace the core hypermedia mechanics of the application.</p>
</div>
<div class="paragraph">
<p>For our auto-download feature we will use <a href="https://hyperscript.org">_hyperscript</a> , our preferred scripting option, but the
equivalent JavaScript would be nearly as simple.</p>
</div>
<div class="paragraph">
<p>All we need to do to implement the auto-download feature is the following: when the download link renders,
 automatically click on the link for the user.</p>
</div>
<div class="paragraph">
<p>The _hyperscript code reads almost the same as the previous sentence (which is why we love hyperscript):</p>
</div>
<div class="listingblock">
<div class="title">Auto-Downloading</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">  &lt;a hx-boost="false" href="/contacts/archive/file"
     _="on load click() me"&gt; <b class="conum">(1)</b>
    Archive Downloading!  Click here if the download does not start.
  &lt;/a&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a bit of _hyperscript to make the file auto-download</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Have we mentioned that we love _hyperscript?</p>
</div>
<div class="paragraph">
<p>Crucially, the scripting here is simply <em>enhancing</em> the existing hypermedia, rather than replacing it with
a non-hypermedia request.  This is hypermedia-friendly scripting, as we will cover in more depth in a bit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_dynamic_archive_ui_complete">8.6. A Dynamic Archive UI: Complete</h3>
<div class="paragraph">
<p>In this chapter we&#8217;ve managed to create a very dynamic UI for our contact archive functionality, with a progress bar and
auto-downloading, and we&#8217;ve done nearly all of it (with the exception of a small bit of scripting for auto-download) in
pure hypermedia. And it only took about 16 lines of front end code and 16 lines of backend code to build the whole thing.</p>
</div>
<div class="paragraph">
<p>This shows once again that HTML, with a bit of help from htmx, can in fact be extremely powerful and expressive.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tricks_of_the_htmx_masters">9. Tricks Of The htmx Masters</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_advanced_htmx">Advanced htmx</h3>
<div class="paragraph">
<p>In this chapter we are going to look more deeply into htmx.  We&#8217;ve accomplished quite a bit with what we&#8217;ve learned
so far, but, when you are developing Hypermedia-Driven Applications, there are likely to be situations that arise
that require additional functionality to address cleanly.</p>
</div>
<div class="paragraph">
<p>We will go over some of the more advanced attributes in htmx, as well as expand on the advanced details of some attributes we
have already used.</p>
</div>
<div class="paragraph">
<p>Additionally, we will look at functionality that htmx offers beyond simple HTML attributes:  how htmx extends
standard HTTP request and responses, how htmx works with (and produces) events, and how to approach situations where
there isn&#8217;t a simple, single target on the page to be updated.</p>
</div>
<div class="paragraph">
<p>Finally, we will take a look at practical considerations when doing htmx development: how to debug htmx-based applications
effectively, security considerations you will need to take into account when working with htmx, and how to configure
the behavior of htmx.</p>
</div>
<div class="paragraph">
<p>By understanding all the features and techniques in this chapter, you will be able to pull off extremely
sophisticated user interfaces using only htmx and perhaps a small bit of hypermedia-friendly client-side scripting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_htmx_attributes">9.1. htmx Attributes</h3>
<div class="paragraph">
<p>Thus far we have used about fifteen different attributes from htmx in our application.  The most important ones
have been:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hx-get</code>, <code>hx-post</code>, etc.</dt>
<dd>
<p>To specify the AJAX request an element should make</p>
</dd>
<dt class="hdlist1"><code>hx-trigger</code></dt>
<dd>
<p>To specify the event that triggers a request</p>
</dd>
<dt class="hdlist1"><code>hx-swap</code></dt>
<dd>
<p>To specify how to swap the returned HTML content into the DOM</p>
</dd>
<dt class="hdlist1"><code>hx-target</code></dt>
<dd>
<p>To specify where in the DOM to swap the returned HTML content</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Let&#8217;s do a deep dive on two of these attributes, <code>hx-swap</code> and <code>hx-trigger</code>, because they support a large number of
options that might be useful when you are creating more advanced Hypermedia Driven Applications.</p>
</div>
<div class="sect3">
<h4 id="_hx_swap"><code>hx-swap</code></h4>
<div class="paragraph">
<p>The <code>hx-swap</code> attribute is often not included on elements that issue htmx-driven requests.  This is because, for many
cases, the default behavior, <code>innerHTML</code>, which swaps the inner HTML of the element, is fine.  Of course, we have seen
cases where we wanted to override this behavior and use <code>outerHTML</code>, for example.  And, in chapter 3, we discussed some
other swap options beyond these two, <code>beforebegin</code>, <code>afterend</code>, etc.</p>
</div>
<div class="paragraph">
<p>In chapter 6, we also looked at the <code>swap</code> delay modifier for <code>hx-swap</code>, which allowed us to fade some content out before
it was removed from the DOM.</p>
</div>
<div class="paragraph">
<p>In addition to these, <code>hx-swap</code> also supports the following modifiers:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>settle</code></dt>
<dd>
<p>Like <code>swap</code>, this allows you to apply a specific delay between when the content has been swapped into the DOM and
  when its attributes are &#8220;settled&#8221;, that is, updated from their old values (if any) to their new values.</p>
</dd>
<dt class="hdlist1"><code>show</code></dt>
<dd>
<p>Allows you to specify an element that should be shown (that is, scrolled into the viewport of the browser if necessary)
 when a request is completed</p>
</dd>
<dt class="hdlist1"><code>scroll</code></dt>
<dd>
<p>Allows you to specify a scrollable element (that is, an element with scrollbars), that should be scrolled to the top
  or bottom when a request is completed</p>
</dd>
<dt class="hdlist1"><code>focus-scroll</code></dt>
<dd>
<p>Allows you to specify that htmx should scroll to the focused element when a request completes.  (This defaults to
  false)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>So, for example, if we had a button that issued a <code>GET</code> request, and we wished to scroll to the top of the <code>body</code> element
when the request had completed, we would write the following HTML:</p>
</div>
<div class="listingblock">
<div class="title">Scrolling To The Top Of The Page</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-target="#content-div"
        hx-swap="innerHTML show:body:top"&gt; <b class="conum">(1)</b>
  Get Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This tells htmx to show the top of the body after the swap occurs</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>More details and examples can be found online in the <code>hx-swap</code> <a href="https://htmx.org/attributes/hx-swap/">documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hx_trigger"><code>hx-trigger</code></h4>
<div class="paragraph">
<p>Like <code>hx-swap</code>, <code>hx-trigger</code> can often be omitted when you are using htmx, because the default behavior is typically
what you want anyway.  Recall the default triggering events are determined by an element&#8217;s type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Requests on <code>input</code>, <code>textarea</code> &amp; <code>select</code> elements are triggered by the <code>change</code> event</p>
</li>
<li>
<p>Requests on <code>form</code> elements are triggered on the <code>submit</code> event</p>
</li>
<li>
<p>Requests on all other elements are triggered by the <code>click</code> event</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are times, however, when you want a more elaborate trigger specification.  A classic example was the active
search example we implemented in Contact.app:</p>
</div>
<div class="listingblock">
<div class="title">The Active Search Input</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">    &lt;input id="search" type="search" name="q" value="{{ request.args.get('q') or '' }}"
           hx-get="/contacts"
           hx-trigger="search, keyup delay:200ms changed"/&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An elaborate trigger specification</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This example took advantage of two modifiers available for the <code>hx-trigger</code> attribute:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>delay</code></dt>
<dd>
<p>Allows you to specify a delay to wait before a request is issued.  If the event occurs again, the first event is
  discarded and the timer resets.  This allows you to &#8220;debounce&#8221; requests.</p>
</dd>
<dt class="hdlist1"><code>changed</code></dt>
<dd>
<p>Allows you to specify that a request should only be issued when the <code>value</code> property of the given element has changed</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>hx-trigger</code> has quite a few additional modifiers.  This makes sense, because events are fairly complex and we want to
be able to take advantage of all the power they offer.  (We will discuss events in more detail below.)</p>
</div>
<div class="paragraph">
<p>Here are the other modifiers available on <code>hx-trigger</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>once</code></dt>
<dd>
<p>The given event will only trigger a request once</p>
</dd>
<dt class="hdlist1"><code>throttle</code></dt>
<dd>
<p>Allows you to throttle events, only issuing them once every certain interval.  This is different than <code>delay</code> in that
the first event will trigger immediately, but any following events will not trigger until the throttle time period
has elapsed</p>
</dd>
<dt class="hdlist1"><code>from</code></dt>
<dd>
<p>A CSS selector that allows you to pick another element to listen for events on.  We will see an example of this used
later in the chapter.</p>
</dd>
<dt class="hdlist1"><code>target</code></dt>
<dd>
<p>A CSS selector that allows you to filter events to only those that occur directly on a given element.  In the DOM,
events &#8220;bubble&#8221; to their parent elements, so a <code>click</code> event on a button will also trigger a <code>click</code> event on a parent
<code>div</code>, all the way up to the <code>body</code> element.  Sometimes you want to specify an event directly on a given element, and
this attribute allows you to do that.</p>
</dd>
<dt class="hdlist1"><code>consume</code></dt>
<dd>
<p>If this option is set to <code>true</code>, the triggering event will be cancelled and not propagate to parent elements.</p>
</dd>
<dt class="hdlist1"><code>queue</code></dt>
<dd>
<p>This option allows you to specify how events are queued in htmx.  By default, when htmx receives a triggering event,
it will issue a request and start an event queue.  If the request is still in flight when another event is received,
it will queue the event and, when the request finishes, trigger a new request.  By default, it only keeps the last
event it receives, but you can modify that behavior using this option: for example, you can set it to <code>none</code> and ignore
all triggering events that occur during a request.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="_filters">Filters</h5>
<div class="paragraph">
<p>The <code>hx-trigger</code> attribute allows you to specify a <em>filter</em> for events by using square brackets enclosing a JavaScript
expression after the event name.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you have a complex situation where contacts should only be retrievable in certain situations, and you have
a JavaScript function, <code>contactRetrievalEnabled()</code> that returns a boolean, <code>true</code> if contacts can be retrieved and
<code>false</code> otherwise.  You want to gate a button that issues a request to <code>/contacts</code> on this function.  To do this using
an event filter in htmx, you would write the following HTML:</p>
</div>
<div class="listingblock">
<div class="title">The Active Search Input</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;script&gt;
  function contactRetrievalEnabled() {
      // code to test if contact retrieval is enabled
      ...
  }
&lt;/script&gt;
&lt;button hx-get="/contacts" hx-trigger="click[contactRetrievalEnabled()]"&gt; <b class="conum">(1)</b>
  Get Contacts
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A request is issued on click only when <code>contactRetrievalEnabled()</code> returns <code>true</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The button will not issue a request if <code>contactRetrievalEnabled()</code> returns false, allowing you to dynamically control
when the request will be made.  Common situations that call for an event trigger are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only issue a request when a certain element has focus</p>
</li>
<li>
<p>Only issue a request when a given form is valid</p>
</li>
<li>
<p>Only issue a request when a set of inputs have specific values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using event filters, you can use whatever logic you&#8217;d like to filter requests by htmx.</p>
</div>
</div>
<div class="sect4">
<h5 id="_synthetic_events">Synthetic Events</h5>
<div class="paragraph">
<p>In addition to these modifiers, <code>hx-trigger</code> offers a few &#8220;synthetic&#8221; events, that is events that are not part of the
regular DOM API.  We have already seen <code>load</code> and <code>revealed</code> in our lazy loading and infinite scroll examples, but
htmx also gives you an <code>intersect</code> event that triggers when an element intersects its parent element.</p>
</div>
<div class="paragraph">
<p>This synthetic event uses the modern Intersection Observer API, which you can read more about
at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">MDN</a>.</p>
</div>
<div class="paragraph">
<p>Intersection gives you fine grained control over exactly when a request should be triggered.  For example, you can
set a threshold and specify that the request be issued only when an element is 50% visible.</p>
</div>
<div class="paragraph">
<p>The <code>hx-trigger</code> attribute certainly is the most complex in htmx. More details and examples can be found in its <a href="https://htmx.org/attributes/hx-trigger/">documentation</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_attributes">Other Attributes</h4>
<div class="paragraph">
<p>Htmx offers many other less commonly used attributes for fine-tuning the behavior of your Hypermedia Driven Application.</p>
</div>
<div class="paragraph">
<p>Here are some of the most useful ones:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">hx-push-url</dt>
<dd>
<p>&#8220;Pushes&#8221; the request URL (or some other value) into the navigation bar</p>
</dd>
<dt class="hdlist1">hx-preserve</dt>
<dd>
<p>Preserves a bit of the DOM between requests (the original content will be kept, regardless of what is returned)</p>
</dd>
<dt class="hdlist1">hx-sync</dt>
<dd>
<p>Synchronized requests between two or more elements</p>
</dd>
<dt class="hdlist1">hx-disable</dt>
<dd>
<p>Disables htmx behavior on this element and any children.  We will discuss this more below in the security section.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at <code>hx-sync</code>, which allows us to synchronize AJAX requests between two or more elements.  Consider
a simple case where we have two buttons that both target the same element on the screen:</p>
</div>
<div class="listingblock">
<div class="title">Two Competing Buttons</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button hx-get="/contacts" hx-target="body"&gt; <b class="conum">(1)</b>
  Get Contacts
&lt;/button&gt;
&lt;button hx-get="/settings" hx-target="body"&gt; <b class="conum">(1)</b>
  Get Settings
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is fine and will work, but what if a user clicks the &#8220;Get Contacts&#8221; button and then the request takes a while to
respond?  And, in the meantime the user clicks the &#8220;Get Settings&#8221; button?  In this case we would have two requests in
flight at the same time.</p>
</div>
<div class="paragraph">
<p>If the <code>/settings</code> request finished first and displayed the user&#8217;s setting information, they might be very surprised
if they began making changes and then, suddenly, the <code>/contacts</code> request finished and replaced the entire body with
the contacts instead!</p>
</div>
<div class="paragraph">
<p>To deal with this situation, we might consider using an <code>hx-indicator</code> to alert the user that something is going on, making
it less likely that they click the second button.  But if we really want to guarantee that there is only one request
at a time issued between these two buttons, the right thing to do is to use the <code>hx-sync</code> attribute.  Let&#8217;s enclose
both buttons in a <code>div</code> and eliminate the redundant <code>hx-target</code> specification by hoisting the attribute up to that
<code>div</code>.  We can then use <code>hx-sync</code> on that div to coordinate requests between the two buttons.</p>
</div>
<div class="paragraph">
<p>Here is our updated code:</p>
</div>
<div class="listingblock">
<div class="title">Syncing Two Buttons</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div hx-target="body"  <b class="conum">(1)</b>
     hx-sync="this"&gt;  <b class="conum">(2)</b>
    &lt;button hx-get="/contacts"&gt; <b class="conum">(1)</b>
      Get Contacts
    &lt;/button&gt;
    &lt;button hx-get="/settings"&gt; <b class="conum">(1)</b>
      Get Settings
    &lt;/button&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Hoist the duplicate <code>hx-target</code> attributes to the parent <code>div</code></p>
</li>
<li>
<p>Synchronize on the parent <code>div</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By placing the <code>hx-sync</code> attribute on the <code>div</code> with the value <code>this</code>, we are saying &#8220;Synchronize all htmx requests that
occur within this <code>div</code> element with one another.&#8221;  This means that if one button already has a request in flight, other
buttons within the <code>div</code> will not issue requests until that has finished.</p>
</div>
<div class="paragraph">
<p>The <code>hx-sync</code> attribute supports a few different strategies that allow you to, for example, replace an existing request
in flight, or queue requests with a particular queuing strategy.  You can find complete documentation, as well as
examples, at the <a href="https://htmx.org/attributes/hx-sync/">documentation page</a> for <code>hx-sync</code>.</p>
</div>
<div class="paragraph">
<p>As you can see, htmx offers a lot of attribute-driven functionality for more advanced Hypermedia Driven Applications.
A complete reference for all htmx attributes can be found <a href="https://htmx.org/reference/#attributes">on the htmx website</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_events">9.2. Events</h3>
<div class="paragraph">
<p>We have been working with JavaScript events in htmx primarily via the <code>hx-trigger</code> attribute.  This simple (well, not
so simple) attribute has proven to be a powerful mechanism for driving our application using a declarative, HTML-friendly
syntax.</p>
</div>
<div class="paragraph">
<p>Events turn out to be a crucial component of both the extension of HTML as a hypermedia, as well as a crucial component
of hypermedia-friendly scripting.  Events are the &#8220;glue&#8221; that brings the DOM, HTML, htmx and scripting together, with the
DOM acting as a sophisticated "event bus" for our application.  We really can&#8217;t stress how important Events are for
building an advanced Hypermedia-Driven Application, and we encourage you to learn them
<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events">in depth</a>.</p>
</div>
<div class="sect3">
<h4 id="_htmx_generated_events">htmx-generated Events</h4>
<div class="paragraph">
<p>In addition to making it easy to <em>respond</em> to events, htmx also <em>emits</em> many useful events.  You
can use these events to add more functionality to your application, either via htmx itself, or by way of scripting.</p>
</div>
<div class="paragraph">
<p>Here are some of the most commonly used events in htmx:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>htmx:load</code></dt>
<dd>
<p>Triggered when new content is loaded into the DOM by htmx</p>
</dd>
<dt class="hdlist1"><code>htmx:configRequest</code></dt>
<dd>
<p>Triggered before a request is issued, allowing you to programmatically configure the request (or cancel it entirely)</p>
</dd>
<dt class="hdlist1"><code>htmx:afterRequest</code></dt>
<dd>
<p>Triggered after a request has responded</p>
</dd>
<dt class="hdlist1"><code>htmx:abort</code></dt>
<dd>
<p>A custom event that can be sent to an htmx-powered element to abort an open request</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_htmxconfigrequest_event">Using The <code>htmx:configRequest</code> Event</h4>
<div class="paragraph">
<p>Let&#8217;s take a look at how you might use the <code>htmx:configRequest</code> event to configure an HTTP request.  Consider the following
scenario: your server-side team has decided that they want you to include a token for extra validation on every request.
The token is going to be stored in <code>localStorage</code> in the browser, in the slot <code>special-token</code>.  The server-side team
wants you to include this special token on every request made by htmx, as the <code>X-SPECIAL-TOKEN</code> header.</p>
</div>
<div class="paragraph">
<p>How could you achieve this?  One way would be to catch the <code>htmx:configRequest</code> event and update the <code>detail.headers</code>
object with this token from <code>localStorage</code>.</p>
</div>
<div class="paragraph">
<p>In VanillaJS, it would look something like this:</p>
</div>
<div class="listingblock">
<div class="title">Adding the <code>X-SPECIAL-TOKEN</code> Header</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">document.body.addEventListener("htmx:configRequest", function(configEvent){
    configEvent.detail.headers['X-SPECIAL-TOKEN'] = localStorage['special-token']; <b class="conum">(1)</b>
})</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>retrieve the value from local storage and set it into a header</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, we add a new value to the <code>headers</code> property of the event&#8217;s detail.  After the event handler executes,
the <code>headers</code> property is read by htmx and used to construct the headers for an AJAX request.  So, with this bit of
JavaScript code, we have added a new custom header to every AJAX request that htmx makes.  Slick!</p>
</div>
<div class="paragraph">
<p>You can also update the <code>parameters</code> property to change the parameters submitted by the request, change the target
of the request, and so on.</p>
</div>
<div class="paragraph">
<p>Full documentation for the <code>htmx:configRequest</code> event can be found
<a href="https://htmx.org/events/#htmx:configRequest">on the htmx website</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_canceling_a_request_using_htmxabort">Canceling a Request using <code>htmx:abort</code></h4>
<div class="paragraph">
<p>We can listen for any of the many useful events from htmx, and we can respond to those events using <code>hx-trigger</code>.  What
else can we do with events?</p>
</div>
<div class="paragraph">
<p>It turns out that htmx itself listens for one special event, <code>htmx:abort</code>.  When htmx receives this
event on an element that has a request in flight, it will abort the request.</p>
</div>
<div class="paragraph">
<p>Consider a situation where we have a potentially long-running request to <code>/contacts</code>, and we want to offer a way for
the users to cancel the request.  What we want is a button that issues the request, driven by htmx, of course, and then
another button that will send an <code>htmx:abort</code> event to the first one.</p>
</div>
<div class="paragraph">
<p>Here is what the code might look like:</p>
</div>
<div class="listingblock">
<div class="title">A Button With An Abort</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button id="contacts-btn" hx-get="/contacts" hx-target="body"&gt; <b class="conum">(1)</b>
  Get Contacts
&lt;/button&gt;
&lt;button onclick="document.getElementById('contacts-btn').dispatchEvent(new Event('htmx:abort'))"&gt; <b class="conum">(2)</b>
  Cancel
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A normal htmx-driven <code>GET</code> request to <code>/contacts</code></p>
</li>
<li>
<p>JavaScript to look up the button and send it an <code>htxm:abort</code> event</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So now, if a user clicks on the &#8220;Get Contacts&#8221; button and the request takes a while, they can click on the &#8220;Cancel&#8221;
button and end the request.  Of course, in a more sophisticated user interface, you may want to disable the &#8220;Cancel&#8221;
button unless an HTTP request is in flight, but that would be a pain to implement in pure JavaScript.</p>
</div>
<div class="paragraph">
<p>Thankfully it isn&#8217;t too bad to implement in hyperscript, so let&#8217;s take a look at what that would look like:</p>
</div>
<div class="listingblock">
<div class="title">A hyperscript-Powered Button With An Abort</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button id="contacts-btn" hx-get="/contacts" hx-target="body"&gt;
  Get Contacts
&lt;/button&gt;
&lt;button _="on click send htmx:abort to #contacts-btn
           on htmx:beforeRequest from #contacts-btn remove @disabled from me
           on htmx:afterRequest from #contacts-btn add @disabled to me"&gt;
  Cancel
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have a &#8220;Cancel&#8221; button that is disabled only when a request from the <code>contacts-btn</code> button is in flight.  And
we are taking advantage of htmx-generated and handled events, as well as the event-friendly syntax of hyperscript, to
make it happen.  Not bad!</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_generated_events">Server Generated Events</h4>
<div class="paragraph">
<p>We are going to talk more about the various ways that htmx enhances regular HTTP requests and responses in the next section,
but, since it involves events, we are going to discuss one HTTP Response header that htmx supports: <code>HX-Trigger</code>.  We
have discussed before how HTTP requests and responses support <em>headers</em>, name-value pairs that contain metadata about
a given request or response.  We took advantage of the <code>HX-Trigger</code> request header, which includes the id of the element
that triggered a given request.</p>
</div>
<div class="paragraph">
<p>In addition to this <em>request header</em>, htmx also supports a <em>response header</em> also named <code>HX-Trigger</code>.  This response header
allows you to <em>trigger an event</em> on the element that submitted an AJAX request.  This turns out to be a powerful way
to coordinate elements in the DOM in a decoupled manner.</p>
</div>
<div class="paragraph">
<p>To see how this might work, let&#8217;s consider the following situation: we have a button that grabs new contacts from some
remote system on the server.  We will ignore the details of the server-side implementation, but we know that if we issue
a <code>POST</code> to the <code>/integrations/1</code> path, it will trigger a synchronization with the system.</p>
</div>
<div class="paragraph">
<p>Now, this synchronization may or may not result in new contacts being created.  In the case where new contacts <em>are</em>
created, we want to refresh our contacts table.  In the case where no contacts are created, we don&#8217;t want to refresh
the table.</p>
</div>
<div class="paragraph">
<p>How could we implement this using the <code>HX-Trigger</code> response header?  Well, we could conditionally add an <code>HX-Trigger</code>
response header with the value <code>contacts-updated</code>, which would trigger the <code>contacts-updated</code> event on the button that
made the AJAX request to <code>/integrations/1</code>.  And we can then take advantage of the <code>from:</code> modifier of the <code>hx-trigger</code>
attribute to listen for that event.  Now we can effectively trigger htmx requests from the server side.</p>
</div>
<div class="paragraph">
<p>Here is what the client-side code might look like:</p>
</div>
<div class="listingblock">
<div class="title">The Contacts Table</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">   &lt;button hx-post="/integrations/1"&gt; <b class="conum">(1)</b>
     Pull Contacts From Integration
   &lt;/button&gt;

      ...

    &lt;table hx-get="/contacts/table" hx-trigger="contacts-updated from:body"&gt; <b class="conum">(2)</b>
      ...
    &lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The response to this request may conditionally trigger the <code>contacts-updated</code> event</p>
</li>
<li>
<p>This table listens for the event and refreshes when it occurs</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The table listens for the <code>contacts-updated</code> event, and it does so on the <code>body</code> element.  It listens on the <code>body</code>
element since the event will bubble up from the button, and this allows us to not couple the button and table together:
we can move the button and table around as we like and, via events, the behavior we want will continue to work fine.
Additionally, we may want <em>other</em> elements or requests to trigger the <code>contacts-updated</code> event, so this provides a
general mechanism for refreshing the contacts table in our application.</p>
</div>
<div class="paragraph">
<p>We are omitting the server-side implementation of this feature in the interest of simplicity, but this gives you
an idea of how the <code>HX-Trigger</code> response header can be used to coordinate sophisticated interactions in the DOM.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_requests_responses">9.3. HTTP Requests &amp; Responses</h3>
<div class="paragraph">
<p>We have just seen an advanced feature of HTTP responses supported by htmx, the <code>HX-Trigger</code> response header,
but htmx supports quite a few more headers for both requests and responses.  In chapter 5 we discussed the
headers present in HTTP Requests.  Here are some of the more important headers you can use to change htmx behavior with
HTTP responses:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>HX-Location</code></dt>
<dd>
<p>Causes a client-side redirection to a new location</p>
</dd>
<dt class="hdlist1"><code>HX-Push-Url</code></dt>
<dd>
<p>Pushes a new URL into the location bar</p>
</dd>
<dt class="hdlist1"><code>HX-Refresh</code></dt>
<dd>
<p>Refreshes the current page</p>
</dd>
<dt class="hdlist1"><code>HX-Retarget</code></dt>
<dd>
<p>Allows you to specify a new target to swap the response content into on the client side</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can find a reference for all requests and response headers in the <a href="https://htmx.org/reference/#headers">htmx documentation</a>.</p>
</div>
<div class="sect3">
<h4 id="_http_response_codes_2">HTTP Response Codes</h4>
<div class="paragraph">
<p>Even more important than response headers, in terms of information conveyed to the client, is the <em>HTTP Response Code</em>.
We discussed HTTP Response Codes in Chapter 4.  By and large htmx handles various response codes in the manner that
you would expect: it swaps content for all 200-level response codes and does nothing for others.  There are, however,
two &#8220;special&#8221; 200-level response codes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>204 No Content</code> - When htmx receives this response code, it will <em>not</em> swap any content into the DOM (even if the response
has a body)</p>
</li>
<li>
<p><code>286</code> - When htmx receives this response code to a request that is polling, it will stop the polling</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can override the behavior of htmx with respect to response codes by, you guessed it, responding to an event!  The
<code>htmx:beforeSwap</code> event allows you to change the behavior of htmx with respect to various status codes.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that, rather than doing nothing when a <code>404</code> occurred, you wanted to alert the user that an error had occurred.
To do so, you want to invoke a JavaScript method, <code>showNotFoundError()</code>.  Let&#8217;s add some code to use the <code>htmx:beforeSwap</code>
event to make this happen:</p>
</div>
<div class="listingblock">
<div class="title">Showing a 404 Dialog</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">document.body.addEventListener('htmx:beforeSwap', function(evt) { <b class="conum">(1)</b>
    if(evt.detail.xhr.status === 404){ <b class="conum">(2)</b>
        showNotFoundError();
    }
});</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>hook into the <code>htmx:beforeSwap</code> event</p>
</li>
<li>
<p>if the response code is a <code>404</code>, show the user a dialog</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can also use the <code>htmx:beforeSwap</code> event to configure if the response should be swapped into the DOM and what element
the response should target.  This gives you quite a bit of flexibility in choosing how you want to use HTTP Response
codes in your application.  Full documentation on the <code>htmx:beforeSwap</code> event can be found at <a href="https://htmx.org/events/#htmx:beforeSwap">htmx.org</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_updating_other_content">9.4. Updating Other Content</h3>
<div class="paragraph">
<p>Above we saw how to use a server-triggered event, via the <code>HX-Trigger</code> HTTP response header, to update a piece of the
DOM based on the response to another part of the DOM.  This technique addresses the general problem that comes up
in Hypermedia Driven Applications: &#8220;How do I update other content?&#8221;  After all, in normal HTTP requests, there is only
one &#8220;target&#8221;, the entire screen, and, similarly, in htmx-based requests, there is only one target: either the explicit
or implicit target of the element.</p>
</div>
<div class="paragraph">
<p>If you want to update other content in htmx, you have a few options:</p>
</div>
<div class="sect3">
<h4 id="_expanding_your_selection">Expanding Your Selection</h4>
<div class="paragraph">
<p>The first option, and the simplest, is to &#8220;expand the target&#8221;.  That is, rather than simply replacing a small part
of the screen, expand the target of your htmx-driven request until it is large enough to enclose all the elements that
need to updated on a screen.  This has the tremendous advantage of being simple and reliable.  The downside is that
it may not provide the user experience that you want, and it may not play well with a particular server-side template
layout.  Regardless, we always recommend at least thinking about this approach first.</p>
</div>
</div>
<div class="sect3">
<h4 id="_out_of_band_swaps">Out of Band Swaps</h4>
<div class="paragraph">
<p>A second option, which is a bit more complex, is to take advantage of &#8220;Out Of Band&#8221; content support in htmx.  When
htmx receives a response, it will look for top-level content in that response that includes the <code>hx-swap-oob</code> attribute
on it.  That content will be removed from the response, so it will not be swapped into the DOM in the normal manner.  Instead,
it will be swapped in for the content that it matches, by its id.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example of this approach.  Let&#8217;s consider the situation we had above, where a contacts table needs to be updated
conditionally, based on if an integration pulls down any new contacts.  Previously we solved this by using events and
a server-triggered event via the <code>HX-Trigger</code> response header.</p>
</div>
<div class="paragraph">
<p>In this case, instead of using an event, let&#8217;s take advantage of the <code>hx-swap-oob</code> attribute in the response to the
<code>POST</code> to <code>/integrations/1</code> to &#8220;piggy back&#8221; the new contacts table content on the response.</p>
</div>
<div class="listingblock">
<div class="title">The Updated Contacts Table</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">   &lt;button hx-post="/integrations/1"&gt; <b class="conum">(1)</b>
     Pull Contacts From Integration
   &lt;/button&gt;

      ...

    &lt;table id="contacts-table"&gt; <b class="conum">(2)</b>
      ...
    &lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the button still issues a <code>POST</code> to <code>/integrations/1</code></p>
</li>
<li>
<p>the table no longer listens for an event, but it now has an id</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at a potential response to the <code>POST</code> to <code>/integrations/1</code>. This response will include the &#8220;regular&#8221;
content that needs to be swapped into the button, per the usual htmx mechanism.  But it will also include a new,
updated version of the contacts table, which will be marked as <code>hx-swap-oob="true"</code>.  This content will be removed from
the response, so it is not inserted into the button but will be instead swapped into the DOM in place of the existing
table since it has the same id value.</p>
</div>
<div class="listingblock">
<div class="title">A Response With Out-of-Band Content</div>
<div class="content">
<pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
...

Pull Contacts From Integration <b class="conum">(1)</b>

&lt;table id="contacts-table" hx-swap-oob="true"&gt; <b class="conum">(2)</b>
  ...
&lt;/table&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>this content will be placed in the button</p>
</li>
<li>
<p>this content will be removed from the response and swapped by id</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using this technique, you are able to piggyback content updates of other elements on top of requests by other elements.
The <code>hx-swap-oob</code> attribute supports other additional features, all of which are <a href="https://htmx.org/attributes/hx-swap-oob/">documented</a>.</p>
</div>
<div class="paragraph">
<p>Depending on how exactly your server-side templating technology works, and what level of interactivity your application
requires, out of band swapping can be a powerful mechanism for more flexible content updates.</p>
</div>
</div>
<div class="sect3">
<h4 id="_events_2">Events</h4>
<div class="paragraph">
<p>Finally, the most complex mechanism for updating content is the one we saw back in the events section: using server-triggered
events to update elements.  This approach can be very clean, but also requires a lot deeper conceptual knowledge of HTML
and events, and a commitment to the event-driven approach.  While we like this style of development, it isn&#8217;t for everyone
and we typically recommend this only if the htmx philosophy of event-driven hypermedia really speaks to you.</p>
</div>
<div class="paragraph">
<p>If it <em>does</em> speak to you, however, we say: go for it.  We&#8217;ve created some very complex and flexible user interfaces using
this approach, and we are quite fond of it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_being_pragmatic">Being Pragmatic</h4>
<div class="paragraph">
<p>All of these approaches to the &#8220;Updating Other Content&#8221; problem will work, and will often work well.  However, there may
come a point where it would just be simpler to use a different approach, like the reactive one.  As much as we like
the hypermedia approach, the reality is that there are some UX patterns that simply cannot be implemented
easily using it.  The canonical example of this sort of pattern, which we have mentioned before, is something like a live
online spreadsheet: it is simply too complex a user interface, with too many inter-dependencies, to be done well via
exchanges of hypermedia with a server.</p>
</div>
<div class="paragraph">
<p>In cases like this, and any time you feel like an htmx-based solution is proving to be more complex than another approach
might be, we can gladly recommend that you consider a different technology: use the right tool for the job!  You can always
use htmx for the parts of your application that aren&#8217;t as complex and don&#8217;t need the full complexity of a reactive framework,
and save that complexity budget for the parts that do.</p>
</div>
<div class="paragraph">
<p>We are not hypermedia puritans and encourage you to learn many different web technologies, with an eye to the strengths
and weaknesses of each one.  This will give you a deep tool chest to reach into when problems present themselves. Our
hope is that, with htmx, hypermedia might be a tool you reach for more frequently!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging">9.5. Debugging</h3>
<div class="paragraph">
<p>We have been talking a lot about events in this chapter and we are not ashamed to admit: we are big fans of events.  They
are the underlying technology of almost any interesting user interface, and are particularly useful in the DOM once they
have been unlocked for general use in HTML.  They let you build nicely decoupled software while often preserving
the locality of behavior we like so much.</p>
</div>
<div class="paragraph">
<p>However, events are not perfect.  One area where events can be particularly tricky to deal with is <em>debugging</em>: you
often want to know why an event <em>isn&#8217;t</em> happening.  But where can you set a break point for something that <em>isn&#8217;t</em> happening?
The answer, as of right now, is: you can&#8217;t.</p>
</div>
<div class="paragraph">
<p>There are two techniques that can help in this regard, one provided by htmx, the other provided by Chrome, the browser
by Google.</p>
</div>
<div class="sect3">
<h4 id="_logging_htmx_events">Logging htmx Events</h4>
<div class="paragraph">
<p>The first technique, provided by htmx itself, is to call the <code>htmx.logAll()</code> method.  When you do this, htmx will log
all the internal events that occur as it goes about its business, loading up content, responding to events and so forth.</p>
</div>
<div class="paragraph">
<p>This can be overwhelming, but with judicious filtering can help you zero in on a problem.  Here are what (a bit of) the logs
look like when clicking on the &#8220;docs&#8221; link on <a href="https://htmx.org" class="bare">https://htmx.org</a>, with <code>logAll()</code> enabled:</p>
</div>
<div class="listingblock">
<div class="title">htmx Logs</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">htmx:configRequest
&lt;a href="/docs/"&gt;
Object { parameters: {}, unfilteredParameters: {}, headers: {…}, target: body, verb: "get", errors: [], withCredentials: false, timeout: 0, path: "/docs/", triggeringEvent: a
, … }
htmx.js:439:29
htmx:beforeRequest
&lt;a href="/docs/"&gt;
Object { xhr: XMLHttpRequest, target: body, requestConfig: {…}, etc: {}, pathInfo: {…}, elt: a
 }
htmx.js:439:29
htmx:beforeSend
&lt;a class="htmx-request" href="/docs/"&gt;
Object { xhr: XMLHttpRequest, target: body, requestConfig: {…}, etc: {}, pathInfo: {…}, elt: a.htmx-request
 }
htmx.js:439:29
htmx:xhr:loadstart
&lt;a class="htmx-request" href="/docs/"&gt;
Object { lengthComputable: false, loaded: 0, total: 0, elt: a.htmx-request
 }
htmx.js:439:29
htmx:xhr:progress
&lt;a class="htmx-request" href="/docs/"&gt;
Object { lengthComputable: true, loaded: 4096, total: 19915, elt: a.htmx-request
 }
htmx.js:439:29
htmx:xhr:progress
&lt;a class="htmx-request" href="/docs/"&gt;
Object { lengthComputable: true, loaded: 19915, total: 19915, elt: a.htmx-request
 }
htmx.js:439:29
htmx:beforeOnLoad
&lt;a class="htmx-request" href="/docs/"&gt;
Object { xhr: XMLHttpRequest, target: body, requestConfig: {…}, etc: {}, pathInfo: {…}, elt: a.htmx-request
 }
htmx.js:439:29
htmx:beforeSwap
&lt;body hx-ext="class-tools, preload"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not exactly easy on the eyes, is it?</p>
</div>
<div class="paragraph">
<p>But, if you take a deep breath and squint, you can see that it isn&#8217;t
<em>that</em> bad: a series of htmx events, some of which we have seen before (there&#8217;s <code>htmx:configRequest</code>!), get logged
to the console, along with the element they are triggered on.</p>
</div>
<div class="paragraph">
<p>After a bit of reading and filtering, you will be
able to make sense of the event stream, and it can help you debug htmx-related issues.</p>
</div>
</div>
<div class="sect3">
<h4 id="_monitoring_events_in_chrome">Monitoring Events in Chrome</h4>
<div class="paragraph">
<p>The preceding technique is useful if the problem is occurring somewhere <em>within</em> htmx, but what if htmx is never getting
triggered at all?  This comes up some times, like when, for example, you have accidentally typed an event name incorrectly
somewhere.</p>
</div>
<div class="paragraph">
<p>In cases like this you will need recourse to a tool available in the browser itself.  Fortunately, the Chrome browser
by Google provides a very useful function, <code>monitorEvents()</code>, that allows you to monitor <em>all</em> events that are triggered
on an element.</p>
</div>
<div class="paragraph">
<p>This feature is available <em>only</em> in the console, so you can&#8217;t use it in code on your page.  But, if
you are working with htmx in Chrome, and are curious why an event isn&#8217;t triggering on an element, you can open the
developers console and type the following:</p>
</div>
<div class="listingblock">
<div class="title">htmx Logs</div>
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">monitorEvents(document.getElementById("some-element"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will then print <em>all</em> the events that are triggered on the element with the id <code>some-element</code> to the console.  This
can be very useful for understanding exactly which events you want to respond to with htmx, or troubleshooting why an
expected event isn&#8217;t occurring.</p>
</div>
<div class="paragraph">
<p>Using these two techniques will help you as you (infrequently, we hope) troubleshoot event-related issues when developing
with htmx.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_security_considerations">9.6. Security Considerations</h3>
<div class="paragraph">
<p>In general, htmx and hypermedia tends to be more secure than JavaScript heavy approaches to building web applications. This
is because, by moving much of the processing to the back end, the hypermedia approach tends not to expose as much surface
area of your system to end users for manipulation and shenanigans.</p>
</div>
<div class="paragraph">
<p>However, even with hypermedia, there are still situations that require care when doing development.  Of particular
concern are situations where user-generated content is shown to other users: a clever user might try to insert
htmx code that tricks the other users into clicking on content that triggers actions they don&#8217;t want to take.</p>
</div>
<div class="paragraph">
<p>In general, all user-generated content should be escaped on the server-side, and most server-side rendering frameworks
provide functionality for handling this situation.  But there is always a risk that something slips through the cracks.</p>
</div>
<div class="paragraph">
<p>In order to help you sleep better at night, htmx provides the <code>hx-disable</code> attribute.  When this attribute is placed
on an element, all htmx attributes within that element will be ignored.</p>
</div>
<div class="sect3">
<h4 id="_content_security_policies_htmx">Content Security Policies &amp; htmx</h4>
<div class="paragraph">
<p>A Content Security Policy (CSP) is a browser technology that allows you to detect and prevent certain types of
content injection-based attacks.  A full discussion of CSPs is beyond the scope of this book, but we refer you to
the  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Mozilla Developer Network article</a> on the topic for more information.</p>
</div>
<div class="paragraph">
<p>A common feature to disable using a CSP is the <code>eval()</code> feature of JavaScript, which allows you to evaluate arbitrary
JavaScript code from a string.  This has proven to be a security issue and many teams have decided that it is not worth
the risk to keep it enabled in their web applications.</p>
</div>
<div class="paragraph">
<p>Htmx does not make heavy use of <code>eval()</code> and, thus, a CSP with this restriction in place will be fine.  The one
feature that does rely on <code>eval()</code> is event filters, discussed above.  If you decide to disable <code>eval()</code> for your
web application, you will not be able to use the event filtering syntax.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring">9.7. Configuring</h3>
<div class="paragraph">
<p>There are a large number of configuration options available for htmx.  Some examples of things you can configure are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The default swap style</p>
</li>
<li>
<p>The default swap delay</p>
</li>
<li>
<p>The default timeout of AJAX requests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A full list of configuration options can be found in the config section of the <a href="https://htmx.org/docs/#config">main htmx documentation</a>.</p>
</div>
<div class="paragraph">
<p>Htmx is typically configured via a <code>meta</code> tag, found in the header of a page.  The name of the meta tag should be
<code>htmx-config</code>, and the content attribute should contain the configuration overrides, formatted as JSON.  Here is
an example:</p>
</div>
<div class="listingblock">
<div class="title">An htmx configuration via a <code>meta</code> tag</div>
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">&lt;meta name="htmx-config" content='{"defaultSwapStyle":"outerHTML"}'&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, we are overriding the default swap style from the usual <code>innerHTML</code> to <code>outerHTML</code>.  This might be useful
if you find yourself using <code>outerHTML</code> more frequently than <code>innerHTML</code> and want to avoid having to explicitly set that
swap value throughout your application.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_client_side_scripting">10. Client Side Scripting</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
REST allows client functionality to be extended by downloading and executing code in the form of applets or scripts.
This simplifies clients by reducing the number of features required to be pre-implemented.
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>Architectural Styles and the Design of Network-based Software Architectures</cite>
</div>
</div>
<div class="paragraph">
<p>Thus far we have (mostly) avoided writing any JavaScript (or _hyperscript) in Contact.app, mainly because the functionality
we implemented has not required it.  In this chapter we are going to look at scripting and, in particular, hypermedia-friendly
scripting within the context of a Hypermedia-Driven Application.</p>
</div>
<div class="sect2">
<h3 id="_is_scripting_allowed">10.1. Is Scripting Allowed?</h3>
<div class="paragraph">
<p>A common criticism of the web is that it&#8217;s being misused.  There is a narrative that WWW was created as a delivery system
for &#8220;documents&#8221;, and only came to be used for &#8220;applications&#8221; by way of an accident or bizarre circumstances.</p>
</div>
<div class="paragraph">
<p>However, the concept of hypermedia challenges the split of document and application, the distinction of code and data, of
operator and operand. Hypermedia systems like HyperCard, which preceded the web, featured rich capabilities for active
and interactive experiences, including scripting.</p>
</div>
<div class="paragraph">
<p>It is true in many ways that HTML, as specified and implemented, lacks affordances needed to build the kinds of applications
that were implemented within those older systems. None of this means, however, that hypermedia&#8217;s <em>purpose</em> is &#8220;documents&#8221;
over &#8220;applications&#8221;.</p>
</div>
<div class="paragraph">
<p>Rather, while the theoretical foundation is there, the implementation is underdeveloped. With JavaScript being the
only extension point and hypermedia controls not being well integrated to JavaScript (why can&#8217;t one click a link without
halting the program?), developers have not internalized hypermedia and have instead used the Web as a dumb pipe for apps
that imitate &#8220;native&#8221; ones.</p>
</div>
<div class="paragraph">
<p>A goal of this book is to show that it is possible to build sophisticated web applications using the original technology
of the web, hypermedia, without the application developer needing to reach for the abstractions provided by the large,
popular JavaScript frameworks.</p>
</div>
<div class="paragraph">
<p>htmx itself is, of course, written in JavaScript, and one of its advantages is that hypermedia interactions that go
through htmx expose a rich interface to JavaScript code with configuration, events, and htmx&#8217;s own extension support.</p>
</div>
<div class="paragraph">
<p>Because htmx expands the expressiveness of HTML so much it removes the need for scripting in many situations.
This makes htmx attractive to people who don&#8217;t want to write JavaScript, and there are many of those sorts of developers,
sick to death of the complexity of Single Page Application frameworks.</p>
</div>
<div class="paragraph">
<p>However, dunking on JavaScript is not the aim of the htmx project.</p>
</div>
<div class="paragraph">
<p>The goal of htmx is not less JavaScript, per se, but rather less code.</p>
</div>
<div class="paragraph">
<p>Scripting has been a massive force multiplier for the web. Using scripting, web application developers are not only able
to enhance their HTML websites, but also create fully-fledged client-side applications that can often compete with
native, thick client applications.</p>
</div>
<div class="paragraph">
<p>This JavaScript-centric approach to building web applications is a testament to the power of the web and to the sophistication
of web browsers in particular.  It has its place in web development: there are situations where the hypermedia approach
simply can&#8217;t provide the level of interaction that an SPA can.</p>
</div>
<div class="paragraph">
<p>However, in addition to this more JavaScript-centric style, we want to develop a style of scripting more compatible and
consistent with Hypermedia-Driven Applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scripting_for_hypermedia">10.2. Scripting for Hypermedia</h3>
<div class="paragraph">
<p>Borrowing from Roy Fielding&#8217;s notion of &#8220;constraints&#8221; defining REST, we offer two constraints of hypermedia-friendly
scripting.  You are scripting in an HDA-compatible manner if the following two constraints are adhered to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The main data format exchanged between server and client must be hypermedia, the same as it would be without scripting.</p>
</li>
<li>
<p>Client-side state, outside the DOM itself, is kept to a minimum.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The goal of these constraints is to confine scripting to where it shines best and where nothing else comes close:
<em>interaction design</em>.  Business logic and presentation logic are the responsibility of the server, where we can pick
whichever languages or tools are appropriate for our business domain.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The Server</div>
        <div class="paragraph">
<p>Keeping business logic and presentation logic both &#8220;on the server&#8221; does not mean these two &#8220;concerns&#8221; are mixed or
coupled. They can be modularized on the server. In fact, they <em>should</em> be modularized on the server, along with all the
other concerns of our application.</p>
</div>
<div class="paragraph">
<p>Note also that, especially in web development parlance, the humble &#8220;server&#8221; is usually a whole fleet of racks, virtual
machines, containers and more. Even a worldwide network of datacenters is reduced to &#8220;the server&#8221; when discussing
the server-side of a Hypermedia Driven-Application.</p>
</div>
    </aside>
<div class="paragraph">
<p>Satisfying these two constraints sometimes requires us to diverge from what is typically considered best practice for
JavaScript. Keep in mind that the cultural wisdom of JavaScript was largely developed in JavaScript-centric SPA applications.</p>
</div>
<div class="paragraph">
<p>The Hypermedia-driven Application cannot as comfortably fall back on this tradition. This chapter is our contribution to the
development of a new style and best practices for what we are calling Hypermedia-Driven Applications.</p>
</div>
<div class="paragraph">
<p>Unfortunately, simply listing &#8220;best practices&#8221; is rarely convincing or edifying. To be honest, it&#8217;s boring.</p>
</div>
<div class="paragraph">
<p>Instead, we will demonstrate these best practices by implementing client-side features in Contact.app.  We will
implement three different features, each showing different aspects of hypermedia-friendly scripting:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We will add an overflow menu to hold the <em>Edit</em>, <em>View</em> and <em>Delete</em> actions, to clean up visual clutter in our list of contacts</p>
</li>
<li>
<p>We will add an improved interface for bulk deletion</p>
</li>
<li>
<p>We will add a keyboard shortcut for focusing the search box</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The important takeaway in the implementation of each of these features is that, while they are implemented entirely in
the client-side using scripting, they <em>don&#8217;t exchange information with the server</em> via a non-hypermedia format, such
as JSON, and that they don&#8217;t store a significant amount of state outside of the DOM itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scripting_tools_for_the_web">10.3. Scripting tools for the Web</h3>
<div class="paragraph">
<p>The primary scripting language for the web is, of course, JavaScript, which is ubiquitous in web development today.</p>
</div>
<div class="paragraph">
<p>A bit of interesting internet lore, however, is that JavaScript was not always the only built-in option.
As the quote from Roy Fielding at the start of this chapter hints, &#8220;applets&#8221; written in other languages such as Java were considered to be
part of the scripting infrastructure of the web. In addition, there was a time period when Internet Explorer supported VBScript,
a scripting language based on Visual Basic.</p>
</div>
<div class="paragraph">
<p>Today, we have a variety of <em>transcompilers</em> (often shortened to <em>transpilers</em>) that convert many languages to JavaScript,
such as TypeScript, Dart, Kotlin, ClojureScript, F# and more. There is also the WebAssembly (WASM) bytecode format, which
is supported as a compilation target for C, Rust, and the WASM-first language AssemblyScript.</p>
</div>
<div class="paragraph">
<p>However, most of these options are not geared towards a hypermedia-friendly style of scripting. Compile-to-JS languages
are often paired with SPA-oriented libraries (Dart and AngularDart, ClojureScript and Reagent, F# and Elm), and WASM is
currently mainly geared toward linking to C/C++ libraries from JavaScript.</p>
</div>
<div class="paragraph">
<p>We will instead focus on three client-side scripting technologies that <em>are</em> hypermedia-friendly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>VanillaJS, that is, using JavaScript without depending on any framework.</p>
</li>
<li>
<p>Alpine.js, a JavaScript library for adding behavior directly in HTML.</p>
</li>
<li>
<p>_hyperscript, a non-JavaScript scripting language created alongside htmx. Like AlpineJS, _hyperscript is usually embedded in HTML.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at each of these scripting options, so we know what we are dealing with.</p>
</div>
<div class="paragraph">
<p>Note that, as with CSS, we are not going to do a deep dive into any of these options.  Instead, we are going to show you
just enough to give you a flavor of how they work and, we hope, spark your interest in looking into any of them more extensively.</p>
</div>
</div>
<div class="sect2">
<h3 id="_vanilla_javascript">10.4. Vanilla JavaScript</h3>
<div class="quoteblock">
<blockquote>
No code is faster than no code.
</blockquote>
<div class="attribution">
&#8212; Merb
</div>
</div>
<div class="paragraph">
<p>Vanilla JavaScript is simply using plain JavaScript in your application, without any intermediate layers.
The term &#8220;Vanilla&#8221; entered frontend web dev parlance as it became assumed that any sufficiently &#8220;advanced&#8221; web app would
use some library with a name ending in &#8220;.js&#8221;. As JavaScript matured as a scripting language, however, standardized across browsers and
provided more and more functionality, these frameworks and libraries became less important.</p>
</div>
<div class="paragraph">
<p>Somewhat ironically though, as JavaScript became more powerful and removed the need for the first generation of
JavaScript libraries such as jQuery, it also enabled people to build complex SPA libraries.  These SPA libraries are often
even more elaborate than the original first generation of JavaScript libraries.</p>
</div>
<div class="paragraph">
<p>A quote from the website <a href="http://vanilla-js.com" class="bare">http://vanilla-js.com</a>, which is well worth visiting even though it&#8217;s slightly out of date,
captures the situation well:</p>
</div>
<div class="quoteblock">
<blockquote>
VanillaJS is the lowest-overhead, most comprehensive framework I&#8217;ve ever used.
</blockquote>
<div class="attribution">
&#8212; http://vanilla-js.com
</div>
</div>
<div class="paragraph">
<p>With JavaScript having  matured as a scripting language, this is certainly the case for many applications. It is
especially true in the case of HDAs, since, by using hypermedia, your application will not need many of the features
typically provided by more elaborate Single Page Application JavaScript frameworks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client-side routing</p>
</li>
<li>
<p>An abstraction over DOM manipulation, i.e.: templates that automatically update when referenced variables change</p>
</li>
<li>
<p>Server side rendering <span id="_footnote_3" class="footnote">Rendering here refers to HTML generation. Framework support for server-side rendering is not needed in a HDA because generating HTML on the server is the default.</span></p>
</li>
<li>
<p>Attaching dynamic behavior to server-rendered tags on load, i.e. &#8220;hydration&#8221;</p>
</li>
<li>
<p>Network requests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Without all this complexity being handled in JavaScript, your framework needs are dramatically reduced.</p>
</div>
<div class="paragraph">
<p>One of the best things about VanillaJS is how you install it: you don&#8217;t have to!</p>
</div>
<div class="paragraph">
<p>You can just start writing JavaScript in your web application, and it will simply work.</p>
</div>
<div class="paragraph">
<p>That&#8217;s the good news. The bad news is that, despite improvements over the last decade, JavaScript has some significant
limitations as a scripting language that can make it a less than ideal as a stand-alone scripting technology for
Hypermedia Driven Applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Being as established as it is, it has accreted a lot of features and warts.</p>
</li>
<li>
<p>It has a complicated and confusing set of features for working with asynchronous code.</p>
</li>
<li>
<p>Working with events is surprisingly difficult.</p>
</li>
<li>
<p>DOM APIs (a large portion of which were originally designed for Java, yes <em>Java</em>)
are verbose and don&#8217;t have a habit of making common functionality easy to use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>None of these limitations are deal-breakers, of course. Many of them are gradually being fixed and many people prefer
the &#8220;close to the metal&#8221; (for lack of a better term) nature of vanilla JavaScript over more elaborate client-side scripting approaches.</p>
</div>
<div class="sect3">
<h4 id="_a_simple_counter">A Simple Counter</h4>
<div class="paragraph">
<p>To dive into vanilla JavaScript as a front end scripting option, let&#8217;s create a simple counter widget.</p>
</div>
<div class="paragraph">
<p>Counter widgets are a common &#8220;Hello World&#8221; example for JavaScript frameworks, so looking at how it can be done in
vanilla JavaScript (as well as the other options we are going to look at) will be instructive.</p>
</div>
<div class="paragraph">
<p>Our counter widget will be very simple: it will have a number, shown as text, and a button that increments the number.</p>
</div>
<div class="paragraph">
<p>One problem with tackling this problem in vanilla JavaScript is that it lacks one thing that most JavaScript frameworks
provide: a default code and architectural style.</p>
</div>
<div class="paragraph">
<p>With vanilla JavaScript, there are no rules!</p>
</div>
<div class="paragraph">
<p>This isn&#8217;t all bad. It presents a great opportunity to take a small journey through various styles that people have
developed for writing their JavaScript.</p>
</div>
<div class="sect4">
<h5 id="_an_inline_implementation">An Inline Implementation</h5>
<div class="paragraph">
<p>To begin, let&#8217;s start with the simplest thing imaginable: all of our JavaScript will be written inline, directly in the
HTML.  When the button is clicked, we will look up the <code>output</code> element holding the number, and increment the number
contained within it.</p>
</div>
<div class="listingblock">
<div class="title">Counter in vanilla JavaScript, inline version</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;section class="counter"&gt;
  &lt;output id="my-output"&gt;0&lt;/output&gt; <b class="conum">(1)</b>
  &lt;button
    onclick=" <b class="conum">(2)</b>
      document.querySelector('#my-output') <b class="conum">(3)</b>
        .textContent++ <b class="conum">(4)</b>
    "
  &gt;Increment&lt;/button&gt;
&lt;/section&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Our output element has an ID to help us find it</p>
</li>
<li>
<p>We use the <code>onclick</code> attribute to add an event listener</p>
</li>
<li>
<p>Find the output via a querySelector() call</p>
</li>
<li>
<p>JavaScript allows us use the <code>++</code> operator on strings</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Not too bad.</p>
</div>
<div class="paragraph">
<p>It&#8217;s not the most beautiful code, and can be irritating especially if you aren&#8217;t used to the DOM APIs.</p>
</div>
<div class="paragraph">
<p>It&#8217;s a little annoying that we needed to add an <code>id</code> to the <code>output</code> element. The <code>document.querySelector()</code> function
is a bit verbose compared with, say, the <code>$</code> function, as provided by jQuery.</p>
</div>
<div class="paragraph">
<p>But it works. It&#8217;s also easy enough to understand, and crucially it doesn&#8217;t require any other JavaScript libraries.</p>
</div>
<div class="paragraph">
<p>So that&#8217;s the simple, inline approach with VanillaJS.</p>
</div>
</div>
<div class="sect4">
<h5 id="_separating_our_scripting_out">Separating Our Scripting Out</h5>
<div class="paragraph">
<p>While the inline implementation is simple in some sense, a more standard way to write this code would be to move the code
into a separate JavaScript file. This JavaScript file would then either be linked to via a <code>&lt;script src&gt;</code> tag or
placed into an inline <code>&lt;script&gt;</code> tag by a build process.</p>
</div>
<div class="paragraph">
<p>Here we see the HTML and JavaScript <em>separated out</em> from one another, in different files. The HTML is now &#8220;cleaner&#8221; in
that there is no JavaScript in it.</p>
</div>
<div class="paragraph">
<p>The JavaScript is a bit more complex than in our inline version: we need to look up the button using a query selector
and add an <em>event listener</em> to handle the click event and increment the counter.</p>
</div>
<div class="listingblock">
<div class="title">Counter HTML</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;section class="counter"&gt;
  &lt;output id="my-output"&gt;0&lt;/output&gt;
  &lt;button class="increment-btn"&gt;Increment&lt;/button&gt;
&lt;/section&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Counter JavaScript</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">const counterOutput = document.querySelector("#my-output") <b class="conum">(1)</b>
const incrementBtn  = document.querySelector(".counter .increment-btn") <b class="conum">(2)</b>

incrementBtn.addEventListener("click", e =&gt; { <b class="conum">(3)</b>
  counterOutput.innerHTML++ <b class="conum">(4)</b>
})</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Find the output element</p>
</li>
<li>
<p>and the button</p>
</li>
<li>
<p>We use <code>addEventListener</code>, which is preferable to <code>onclick</code> for many reasons</p>
</li>
<li>
<p>The logic stays the same, only the structure around it changes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In moving the JavaScript out to another file, we are following a software design principle known as <em>Separation of Concerns (SoC).</em></p>
</div>
<div class="paragraph">
<p>Separation of Concerns posits that the various &#8220;concerns&#8221; (or aspects) of a software project should be divided up into
multiple files, so that they don&#8217;t &#8220;pollute&#8221; one another. JavaScript isn&#8217;t markup, so it shouldn&#8217;t be in your HTML,
it should be <em>elsewhere</em>.  Styling information, similarly, isn&#8217;t markup, and so it belongs in a separate file as well
(A CSS file, for example.)</p>
</div>
<div class="paragraph">
<p>For quite some time, this Separation of Concerns was considered the &#8220;orthodox&#8221; way to build web applications.</p>
</div>
<div class="paragraph">
<p>A stated goal of Separation of Concerns is that we should be able to modify and evolve each concern independently, with
confidence that we won&#8217;t break any of the other concerns.</p>
</div>
<div class="paragraph">
<p>However, let&#8217;s look at exactly how this principle has worked out in our simple counter example.  If you look closely
at the new HTML, it turns out that we&#8217;ve had to add a class to the button.  We added this class so that we could look the button
up in JavaScript and add in an event handler for the &#8220;click&#8221; event.</p>
</div>
<div class="paragraph">
<p>Now, in both the HTML and the JavaScript, this class name is just a string and there isn&#8217;t any process to <em>verify</em> that
the button has the right classes on it or its parents to ensure that the event handler is actually added to the right element.</p>
</div>
<div class="paragraph">
<p>Unfortunately, it has turned out that the careless use of CSS selectors in JavaScript can cause what is known as
<em>jQuery soup</em>.  jQuery soup is a situation where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JavaScript that attaches a given behavior to a given element is difficult to find.</p>
</li>
<li>
<p>Code reuse is difficult.</p>
</li>
<li>
<p>The code ends up wildly disorganized and &#8220;flat&#8221;, with lots of unrelated event handlers mixed together.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The name &#8220;jQuery soup&#8221; comes from the fact that early JavaScript-heavy applications were typically built in jQuery,
which, perhaps inadvertently, tended to encourage this style of JavaScript.</p>
</div>
<div class="paragraph">
<p>So, you can see that the notion of Separation of Concerns doesn&#8217;t always work out as well as promised: our concerns
end up intertwined or coupled pretty deeply, even when we separate them into different files.</p>
</div>
<div class="paragraph">
<p>To show that it isn&#8217;t just naming between concerns that can get you into trouble, consider another small change to our HTML
that demonstrates the problems with our separation of concerns: imagine that we decide to change the number field from
an <code>&lt;output&gt;</code> tag to an <code>&lt;input type="number"&gt;</code>.</p>
</div>
<div class="paragraph">
<p>This small change to our HTML will break our JavaScript, despite the fact we have &#8220;separated&#8221; our concerns.</p>
</div>
<div class="paragraph">
<p>The fix for this issue is simple enough (we would need to change the <code>.textContent</code> property to <code>.value</code> property), but
it demonstrates the burden of synchronizing markup changes and code changes across multiple files.  Keeping everything
in sync can become increasingly difficult as your application size increases.</p>
</div>
<div class="paragraph">
<p>The fact that small changes to our HTML can break our scripting indicates that the two are <em>tightly coupled</em>, despite being
broken up into multiple files.  This tight coupling suggests that separation between HTML and JavaScript (and CSS) is often
an illusory separation of concerns: the concerns are sufficiently related to one another that they aren&#8217;t easily separated.</p>
</div>
<div class="paragraph">
<p>In Contact.app we are not <em>concerned</em> with &#8220;structure&#8221;, &#8220;styling&#8221; or &#8220;behavior&#8221;; we are concerned with collecting contact
info and presenting it to users. SoC, in the way it&#8217;s formulated in web development orthodoxy, is not really an inviolate
architectural guideline, but rather a stylistic choice that, as we can see, can even become a hindrance.</p>
</div>
</div>
<div class="sect4">
<h5 id="_locality">Locality</h5>
<div class="paragraph">
<p>It turns out that there is a burgeoning reaction <em>against</em> the Separation of Concerns design principle.  Consider the
following web technologies and techniques:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JSX</p>
</li>
<li>
<p>LitHTML</p>
</li>
<li>
<p>CSS-in-JS</p>
</li>
<li>
<p>Single-File Components</p>
</li>
<li>
<p>Filesystem based routing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of these technologies <em>colocate</em> code in various languages that address a single <em>feature</em> (typically a UI widget).</p>
</div>
<div class="paragraph">
<p>All of them mix <em>implementation</em> concerns together in order to present a unified abstraction to the end-user.  Separating
technical detail concerns just isn&#8217;t as much of an, ahem, concern.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Locality of Behaviour</div>
        <div class="paragraph">
<p>Locality of Behaviour (LoB) is an alternative software design principle that we coined, in opposition to Separation of Concerns.
It describes the following characteristic of a piece of software:</p>
</div>
<div class="quoteblock">
<blockquote>
The behaviour of a unit of code should be as obvious as possible by looking only at that unit of code.
</blockquote>
<div class="attribution">
&#8212; https://htmx.org/essays/locality-of-behaviour/
</div>
</div>
<div class="paragraph">
<p>In simple terms: you should be able to tell what a button does by simply looking at the code or markup that creates that button.
This does not mean you need to inline the entire implementation, but that you shouldn&#8217;t need to hunt for it or require prior knowledge of the codebase to find it.</p>
</div>
<div class="paragraph">
<p>We will demonstrate Locality of Behaviour in all of our examples, both the counter demos and the features we add to Contact.app.
Locality of behavior is an explicit design goal of both _hyperscript and Alpine.js (which we will cover later) as well as htmx.</p>
</div>
<div class="paragraph">
<p>All of these tools achieve Locality of Behaviour by having you embed attributes directly within your HTML, as opposed to
having code look up elements in a document through CSS selectors in order to add event listeners onto them.</p>
</div>
    </aside>
<div class="paragraph">
<p>In a Hypermedia Driven Application, we feel that the Locality of Behaviour design principle is often more important than
the more traditional Separation of Concerns design principle.</p>
</div>
</div>
<div class="sect4">
<h5 id="_what_to_do_with_our_counter">What To Do With Our Counter?</h5>
<div class="paragraph">
<p>So, should we go back to the <code>onclick</code> attribute way of doing things? That approach certainly wins in Locality of
Behavior, and has the additional benefit that it is baked into HTML.</p>
</div>
<div class="paragraph">
<p>Unfortunately, however, the <code>on*</code>  JavaScript attributes also come with some drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They don&#8217;t support custom events.</p>
</li>
<li>
<p>There is no good mechanism for associating long-lasting variables with an element&#8201;&#8212;&#8201;all variables are discarded when an event listener completes executing.</p>
</li>
<li>
<p>If you have multiple instances of an element, you will need to repeat the listener code on each, or use something more clever like event delegation.</p>
</li>
<li>
<p>JavaScript code that directly manipulates the DOM gets verbose, and clutters the markup.</p>
</li>
<li>
<p>An element cannot listen for events on another element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider this common situation: you have a popup, and you want it to be dismissed when a user clicks outside of it.  The
listener will need to be on the body element in this situation, far away from the actual popup markup. This means that
the body element would need to have listeners attached to it that deal with many unrelated components.  Some of these
components may not even be on the page when it was first rendered, if they are added dynamically after the initial
HTML page is rendered.</p>
</div>
<div class="paragraph">
<p>So vanilla JavaScript and Locality of Behaviour don&#8217;t seem to mesh <em>quite</em> as well as we would like them to.</p>
</div>
<div class="paragraph">
<p>The situation is not hopeless, however: it&#8217;s important to understand that LoB does not require behavior to be <em>implemented</em>
at a use site, but merely <em>invoked</em> there.  That is, we don&#8217;t need to write all our code on a given element, we just
need to make it clear that a given element is <em>invoking</em> some code, which can be located elsewhere.</p>
</div>
<div class="paragraph">
<p>Keeping this in mind, it <em>is</em> possible to improve LoB while writing JavaScript in a separate file, provided we have a
reasonable system for structuring our JavaScript.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rsjs">RSJS</h4>
<div class="paragraph">
<p>RSJS (the &#8220;Reasonable System for JavaScript Structure&#8221;, <a href="https://ricostacruz.com/rsjs/" class="bare">https://ricostacruz.com/rsjs/</a>) is a set of guidelines for
JavaScript architecture targeted at &#8220;a typical non-SPA website&#8221;. RSJS provides a solution to the lack of a standard code
style for vanilla JavaScript that we mentioned earlier.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t reproduce all the RSJS guidelines here, but here are the ones most relevant for our counter widget:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;Use <code>data-</code> attributes&#8221; in HTML - invoking behavior via adding data attributes makes it obvious there is JavaScript
happening, as opposed to using random classes or IDs that may be mistakenly removed or changed</p>
</li>
<li>
<p>&#8220;One component per file&#8221; - the name of the file should match the data attribute so that it can be found easily, a win for LoB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To follow the RSJS guidelines, let&#8217;s restructure our current HTML and JavaScript files.  First, we will use <em>data attributes</em>,
that is, HTML attributes that begin with <code>data-</code>, a standard feature of HTML, to indicate that our HTML is a counter
component.  We will then update our JavaScript to use an attribute selector that looks for the <code>data-counter</code> attribute
as the root element in our counter component and wires in the appropriate event handlers and logic.  Additionally, let&#8217;s
rework the code to use <code>querySelectorAll()</code> and add the counter functionality to <em>all</em> counter components found on the
page.  (You never know how many counter&#8217;s you might want!)</p>
</div>
<div class="paragraph">
<p>Here is what our code looks like now:</p>
</div>
<div class="openblock">
<div class="title">Counter in vanilla JavaScript, with RSJS</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;section class="counter" data-counter&gt; <b class="conum">(1)</b>
  &lt;output id="my-output" data-counter-output&gt;0&lt;/output&gt; <b class="conum">(2)</b>
  &lt;button class="increment-btn" data-counter-increment&gt;Increment&lt;/button&gt;
&lt;/section&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Invoke a JavaScript behavior with a data attribute</p>
</li>
<li>
<p>Mark relevant descendant elements</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// counter.js <b class="conum">(1)</b>
document.querySelectorAll("[data-counter]") <b class="conum">(2)</b>
  .forEach(el =&gt; {
    const
    output = el.querySelector("[data-counter-output]"),
    increment = el.querySelector("[data-counter-increment]"); <b class="conum">(3)</b>

    increment.addEventListener("click", e =&gt; output.textContent++); <b class="conum">(4)</b>
  });</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>File should have the same name as the data attribute, so that we can locate it easily</p>
</li>
<li>
<p>Get all elements that invoke this behavior</p>
</li>
<li>
<p>Get any child elements we need</p>
</li>
<li>
<p>Register event handlers</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Using RSJS solves, or at least alleviates, many of the problems we pointed out with our first, unstructured example of VanillaJS being
split out to a separate file:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JS that attaches behavior to a given element is <em>clear</em> (though only through naming conventions).</p>
</li>
<li>
<p>Reuse is <em>easy</em>&#8201;&#8212;&#8201;you can create another counter component on the page and it will just work.</p>
</li>
<li>
<p>The code is <em>well-organized</em>&#8201;&#8212;&#8201;one behavior per file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All in all, RSJS is a good way to structure your vanilla JavaScript in a Hypermedia Driven Application.  So long as the
JavaScript isn&#8217;t communicating with a server via a plain data JSON API, or holding a bunch of internal state outside of
the DOM, this is perfectly compatible with the HDA approach.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s next take a look at implementing a feature in Contact.app using the RSJS/vanilla JavaScript approach.</p>
</div>
</div>
<div class="sect3">
<h4 id="_vanillajs_in_action_an_overflow_menu">VanillaJS in action: an overflow menu</h4>
<div class="paragraph">
<p>Our homepage has &#8220;Edit&#8221;, &#8220;View&#8221; and &#8220;Delete&#8221; links for every contact in our table. This uses a lot of space and creates
visual clutter.  Let&#8217;s fix that by placing these actions inside a drop-down menu with a button to open it.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s begin by sketching the markup we want for our dropdown menu.  First, we need an element, we&#8217;ll use a <code>&lt;div&gt;</code>, to enclose the
entire widget and mark it as a menu component.  Within this div, we will have a standard <code>&lt;button&gt;</code> that will function
as the mechanism that shows and hides our menu items.  Finally, we&#8217;ll have another <code>&lt;div&gt;</code> that holds the menu items
that we are going to show.</p>
</div>
<div class="paragraph">
<p>These menu items will be simple anchor tags, as they are in the current contacts table.</p>
</div>
<div class="paragraph">
<p>Here is what our updated, RSJS-structured HTML looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div data-overflow-menu&gt; <b class="conum">(1)</b>
    &lt;button type="button" aria-haspopup="menu"
        aria-controls="contact-menu-{{ contact.id }}"
        &gt;Options&lt;/button&gt; <b class="conum">(2)</b>
    &lt;div role="menu" hidden id="contact-menu-{{ contact.id }}"&gt; <b class="conum">(3)</b>
        &lt;a role="menuitem" href="/contacts/{{ contact.id }}/edit"&gt;Edit&lt;/a&gt; <b class="conum">(4)</b>
        &lt;a role="menuitem" href="/contacts/{{ contact.id }}"&gt;View&lt;/a&gt;
        &lt;!-- ... --&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mark the root element of the menu component</p>
</li>
<li>
<p>This button will open and close our menu</p>
</li>
<li>
<p>A container for our menu items</p>
</li>
<li>
<p>Menu items</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The roles and ARIA attributes are based on the Menu and Menu Button patterns from the ARIA Authoring Practices Guide.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">What is ARIA?</div>
        <div class="paragraph">
<p>As we web developers create more interactive, app-like websites, HTML&#8217;s repertoire of elements won&#8217;t have all we need.
As we have seen, using CSS and JavaScript, we can endow existing elements with extended behavior and appearances, rivaling
those of native controls.</p>
</div>
<div class="paragraph">
<p>However, there is one thing web apps used to be unable to replicate. While these widgets are similar enough in appearance
for most users to operate, assistive technology (e.g. screen readers) can only report the underlying HTML elements.</p>
</div>
<div class="paragraph">
<p>Even if you take the time to get all the keyboard interactions right, some users often are unable to work with these custom
elements easily.</p>
</div>
<div class="paragraph">
<p>ARIA was created by W3C&#8217;s Web Accessibility Initiative (WAI) in 2008 to address this problem.  At a surface level, it is
a set of attributes you can add to HTML to make it meaningful to assistive software such as a screen reader.</p>
</div>
<div class="paragraph">
<p>ARIA has two main components that interact with one another:</p>
</div>
<div class="paragraph">
<p>The first is the <code>role</code> attribute. This attribute has a predefined set of possible values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>menu</code></p>
</li>
<li>
<p><code>dialog</code></p>
</li>
<li>
<p><code>radiogroup</code></p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>role</code> attribute <em>does not add any behavior</em> to HTML elements. Rather, it is a promise you make to the user.  When
you annotate an element as <code>role='menu'</code>, you are saying: <em>I will make this element work like a menu.</em></p>
</div>
<div class="paragraph">
<p>Because this is a promise you are making, if you add the <code>role</code> attribute to an element but you <em>don&#8217;t</em> uphold
the promise, the experience for many users will be <em>worse</em> than if the element had no <code>role</code> annotation on it at all.</p>
</div>
<div class="paragraph">
<p>Because of this, it is written:</p>
</div>
<div class="quoteblock">
<blockquote>
No ARIA is better than Bad ARIA.
</blockquote>
<div class="attribution">
&#8212; W3C<br>
<cite>Read Me First | APG https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/</cite>
</div>
</div>
<div class="paragraph">
<p>The second component of ARIA is a whole range of attributes, all sharing the <code>aria-</code> prefix:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>aria-expanded</code></p>
</li>
<li>
<p><code>aria-controls</code></p>
</li>
<li>
<p><code>aria-label</code></p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These attributes can specify various things such as the state of a widget, the relationships between components, or
additional semantics.</p>
</div>
<div class="paragraph">
<p>Once again, these attributes are <em>promises</em>, not implementations.</p>
</div>
<div class="paragraph">
<p>Rather than learn all the roles and attributes and try to combine them into a usable widget,
the best course of action for most developers is to rely on the ARIA Authoring Practices Guide (APG),
a web resource with practical information aimed directly at web developers.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re new to ARIA, check out the following links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/">ARIA Read Me First</a></p>
</li>
<li>
<p><a href="https://www.w3.org/WAI/ARIA/apg/patterns/">ARIA UI patterns</a></p>
</li>
<li>
<p><a href="https://www.w3.org/WAI/ARIA/apg/practices/">ARIA Good Practices</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Always remember to test your website for accessibility to ensure a maximum number of users can interact with it
easily and effectively.</p>
</div>
    </aside>
<div class="paragraph">
<p>With this ARIA introduction out the way, let&#8217;s return to our VanillaJS drop down menu.  We&#8217;ll begin with the RSJS
boilerplate: query for all elements with some data attribute, iterate over them, get any relevant descendants.</p>
</div>
<div class="paragraph">
<p>Note that, below, we&#8217;ve modified the RSJS boilerplate a bit to integrate with htmx, in particular we load the
overflow menu when htmx loads new content.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">function overflowMenu(subtree = document) {
  document.querySelectorAll("[data-overflow-menu]").forEach(menuRoot =&gt; { <b class="conum">(1)</b>
    const
    button = menuRoot.querySelector("[aria-haspopup]"), <b class="conum">(2)</b>
    menu = menuRoot.querySelector("[role=menu]"), <b class="conum">(2)</b>
    items = [...menu.querySelectorAll("[role=menuitem]")]; <b class="conum">(3)</b>
  });
}

addEventListener("htmx:load", e =&gt; overflowMenu(e.target)); <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>With RSJS, you&#8217;ll be writing <code>document.querySelectorAll(&#8230;&#8203;).forEach</code> a lot.</p>
</li>
<li>
<p>To keep the HTML clean, we use ARIA attributes rather than custom data attributes here.</p>
</li>
<li>
<p>Use the spread operator to convert a <code>NodeList</code> into a normal <code>Array</code>.</p>
</li>
<li>
<p>Initialize all overflow menus when the page is loaded or content is inserted by htmx.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Conventionally, we would keep track of whether the menu is open using a JavaScript variable or a property in a JavaScript
state object.  This approach is common in large, JavaScript-heavy web applications.</p>
</div>
<div class="paragraph">
<p>However, this approach has some drawback:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We would need to keep the DOM in sync with the state (harder without a framework)</p>
</li>
<li>
<p>We would lose the ability to serialize the HTML (as this open state isn&#8217;t stored in the DOM, but rather in JavaScript).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Instead of taking this approach, we will use the DOM to store our state.  We&#8217;ll lean on the <code>hidden</code> attribute on the
menu element to tell us it&#8217;s closed. If the HTML of the page is snapshotted and restored, the menu can be restored as
well by simply re-running the JS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  items = [...menu.querySelectorAll("[role=menuitem]")];

  const isOpen = () =&gt; !menu.hidden; <b class="conum">(1)</b>

});</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>hidden</code> attribute is helpfully reflected as a <code>hidden</code> <em>property</em>, so we don&#8217;t need to use <code>getAttribute</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;ll also make the menu items non-tabbable, so we can manage their focus ourselves.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  const isOpen = () =&gt; !menu.hidden; <b class="conum">(1)</b>

  items.forEach(item =&gt; item.setAttribute("tabindex", "-1"));

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s implement toggling the menu in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  items.forEach(item =&gt; item.setAttribute("tabindex", "-1"));

  function toggleMenu(open = !isOpen()) { <b class="conum">(1)</b>
    if (open) {
      menu.hidden = false;
      button.setAttribute("aria-expanded", "true");
      items[0].focus(); <b class="conum">(2)</b>
    } else {
      menu.hidden = true;
      button.setAttribute("aria-expanded", "false");
    }
  }

  toggleMenu(isOpen()); <b class="conum">(3)</b>
  button.addEventListener("click", () =&gt; toggleMenu()); <b class="conum">(4)</b>
  menuRoot.addEventListener("blur", e =&gt; toggleMenu(false)); <b class="conum">(5)</b>

})</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Optional parameter to specify desired state. This allows us to use one function to open, close, or toggle the menu.</p>
</li>
<li>
<p>Focus first item of menu when opened.</p>
</li>
<li>
<p>Call <code>toggleMenu</code> with current state, to initialize element attributes.</p>
</li>
<li>
<p>Toggle menu when button is clicked.</p>
</li>
<li>
<p>Close menu when focus moves away.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s also make the menu close when we click outside it, a nice behavior that mimics how native drop-down menus work. This
will require an event listener on the whole window.</p>
</div>
<div class="paragraph">
<p>Note that we need to be careful with this kind of listener: you may find that listeners accumulate as components add
listeners and fail to remove them when the component is removed from the DOM.  This, unfortunately, leads to difficult
to track down memory leaks.</p>
</div>
<div class="paragraph">
<p>There is not an easy way in JavaScript to execute logic when an element is removed.  The best option is what is known
as the <code>MutationObserver</code> API.  A <code>MutationObserver</code> is very useful, but the API is quite heavy and a bit arcane, so we
won&#8217;t be using it for our example.</p>
</div>
<div class="paragraph">
<p>Instead, we will use a simple pattern to avoid leaking event listeners: when our event listener runs, we will check if the
attaching component is still in the DOM, and, if the element is no longer in the DOM, we will remove the listener and
exit.</p>
</div>
<div class="paragraph">
<p>This is a somewhat hacky, manual form of <em>garbage collection</em>.  As is (usually) the case with other garbage collection
algorithms, our strategy removes listeners in a nondeterministic amount of time after they are no longer needed. Fortunately
for us, With a frequent event like &#8220;the user clicks anywhere in the page&#8221; driving the collection, it should work well
enough for our system.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  menuRoot.addEventListener("blur", e =&gt; toggleMenu(false));

  window.addEventListener("click", function clickAway(event) {
    if (!menuRoot.isConnected) window.removeEventListener("click", clickAway); <b class="conum">(1)</b>
    if (!menuRoot.contains(event.target)) toggleMenu(false); <b class="conum">(2)</b>
  });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This line is the garbage collection</p>
</li>
<li>
<p>If the click is outside the menu, close the menu</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, let&#8217;s move on to the keyboard interactions for our dropdown menu. The keyboard handlers turn out to all be pretty
similar to one another and not particularly intricate, so let&#8217;s knock them all out in one go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">    if (!menuRoot.contains(event.target)) toggleMenu(false); <b class="conum">(2)</b>
  });

  const currentIndex = () =&gt; { <b class="conum">(1)</b>
    const idx = items.indexOf(document.activeElement);
    if (idx === -1) return 0;
    return idx;
  }

  menu.addEventListener("keydown", e =&gt; {
    if (e.key === "ArrowUp") {
      items[currentIndex() - 1]?.focus(); <b class="conum">(2)</b>

    } else if (e.key === "ArrowDown") {
      items[currentIndex() + 1]?.focus(); <b class="conum">(3)</b>

    } else if (e.key === "Space") {
      items[currentIndex()].click(); <b class="conum">(4)</b>

    } else if (e.key === "Home") {
      items[0].focus(); <b class="conum">(5)</b>

    } else if (e.key === "End") {
      items[items.length - 1].focus(); <b class="conum">(6)</b>

    } else if (e.key === "Escape") {
      toggleMenu(false); <b class="conum">(7)</b>
      button.focus(); <b class="conum">(8)</b>
    }
  });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Helper: Get the index in the items array of the currently focused menu item (0 if none).</p>
</li>
<li>
<p>Move focus to the previous menu item when the up arrow key is pressed</p>
</li>
<li>
<p>Move focus to the next menu item when the down arrow key is pressed</p>
</li>
<li>
<p>Activate the currently focused element when the space key is pressed</p>
</li>
<li>
<p>Move focus to the first menu item when Home is pressed</p>
</li>
<li>
<p>Move focus to the last menu item when End is pressed</p>
</li>
<li>
<p>Close menu when Escape is pressed</p>
</li>
<li>
<p>Return focus to menu button when closing menu</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That should cover all our bases, and we&#8217;ll admit that that&#8217;s a lot of code. But, in fairness, it&#8217;s code that encodes a
lot of behavior.</p>
</div>
<div class="paragraph">
<p>Now, our drop-down menu isn&#8217;t perfect, and it doesn&#8217;t handle a lot of things.  For example, we don&#8217;t support submenus,
or menu items being added or removed dynamically to the menu.  If we needed more menu features like this, it might make
more sense to use an off-the-shelf library such as, GitHub&#8217;s <a href="https://github.com/github/details-menu-element"><code>details-menu-element</code></a>.</p>
</div>
<div class="paragraph">
<p>But, for our relatively simple use case, this library does a fine job, and we got to explore ARIA and RSJS while
implementing it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alpine_js">10.5. Alpine.js</h3>
<div class="paragraph">
<p>OK, so that&#8217;s an in-depth look at how to structure plain VanillaJS-style JavaScript.  Let&#8217;s turn our attention to an
actual JavaScript framework that enables a different approach for adding dynamic behavior to your application,
<a href="https://alpinejs.dev">Alpine.js</a>.</p>
</div>
<div class="paragraph">
<p>Alpine is a relatively new JavaScript library which allows developers to embed JavaScript code directly in HTML, akin to
the <code>on*</code> attributes available in plain HTML and JavaScript.  However, Alpine takes this concept of embedded scripting
much further than <code>on*</code> attributes.</p>
</div>
<div class="paragraph">
<p>Alpine bills itself as a modern replacement for jQuery, the widely used, older JavaScript library.  As you will see, it
definitely lives up to this promise.</p>
</div>
<div class="paragraph">
<p>Installing Alpine is very easy: it is a single file and is dependency-free, so you can simply include it via a CDN:</p>
</div>
<div class="listingblock">
<div class="title">Installing Alpine</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;script src="https://unpkg.com/alpinejs"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also install it via a package manager such as NPM, or vendor it from your own server.</p>
</div>
<div class="paragraph">
<p>Alpine provides a set of HTML attributes, all of which begin with the <code>x-</code> prefix, the main one of which is <code>x-data</code>.
The content of <code>x-data</code> is a JavaScript expression which evaluates to an object.  The properties of this object can, then,
be access within the element that the <code>x-data</code> attribute is located on.</p>
</div>
<div class="paragraph">
<p>To get a flavor of what AlpineJS looks like, let&#8217;s look at how to implement our counter example using it.</p>
</div>
<div class="paragraph">
<p>For the counter, the only state we need to keep track of is the current number, so let&#8217;s declare a JavaScript object
with one property, <code>count</code>, in an <code>x-data</code> attribute on the div for our counter:</p>
</div>
<div class="listingblock">
<div class="title">Counter with Alpine, line 1</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="counter" x-data="{ count: 0 }"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This defines our state, that is, the data we are going to be using to drive dynamic updates to the DOM.  With the state
declared like this, we can now use it <em>within</em> the div element it is declared on.  Let&#8217;s add an <code>output</code> element with
an <code>x-text</code> attribute.</p>
</div>
<div class="paragraph">
<p>Next, we will <em>bind</em> the <code>x-text</code> attribute to the <code>count</code> attribute we declared in the <code>x-data</code> attribute
on the parent <code>div</code> element.  This will have the effect of setting the text of the <code>output</code> element to whatever the
value of <code>count</code> is: if <code>count</code> is updated, so will the text of the <code>output</code>.  This is &#8220;reactive&#8221; programming, in that
the DOM will &#8220;react&#8221; to changes to the backing data.</p>
</div>
<div class="listingblock">
<div class="title">Counter with Alpine, lines 1-2</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="counter" x-data="{ count: 0 }"&gt;
  &lt;output x-text="count"&gt;&lt;/output&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>x-text</code> attribute.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, we need to update the count, using a button.  Alpine allows you to attach event listeners with the <code>x-on</code> attribute.</p>
</div>
<div class="paragraph">
<p>To specify the event to listen for, you add a colon and then the event name after the <code>x-on</code> attribute name.  Then, the
value of the attribute is the JavaScript you wish to execute.  This is similar to the plain <code>on*</code> attributes we discussed
earlier, but it turns out to be much more flexible.</p>
</div>
<div class="paragraph">
<p>We want to listen for a <code>click</code> event, and we want to increment <code>count</code> when a click occurs, so here is what the Alpine
code will look like:</p>
</div>
<div class="listingblock">
<div class="title">Counter with Alpine, the full thing</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="counter" x-data="{ count: 0 }"&gt;
  &lt;output x-text="count"&gt;&lt;/output&gt;

  &lt;button x-on:click="count++"&gt;Increment&lt;/button&gt; <b class="conum">(1)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>With <code>x-on</code>, we specify the attribute in the attribute <em>name</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And that&#8217;s all it takes.  A simple component like a counter should be simple, and Alpine delivers.</p>
</div>
<div class="sect3">
<h4 id="_x_onclick_vs_onclick"><code>x-on:click</code> vs. <code>onclick</code></h4>
<div class="paragraph">
<p>As we said, the Alpine <code>x-on:click</code> attribute (or its shorthand, the <code>@click</code> attribute) is similar to the built-in
<code>onclick</code> attribute.   However, it has additional features that make it significantly more useful:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can listen for events from other elements. For example, the <code>.outside</code> modifier lets you listen to any click event
that is <em>not</em> within the element.</p>
</li>
<li>
<p>You can use other modifiers to:</p>
<div class="ulist">
<ul>
<li>
<p>throttle or debounce event listeners,</p>
</li>
<li>
<p>ignore events that are bubbled up from descendant elements, or</p>
</li>
<li>
<p>attach passive listeners.</p>
</li>
</ul>
</div>
</li>
<li>
<p>You can listen to custom events.  For example, if you wanted to listen for the <code>htmx:after-request</code> event you could write
<code>x-on:htmx:after-request="doSomething()"</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reactivity_and_templating">Reactivity and Templating</h4>
<div class="paragraph">
<p>We hope that you&#8217;ll agree that the AlpineJS version of the counter widget is better, in general, than the VanillaJS
implementation, which was either somewhat hacky or spread out over multiple files.</p>
</div>
<div class="paragraph">
<p>A big part of the power of AlpineJS is that it supports a notion of &#8220;reactive&#8221; variables, allowing you to bind the count
of the <code>div</code> element to a variable that both the <code>output</code> and the <code>button</code> can reference, and properly updating all the
dependencies when a mutation occurs.  Alpine allows for much more elaborate data bindings than what we have demonstrated
here, and it is an excellent general purpose client-side scripting library.</p>
</div>
</div>
<div class="sect3">
<h4 id="_alpine_js_in_action_a_bulk_action_toolbar">Alpine.js in Action: A Bulk Action Toolbar</h4>
<div class="paragraph">
<p>Next, let&#8217;s implement a feature in Contact.app with Alpine. As it stands currently, Contact.app has a &#8220;Delete Selected
Contacts&#8221; button at the very bottom of the page. This button has a long name, is not easy to find and takes up a
lot of room.  If we wanted to add additional &#8220;bulk&#8221; actions, this wouldn&#8217;t really scale very well visually.</p>
</div>
<div class="paragraph">
<p>In this section, we&#8217;ll replace this single button with a toolbar.  Furthermore, the toolbar will only appear when the
user starts selecting contacts. Finally, it will show how many contacts are selected and let you select all contacts in
one go.</p>
</div>
<div class="paragraph">
<p>The first thing we will need to add is an <code>x-data</code> attribute, to hold the state that we will use to determine if the
toolbar is visible or not.  We will need to place this on a parent element of both the toolbar that we are going to
add, as well as the checkboxes, which will be updating the state when they are checked and unchecked.  The best
option given our current HTML is to place the attribute on the <code>form</code> element that surrounds the contacts table.  We
will declare a property, <code>selected</code>, which will be an array that holds the selected contact ids, based on the checkboxes
that are selected.</p>
</div>
<div class="paragraph">
<p>Here is what our form tag will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form x-data="{ selected: [] }"&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is the form that was wrapped around the contacts table.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, at the top of the contacts table, we are going to add a <code>template</code> tag.  A template tag is <em>not</em> rendered by a
browser, by default, so you might be surprised that we are using it.  However, by adding an Alpine <code>x-if</code> attribute,
we can tell Alpine: if a condition is true, show the HTML within this template.</p>
</div>
<div class="paragraph">
<p>Recall that we want to show the toolbar if and only if one or more contacts are selected.  But we know that we will
have the ids of the selected contacts in the <code>selected</code> property.  Therefore, we can check the <em>length</em> of that array
to see if there are any selected contacts, quite easily:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;template x-if="selected.length &gt; 0"&gt; <b class="conum">(1)</b>
  &lt;div class="box info tool-bar"&gt;
    &lt;slot x-text="selected.length"&gt;&lt;/slot&gt;
    contacts selected

    &lt;button type="button" class="bad bg color border"&gt;Delete&lt;/button&gt; <b class="conum">(2)</b>
    &lt;hr aria-orientation="vertical"&gt;
    &lt;button type="button"&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Show this HTML if there are 1 or more selected contacts</p>
</li>
<li>
<p>We will implement these buttons in just a moment</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The next step is to ensure that toggling a checkbox for a given contact adds (or removes) a given contact&#8217;s id from the
<code>selected</code> property.  To do this, we will need to use a new Alpine attribute, <code>x-model</code>.  The <code>x-model</code> attribute allows
you to <em>bind</em> a given element to some underlying data, or its "model".</p>
</div>
<div class="paragraph">
<p>In this case, we want to bind the value of the checkbox inputs to the <code>selected</code> property.  This is how we do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;td&gt;
&lt;input type="checkbox" name="selected_contact_ids" value="{{ contact.id }}" x-model="selected"&gt; <b class="conum">(1)</b>
&lt;/td&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>x-model</code> attribute binds the <code>value</code> of this input to the <code>selected</code> property</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, when a checkbox is checked or unchecked, the <code>selected</code> array will be updated with the given row&#8217;s contact id.
Furthermore, mutations we make to the <code>selected</code> array will similarly be reflected in the checkboxes' state.  This is
known as a <em>two-way</em> binding.</p>
</div>
<div class="paragraph">
<p>With this code written, we can make the toolbar appear and disappear, based on whether contact checkboxes are selected.</p>
</div>
<div class="paragraph">
<p>Very slick.</p>
</div>
<div class="sect4">
<h5 id="_implementing_actions">Implementing Actions</h5>
<div class="paragraph">
<p>Now that we have the mechanics of showing and hiding the toolbar, let&#8217;s look at how to implement the buttons within
the toolbar.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first implement the &#8220;Clear&#8221; button, because it is quite easy.  All we need to do is, when the button is clicked,
clear out the <code>selected</code> array.  Because of the two-way binding that Alpine provides, this will uncheck all the selected
contacts (and then hide the toolbar)!</p>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="paragraph">
<p>For the <em>Cancel</em> button, our job is quite simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button type="button" @click="selected = []"&gt;Cancel&lt;/button&gt;<b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Just reset the <code>selected</code> array</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once again, AlpineJS makes this very easy.</p>
</div>
<div class="paragraph">
<p>The &#8220;Delete&#8221; button, however, will be a bit more complicated.  It will need to do two things: first it will confirm
if the user indeed intends to delete the contacts selected, and, if the user confirms the action, it will use the
htmx JavaScript API to issue a <code>DELETE</code> request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button type="button" class="bad bg color border"
  @click="confirm(`Delete ${selected.length} contacts?`) &amp;&amp; <b class="conum">(1)</b>
    htmx.ajax('DELETE', '/contacts', { source: $root, target: document.body })" <b class="conum">(2)</b>
&gt;Delete&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Confirm the user wishes to delete the selected number of contacts</p>
</li>
<li>
<p>Issue a <code>DELETE</code> using the htmx JavaScript API</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that we are using the short-circuiting behavior of the <code>&amp;&amp;</code> operator in JavaScript to avoid the call to
<code>htmx.ajax()</code> if the <code>confirm()</code> call returns false.</p>
</div>
<div class="paragraph">
<p>The <code>htmx.ajax()</code> function is just a way to access the normal, HTML-driven hypermedia exchange that htmx&#8217;s
HTML attributes give you directly from JavaScript.</p>
</div>
<div class="paragraph">
<p>Looking at how we call <code>htmx.ajax</code>, we first pass in that we want to issue a <code>DELETE</code> to <code>/contacts</code>.  We then pass in
two additional pieces of information: <code>source</code> and <code>target</code>. The <code>source</code> property is the element from which htmx will
collect data to include in the request. We set this to <code>$root</code>, which is a special symbol in Alpine that will be
the element that has the <code>x-data</code> attribute declared on it.  In this case, it will be  the form containing all of our
contacts. The <code>target</code>, or where the response HTML will be placed, is just the entire document&#8217;s body, since the
<code>DELETE</code> handler returns a whole page when it completes.</p>
</div>
<div class="paragraph">
<p>Note that we are using Alpine here in a Hypermedia Driven Application compatible manner.  We <em>could</em> have issued an
AJAX request directly from Alpine and perhaps updated an <code>x-data</code> property depending on the results of that request.
But, instead, we delegated to htmx&#8217;s JavaScript API, which made a <em>hypermedia exchange</em> with the server.</p>
</div>
<div class="paragraph">
<p>This is the key to scripting in a hypermedia-friendly manner within a Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>So, with all of this in place, we now have a much improved experience for performing bulk actions on contacts:  less
visual clutter and the toolbar can be extended with more options without creating bloat in the main interface of our app.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hyperscript">10.6. _hyperscript</h3>
<div class="paragraph">
<p>The final scripting technology we are going to look at is a bit further afield:  <a href="https://hyperscript.org">_hyperscript</a>.</p>
</div>
<div class="paragraph">
<p>While the previous two examples are JavaScript-oriented, _hyperscript is an <em>entirely new</em> scripting language for front-end
development. _hyperscript has a completely different syntax than JavaScript, based on an older language called HyperTalk.
HyperTalk was the scripting language for a technology called HyperCard, an old hypermedia system available on early
Macintosh Computers.</p>
</div>
<div class="paragraph">
<p>The most noticeable thing about _hyperscript is that it resembles English prose more than it resembles other programming
languages. _hyperscript was initially created as a sibling project to htmx, because we felt that JavaScript wasn&#8217;t
event-oriented enough, which made adding small scripting enhancements to htmx applications cumbersome.  Like Alpine,
_hyperscript is a modern jQuery replacement.</p>
</div>
<div class="paragraph">
<p>Also like Alpine, _hyperscript allows you to write your scripting inline, in HTML.</p>
</div>
<div class="paragraph">
<p>Unlike Alpine, however, _hyperscript is <em>not</em> reactive.  It instead focuses on making DOM manipulations in response to events,
easy to write and easy to read. It has built-in language constructs for many DOM operations, preventing you from needing
to navigate the sometimes-verbose JavaScript DOM APIs.</p>
</div>
<div class="paragraph">
<p>We will not be doing a deep dive on the language, but again just want to give you a flavor of what scripting in
_hyperscript is like, so you can pursue the language in more depth later if you find it interesting.</p>
</div>
<div class="paragraph">
<p>Like htmx and AlpineJS, _hyperscript can be installed via a CDN or from npm (package name <code>hyperscript.org</code>):</p>
</div>
<div class="listingblock">
<div class="title">Installing _hyperscript via CDN</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;script src="//unpkg.com/hyperscript.org"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>_hyperscript uses the <code>\_</code> (underscore) attribute for putting scripting on DOM elements.  You may also use the <code>script</code>
or <code>data-script</code> attributes, depending on your HTML validation needs.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how to implement the simple counter component we have been looking at using _hyperscript.  We will place
 an <code>output</code> element and a <code>button</code> inside of a <code>div</code>.  To implement the counter, we will need to add a small bit of
_hyperscript to the button.  On a click, the button should increment the text of the previous <code>output</code> tag.</p>
</div>
<div class="paragraph">
<p>It turns out that that last sentence is nearly valid _hyperscript!</p>
</div>
<div class="paragraph">
<p>Here is our code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div class="counter"&gt;
  &lt;output&gt;0&lt;/output&gt;
  &lt;button _="on click increment the textContent of the previous &lt;output/&gt;"&gt;Increment&lt;/button&gt; <b class="conum">(1)</b>
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is what _hyperscript looks like, believe it or not</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s go through each component of this script:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>on click</code> This is an event listener, telling the button to listen for a <code>click</code> event and then executing
the remaining code</p>
</li>
<li>
<p><code>increment</code> This is a &#8220;command&#8221; in _hyperscript that &#8220;increments&#8221; things, similar to the <code>++</code> operator in JavaScript</p>
</li>
<li>
<p>the &#8220;the&#8221; doesn&#8217;t have any semantic meaning _hyperscript, but can used to make scripts more readable</p>
</li>
<li>
<p><code>textContent of</code> -  This one form of <em>property access</em> in _hyperscript.  You are probably familiar with the JavaScript
syntax <code>a.b</code>, meaning "Get the property <code>b</code> on object <code>a`".  _hyperscript supports this syntax, but <em>also</em> supports
the forms `b of a</code> and <code>a&#8217;s b</code>.  Which one you use should depend on which one is most readable.</p>
</li>
<li>
<p><code>the previous</code> The <code>previous</code> expression in _hyperscript finds the previous element in the DOM that matches some condition</p>
</li>
<li>
<p><code>&lt;output /&gt;</code> This is a <em>query literal</em>, which is a CSS selector wrapped between <code>&lt;</code> and <code>/&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this code, the <code>previous</code> keyword (and the accompanying <code>next</code> keyword) is an example of how _hyperscript makes DOM operations
easier: there is no such native functionality to be found in the standard DOM API, and implementing this in VanillaJS is trickier
than you might think!</p>
</div>
<div class="paragraph">
<p>So, you can see, _hyperscript is very expressive, particularly when it comes to DOM manipulations.  This makes it
easier to embed scripts directly in HTML: since the scripting language is more powerful, scripts written in it tend
to be shorter and easier to read.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Natural Language Programming?</div>
        <div class="paragraph">
<p>Seasoned programmers are often suspicious of _hyperscript: There have been many "natural language programming" (NLP)
projects that target non-programmers and beginner programmers, assuming that being able to read code in their
"natural language" will give them the ability to write it as well.  This has lead to some badly written and
structured code and has failed to live up to the (often over the top) hype.</p>
</div>
<div class="paragraph">
<p>_hyperscript is <em>not</em> an NLP programming language.  Yes, its syntax is inspired in many places
by the speech patterns of web developers. But _hyperscript's readability is achieved not through complex
heuristics or fuzzy NLP processing, but rather through judicious use of common parsing tricks, coupled with a culture
of readability.</p>
</div>
<div class="paragraph">
<p>As you can see in the above example, with the use of a <em>query reference</em>, <code>&lt;output/&gt;</code>,  _hyperscript does not shy away
from using DOM-specific, non-natural language when appropriate.</p>
</div>
    </aside>
<div class="sect3">
<h4 id="_hyperscript_in_action_a_keyboard_shortcut">_hyperscript in action: a keyboard shortcut</h4>
<div class="paragraph">
<p>While the counter demo is a good way to compare various approaches to scripting, the rubber meets the road when
you try to actually implement a useful feature with an approach.  For _hyperscript, let&#8217;s add a keyboard shortcut
to Contact.app: when a user hits Shift-S in our app, we will focus the search field.</p>
</div>
<div class="paragraph">
<p>Since our keyboard shortcut focuses the search input, let&#8217;s put the code for it on that search input, satisfying
locality.</p>
</div>
<div class="paragraph">
<p>Here is the original HTML for the search input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input id="search" name="q" type="search" placeholder="Search Contacts"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will add an event listener using the <code>on keydown</code> syntax, which will fire whenever a keydown occurs.  Further, we
can use an <em>event filter</em> syntax in _hyperscript using square brackets after the event.  In the square brackets we
can place a <em>filter expression</em> that will filter out <code>keydown</code> events we aren&#8217;t interested in.  In our case, we only
want to consider events where the shift key is held down and where the &#8220;S&#8221; key is being pressed.  We can create a
boolean expression that inspects the <code>shiftKey</code> property (to see if it is <code>true</code>) and the <code>code</code> property (to see if
it is <code>"KeyS"</code>) of the event to achieve this.</p>
</div>
<div class="paragraph">
<p>So far our _hyperscript looks like this:</p>
</div>
<div class="listingblock">
<div class="title">A Start On Our Keyboard Shortcut</div>
<div class="content">
<pre class="highlight"><code class="language-hyperscript" data-lang="hyperscript">  on keydown[shiftKey and code is 'KeyS'] ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, by default, _hyperscript will listen for a given event <em>on the element it is declared on</em>.  So, in this case, with
the script we have so far, we would only get <code>keydown</code> events if the search box is already focused.  That&#8217;s not what
we want!  We want to have this key work <em>globally</em>, no matter which element has focus.</p>
</div>
<div class="paragraph">
<p>Not a problem!  We can listen for the <code>keyDown</code> event elsewhere by using a <code>from</code> clause in our event handler.  In this
case we want to listen for the <code>keyDown</code> from the window, and our code ends up looking, naturally, like this:</p>
</div>
<div class="listingblock">
<div class="title">Listening Globally</div>
<div class="content">
<pre class="highlight"><code class="language-hyperscript" data-lang="hyperscript">  on keydown[shiftKey and code is 'KeyS'] from window ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>from</code> clause, we can attach the listener to the window while, at the same time, keeping the code on the
element it logically relates to.</p>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve picked out the event we want to use to focus the search box, let&#8217;s implement the actual focusing by
calling the standard <code>.focus()</code> method.</p>
</div>
<div class="paragraph">
<p>Here is the entire script, embedded in HTML</p>
</div>
<div class="listingblock">
<div class="title">Our Final Script</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input id="search" name="q" type="search" placeholder="Search Contacts"
  _="on keydown[shiftKey and code is 'KeyS'] from the window
       me.focus()"&gt; <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>&#8220;me&#8221; refers to the element that the script is written on.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Given all the functionality, this is surprisingly terse, and, as an English-like programming language, pretty easy to
read.</p>
</div>
</div>
<div class="sect3">
<h4 id="_why_a_new_programming_language">Why a new programming language?</h4>
<div class="paragraph">
<p>This is all well and good, but you may be thinking &#8220;An entirely new scripting language?  That seems excessive.&#8221;  And,
at some level, you are right: JavaScript is a decent scripting language, is very well optimized and is widely understood
in web development.  On the other hand, by creating an entirely new front end scripting language, we had the freedom
to address some problems that we saw generating ugly and verbose code in JavaScript:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Async transparency</dt>
<dd>
<p>In _hyperscript, asynchronous functions (i.e. functions that return <code>Promise</code> instances) can be
invoked <em>as if they were synchronous</em>. Changing a function from sync to async does not break any _hyperscript code that
calls it.  This is achieved by checking for a Promise when evaluating any expression, and suspending the running script
if one exists (only the current event handler is suspended and the main thread is not blocked). JavaScript, instead, requires
either the explicit use of callbacks <em>or</em> the use of explicit <code>async</code> annotations (which can&#8217;t be mixed with synchronous
code).</p>
</dd>
<dt class="hdlist1">Array property access</dt>
<dd>
<p>In _hyperscript, accessing a property on an array (other than <code>length</code> or a number) will return
an array of the values of property on each member of that array, making array property access act like a flat-map operation.
jQuery has a similar feature, but only for its own data structure.</p>
</dd>
<dt class="hdlist1">Native CSS Syntax</dt>
<dd>
<p>In _hyperscript, you can use things like CSS class and ID literals, or CSS query literals, directly
in the language, rather than needing to call out to a wordy DOM API, as you do in JavaScript.</p>
</dd>
<dt class="hdlist1">Deep Event Support</dt>
<dd>
<p>Working with events in _hyperscript is far more pleasant than working with them in JavaScript, with
native support for responding to and sending events, as well as for common event-handling patterns such as &#8220;debouncing&#8221;
or rate limiting events.  _hyperscript also provides declarative mechanisms for synchronizing events within a given element
and across multiple elements.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Again we wish to stress that, in this example, we are not stepping outside the lines of a Hypermedia-Driven
Application: we are only adding front-end, client-side functionality with our scripting.  We are not creating and
managing a large amount of state outside of the DOM itself, or communicating with the server in a non-hypermedia
exchange.</p>
</div>
<div class="paragraph">
<p>Additionally, since _hyperscript embeds so well in HTML, it keeps the focus <em>on the hypermedia</em>, rather than on the
scripting logic.</p>
</div>
<div class="paragraph">
<p>Taken all together, given a certain style of scripting and certain scripting needs, _hyperscript can provide an
excellent scripting experience for your Hypermedia Driven Application.  Of course, it is a small and obscure programming
language, so we won&#8217;t blame you if you decide to pass on it, but it is at least worth a look to understand what it
is trying to achieve, if only out of intellectual interest.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_off_the_shelf_components">10.7. Using Off-the-shelf Components</h3>
<div class="paragraph">
<p>That concludes our look at three different options for <em>your</em> scripting infrastructure, that is, the code that <em>you</em> write
to enhance your Hypermedia Driven Application.  However, there is another major area to consider when discussing client
side scripting: &#8220;off the shelf&#8221; components.  That is, JavaScript libraries that other people have created that offer
some sort of functionality, such as showing modal dialogs.</p>
</div>
<div class="paragraph">
<p>Components have become very popular in the web development works, with libraries like  <a href="https://datatables.net/">DataTables</a>
providing rich user experiences with very little JavaScript code on the part of a user.  Unfortunately, if these libraries
aren&#8217;t integrated well into a website, they can begin to make an application feel &#8220;patched together&#8221;.  Furthermore, some
libraries go beyond simple DOM manipulation, and require that you integrate with a server end point, almost invariably
with a JSON data API.  This means you are no longer building a Hypermedia Driven Application, simply because a particular
widget demands something different.  A shame!</p>
</div>
<div class="sect3">
<h4 id="_integration_options">Integration Options</h4>
<div class="paragraph">
<p>The best JavaScript libraries to work with when you are building a Hypermedia Driven Application are ones that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mutate the DOM but don&#8217;t communicate with a server over JSON</p>
</li>
<li>
<p>Respect HTML norms (e.g. using <code>input</code> elements to store values)</p>
</li>
<li>
<p>Trigger many custom events, as the library updates things</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last point, triggering many custom events (over the alternative of using lots of methods and callbacks) is especially
important, as these custom events can be dispatched or listened to without additional glue code written in a scripting language.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at two different approaches to scripting, one using JavaScript call backs, and one using events.</p>
</div>
<div class="paragraph">
<p>To make things concrete, let&#8217;s  implement a better confirmation dialog for the <code>DELETE</code> button we created in Alpine in the
previous section.  In the original example we used the <code>confirm()</code> function built in to JavaScript, which shows a
pretty bare-bones system confirmation dialog.  We will replace this function with a popular JavaScript library,
SweetAlert2, that shows a much nicer looking confirmation dialog.  Unlink the <code>confirm()</code> function, which blocks
and returns a boolean (<code>true</code> if the user confirmed, <code>false</code> otherwise), SweetAlert2 returns a <code>Promise</code> object, which
is a JavaScript mechanism for hooking in a callback once an asynchronous action (such as waiting for a user to confirm
or deny an action) completes.</p>
</div>
<div class="sect4">
<h5 id="_integrating_using_callbacks">Integrating Using Callbacks</h5>
<div class="paragraph">
<p>With SweetAlert2 installed as a library, you have access to the <code>Swal</code> object, which has a <code>fire()</code> function on it to
trigger showing an alert.  You can pass in arguments to the <code>fire()</code> method to configure exactly what the buttons
on the confirmation dialog look like, what the title of the dialog is, and so forth.  We won&#8217;t get into these details
too much, but you will see what a dialog looks like in a bit.</p>
</div>
<div class="paragraph">
<p>So, given we have installed the SweetAlert2 library, we can swap it in place of the <code>confirm()</code> function call.  We then
need to restructure the code to pass a <em>callback</em> to the <code>then()</code> method on the <code>Promise</code> that <code>Swal.fire()</code> returns.  A
deep dive into Promises is beyond the scope of this chapter, but suffice to say that this callback will be called when
a user confirms or denies the action.  If the user confirmed the action, then the <code>result.isConfirmed</code> property will be
<code>true</code>.</p>
</div>
<div class="paragraph">
<p>Given all that, our updated code will look like this:</p>
</div>
<div class="listingblock">
<div class="title">A Callback-based Confirmation Dialog</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button type="button" class="bad bg color border"
  @click="Swal.fire({  <b class="conum">(1)</b>
                  title: 'Delete these contacts?',  <b class="conum">(2)</b>
                  showCancelButton: true,
                  confirmButtonText: 'Delete'
                }).then((result) =&gt; { <b class="conum">(3)</b>
                  if (result.isConfirmed) {
                    htmx.ajax('DELETE', '/contacts', { source: $root, target: document.body })
                  }
               });"
&gt;Delete&lt;/button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Invoke the <code>Swal.fire()</code> function</p>
</li>
<li>
<p>Configure how the dialog appears</p>
</li>
<li>
<p>Handle the result of the users selection</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And now, when this button is clicked, we get a nice looking dialog in our web application:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_sweet_alert.png" alt="screenshot sweet alert">
</div>
</div>
<div class="paragraph">
<p>Much nicer than the system confirmation dialog.  Still, this feels a little wrong.  This is a lot of code to write
just to trigger a slightly nicer <code>confirm()</code>, isn&#8217;t it?  And the htmx JavaScript code we are using here feels a little
awkward.  It would be more natural to move the htmx out to attributes on the button, as we have been doing, and then
trigger the request via events.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s take a different approach and see how that looks.</p>
</div>
</div>
<div class="sect4">
<h5 id="_integrating_using_events">Integrating Using Events</h5>
<div class="paragraph">
<p>To clean this code up, we will pull the <code>Swal.fire()</code> code out to a custom JavaScript function we will create called
<code>sweetConfirm()</code>.  <code>sweetConfirm()</code> will take the dialog options that are passed into the <code>fire()</code> method, as well as
the element that is confirming an action.  The big difference between the code we already have and <code>sweetConfirm()</code> is
that <code>sweetConfirm()</code>, rather than calling some htmx directly, will, instead, trigger a <code>confirmed</code> event on the
button when the user confirms they wish to delete.</p>
</div>
<div class="paragraph">
<p>Here is what our JavaScript function looks like:</p>
</div>
<div class="listingblock">
<div class="title">An Event-based Confirmation Dialog</div>
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">function sweetConfirm(elt, config) {
      Swal.fire(config) <b class="conum">(1)</b>
          .then((result) =&gt; {
                  if (result.isConfirmed) {
                      elt.dispatchEvent(new Event('confirmed')); <b class="conum">(2)</b>
                  }
          });
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Pass the config through to the <code>fire()</code> function</p>
</li>
<li>
<p>If the user confirmed the action, trigger a <code>confirmed</code> event</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this method available, we can now tighten up our delete button quite a bit.  We can remove all the SweetAlert2
code that we had in the <code>@click</code> Alpine attribute, and simply call this new <code>sweetConfirm()</code> method, passing in the
arguments <code>$el</code>, which is the Alpine syntax for getting `"the current element`" that the script is on, and then
the exact configuration we want for our dialog.</p>
</div>
<div class="paragraph">
<p>If the user confirms the action, a <code>confirmed</code> event will be triggered on the button.  This means that we can go back
to using our trusty htmx attributes!  Namely, we can move <code>DELETE</code> to an <code>hx-delete</code> attribute, and we can we can use
<code>hx-target</code> to target the body.  And then, and here is the crucial step, we can use the <code>confirmed</code> event that is
triggered in the <code>sweetConfirm()</code> function, to trigger the request, but adding an <code>hx-trigger</code> for it.</p>
</div>
<div class="paragraph">
<p>Here is what our code looks like:</p>
</div>
<div class="listingblock">
<div class="title">An Event-based Confirmation Dialog</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;button type="button" class="bad bg color border"
        hx-delete="/contacts" hx-target="body" hx-trigger="confirmed" <b class="conum">(1)</b>
        @click="sweetConfirm($el, <b class="conum">(2)</b>
                { title: 'Delete these contacts?',  <b class="conum">(3)</b>
                  showCancelButton: true,
                  confirmButtonText: 'Delete'})"&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>htmx attributes are back</p>
</li>
<li>
<p>We pass the button in to the function, so an event can be triggered on it</p>
</li>
<li>
<p>We pass through the SweetAlert2 configuration information</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, this event-based code is much cleaner and certainly more &#8220;HTML-ish&#8221;.  The key to this cleaner
implementation is that our new <code>sweetConfirm()</code> function fires an event that htmx is able to listen for.</p>
</div>
<div class="paragraph">
<p>This is why a rich event model is important to look for when choosing a library to work with, both with htmx and with
Hypermedia-Driven Applications in general.</p>
</div>
<div class="paragraph">
<p>Unfortunately, due to the prevalence and dominance of the JavaScript-first mindset today, many libraries are like
SweetAlert2: they expect you to pass a callback in the first style.  In these cases you can use the technique we
have demonstrated here, wrapping the library in a function that triggers events in a callback, to make the library more
hypermedia and htmx-friendly.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pragmatic_scripting">10.8. Pragmatic Scripting</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>In case of conflict, consider users over authors over implementors over specifiers over theoretical purity.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; W3C<br>
<cite>HTML Design Principles § 3.2 Priority of Constituencies</cite>
</div>
</div>
<div class="paragraph">
<p>We have shown you quite a few tools and techniques for scripting in a Hypermedia Driven Application.  How should you
pick between them?  The sad truth is that there will never be a single, always correct answer to this question.</p>
</div>
<div class="paragraph">
<p>Are you committed to vanilla JavaScript-only, perhaps due to company policy?  Well, you can use vanilla JavaScript effectively
to script your Hypermedia-Driven Application.</p>
</div>
<div class="paragraph">
<p>Do you have more leeway and like the look of Alpine.js?  That&#8217;s a great way to add more structured, localized JavaScript
to your application, and offers some nice reactive features as well.</p>
</div>
<div class="paragraph">
<p>Are you a bit more bold in your technical choices?  Maybe _hyperscript would be worth taking a look at.  (We certainly think so.)</p>
</div>
<div class="paragraph">
<p>Sometimes you might even consider picking two (or more) of these approaches within an application.  Each has its own
strengths and weaknesses, and all of them are relatively small and self-contained, so picking the right tool for the job
at hand might be the best approach.</p>
</div>
<div class="paragraph">
<p>In general, we encourage a <em>pragmatic</em> approach to scripting: whatever feels right is probably right (or, at least,
right <em>enough</em>) for you.  Rather than being concerned about which particular approach is taken for your scripting,
we would focus with these more general concerns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoiding communicating with the server via JSON data APIs</p>
</li>
<li>
<p>Avoiding storing large amounts of state outside of the DOM</p>
</li>
<li>
<p>Favoring using events, rather than hard-coded callbacks or method calls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But even on these topics, sometimes a web developer has to do what a web developer has to do.  If the perfect widget
for your application exists but, darn it, it uses a JSON data API, that&#8217;s OK.</p>
</div>
<div class="paragraph">
<p>Just don&#8217;t make it a habit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_json_data_apis_hypermedia_driven_applications">11. JSON Data APIs &amp; Hypermedia Driven Applications</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_json_data_apis">JSON Data APIs</h3>
<div class="paragraph">
<p>So far we have been focusing on using hypermedia to build Hypermedia-Driven Applications.  In doing so we are
following the original networking architecture of the web, and building a RESTful system, in the original sense
of that term.</p>
</div>
<div class="paragraph">
<p>However, today, we should acknowledge that many web applications are often <em>not</em> built using this approach.  Instead, they use a
Single Page Application front end library such as React to build their application, and they interact with the server
via a JSON API.  This JSON API almost never uses hypermedia concepts.  Rather JSON APIs tend to be <em>Data APIs</em>, that
is, an API that simply returns structured domain data to the client without any hypermedia control information.  The client
itself must know how to interpret the JSON Data: what end points are associated with the data, how certain fields should
be interpreted, and so on.</p>
</div>
<div class="paragraph">
<p>Now, believe it or not, we <em>have</em> been creating an API for Contact.app.</p>
</div>
<div class="paragraph">
<p>This may sound confusing to you: an API?  We have just been creating a web application, with handlers that just return
HTML.</p>
</div>
<div class="paragraph">
<p>How is that an API?</p>
</div>
<div class="paragraph">
<p>It turns out that Contact.app is, indeed, providing an API.  It just happens to be a <em>hypermedia</em> API that a <em>hypermedia client</em>,
that is, a browser, understands.  We are building an API for the browser to interact with over HTTP, and, thanks to the
magic of HTML and hypermedia, the browser doesn&#8217;t need to know anything about our hypermedia API beyond an entry point
URL: all the actions and display information comes, self-contained, within the HTML responses.</p>
</div>
<div class="paragraph">
<p>Building RESTful web applications like this is so natural and simple that you might not think of it as an API at all, but
we assure you, it is.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hypermedia_apis_json_data_apis">11.1. Hypermedia APIs &amp; JSON Data APIs</h3>
<div class="paragraph">
<p>So, we have a hypermedia API for Contact.app.  Should we include a Data API for Contact.app as well?</p>
</div>
<div class="paragraph">
<p>Sure!  The existence of a hypermedia API <em>in no way means</em> that you can&#8217;t <em>also</em> have a Data API.  In fact, this is a
common situation in traditional web applications: there is the &#8220;web application&#8221; that is entered through that entry point
URL, say <code><a href="https://mywebapp.example.com/" class="bare">https://mywebapp.example.com/</a></code>.  And there is also a <em>separate</em> JSON API that is accessible through another
URL, perhaps <code><a href="https://api.mywebapp.example.com/v1" class="bare">https://api.mywebapp.example.com/v1</a></code>.</p>
</div>
<div class="paragraph">
<p>This is a perfectly reasonable way to split up the hypermedia interface to your application and the Data API you provide
to other, non-hypermedia clients.</p>
</div>
<div class="paragraph">
<p>Why would you want to include a Data API along with a hypermedia API?  Well, because <em>non-hypermedia clients</em> might also
want to interact with your application as well.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Perhaps you have a mobile application that isn&#8217;t built using Hyperview.  That application will need to interact with
your server somehow, and using the existing HTML API would almost certainly be a poor fit!  You want programmatic
access to your system via a Data API, and JSON is a natural choice for this.</p>
</li>
<li>
<p>Perhaps you have an automated script that needs to interact with the system on a regular basis.  For example, maybe we
have a bulk-import job that runs nightly, and needs to import/sync thousands of contacts.  While it would be possible
to script this against the HTML API, it would also be annoying: parsing HTML in scripts is error prone and tedious.  It
would be better to have a simple JSON API for this use case.</p>
</li>
<li>
<p>Perhaps there are 3rd party clients who wish to integrate with your system&#8217;s data in some way.  Maybe a partner
wants to synchronize data nightly.  As with the bulk-import example, this isn&#8217;t a great use case for an HTML-based API,
and it would make more sense to provide something more amenable to scripting.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For all of these use cases, a JSON Data API makes sense: in each case the API is not being consumed by a hypermedia client,
so presenting an HTML-based hypermedia API would be inefficient and complicated for the client to deal with.  A simple JSON Data API fits the bill for what we want and, as always, we recommend using the right tool for the job.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">&#8220;What!?!  You Want Me To Parse HTML!?!&#8221;</div>
        <div class="paragraph">
<p>A confusion we often run into in online discussions when we advocate a hypermedia approach to building web
applications is that people think we mean that they should parse the HTML responses from the server, and then dump the
data into their SPA framework or mobile applications.</p>
</div>
<div class="paragraph">
<p>This is, of course, silly.</p>
</div>
<div class="paragraph">
<p>What we mean, instead, is that you should consider using a hypermedia API <em>with a hypermedia client</em>, like the browser,
interpreting the hypermedia response itself and presenting it to the user. A hypermedia API can&#8217;t simply be welded on
top of an existing SPA approach.  It requires a sophisticated hypermedia client such as the browser to be consumed
effectively.</p>
</div>
<div class="paragraph">
<p>If you are writing code to tease apart your hypermedia only to then treat as data to feed into a client-side model,
you are probably doing it wrong.</p>
</div>
    </aside>
<div class="sect3">
<h4 id="_differences_between_hypermedia_apis_data_apis">Differences Between Hypermedia APIs &amp; Data APIs</h4>
<div class="paragraph">
<p>Let&#8217;s accept for a moment that we <em>are</em> going to have a Data API for our application, in addition to our hypermedia API.
At this point, some developers may be wondering: why have both?  Why not have a single API, the JSON Data API, and have
multiple clients use this one API to communicate with it?</p>
</div>
<div class="paragraph">
<p>Isn&#8217;t it redundant to have both types of APIs for our application?</p>
</div>
<div class="paragraph">
<p>This is a reasonable point: we do advocate having multiple APIs to your web application if necessary and, yes, this may
lead to some redundancy in code.  However, there are distinct advantages to both sorts of APIs and, even more so,
distinct requirements for both sorts of APIs.</p>
</div>
<div class="paragraph">
<p>By supporting both of these types of APIs separately you can get the strengths of both, while keeping their varying
styles of code and infrastructure needs cleanly split out.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s contrast the needs of JSON APIs with Hypermedia APIs:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">JSON API Needs</th>
<th class="tableblock halign-left valign-top">Hypermedia API</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It must remain stable over time: you cannot change the API willy nilly or you risk breaking clients that use the API
and expect certain end points to behave in certain ways</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>There is no need to remain stable over time: all URLs are discovered via HTML responses, so you can be much more aggressive in changing the shape of a hypermedia API</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It must be versioned: related to the first point, when you do make a major change, you need to version the API so that clients that are using the old API continue to work</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This means that versioning is not an issue, another strength of the hypermedia approach</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It should be rate limited: since data APIs are often used by other clients, not just your own internal web application, requests should be rate limited, often by user, in order to avoid a single client overloading the system</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Rate limiting probably isn&#8217;t as important beyond the prevention of Distributed Denial of Service (DDoS) attacks</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It should be a general API: since the API is for <em>all</em> clients, not just for your web application, you should avoid specialized end points that are driven by your own application needs.  Instead, the API should be general and expressive enough to satisfy as many potential client needs as possible.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The API can be <em>very specific</em> to your application needs: since it is designed only for your particular web application, and since the API is discovered through hypermedia, you can add and remove highly tuned end points for specific features or optimization needs in your application</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Authentication for these sorts of API is typically token based, which we will discuss in more detail later</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Authentication is typically managed through a session cookie established by a login page</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>These two different types of APIs have different strengths and needs, so it makes sense to use both. The hypermedia
approach can be used for your web application, allowing you to specialize the API for the &#8220;shape&#8221;
of your application.  The Data API approach can be used for other, non-hypermedia clients like mobile, integration
partners, etc.</p>
</div>
<div class="paragraph">
<p>Note in particular that, by splitting these two APIs apart from one another, you reduce the pressure that running your web
application through your general Data API produces to be constantly changing the API to address application needs.  Rather
than being thrashed around with every feature change, your Data API can focus on remaining stable and reliable.</p>
</div>
<div class="paragraph">
<p>This is the core strength of splitting your Data API from your Hypermedia API, in our opinion.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">JSON Data APIs vs JSON &#8220;REST&#8221; APIs</div>
        <div class="paragraph">
<p>Unfortunately, today, for historical reasons, what we are calling JSON Data APIs are often referred to
&#8220;REST APIs&#8221; in the industry.  This is ironic, because, by any reasonable reading of Roy Fielding&#8217;s work defining what REST
means, the vast majority of JSON APIs are <em>not</em> RESTful.  Not even close.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the
SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.</p>
</div>
<div class="paragraph">
<p>What needs to be done to make the REST architectural style clear on the notion that hypertext is a constraint? In other
words, if the engine of application state (and hence the API) is not being driven by hypertext, then it cannot be RESTful
and cannot be a REST API. Period. Is there some broken manual somewhere that needs to be fixed?</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Roy Fielding<br>
<cite>https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</cite>
</div>
</div>
<div class="paragraph">
<p>The story of how &#8220;REST API&#8221; came to mean &#8220;JSON APIs&#8221; in the industry is a long and sordid one, and beyond the
scope of this book.  However, if you are interested, you can refer to an essay entitled &#8220;How Did REST Come To Mean The Opposite of
REST?&#8221; on the htmx website:</p>
</div>
<div class="paragraph">
<p><a href="https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest/" class="bare">https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest/</a></p>
</div>
<div class="paragraph">
<p>In this book we will use the term &#8220;Data API&#8221; to describe these JSON APIs, while acknowledging that many people
in the industry will continue to call them &#8220;REST APIs&#8221; for the foreseeable future.</p>
</div>
    </aside>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_json_data_api_to_contact_app">11.2. Adding a JSON Data API To Contact.app</h3>
<div class="paragraph">
<p>Alright, so how are we going to add a JSON Data API to our application?  One approach, popularized by the Ruby on Rails
web framework, is to use the same URL endpoints as your hypermedia application, but use the HTTP <code>Accept</code> header to
determine if the client wants a JSON representation or an HTML representation.  The HTTP <code>Accept</code> header allows a client
to specify what sort of  Multipurpose Internet Mail Extensions (MIME) types, that is file types, it wants back from the
server: JSON, HTML, text and so on.</p>
</div>
<div class="paragraph">
<p>So, if the client wanted a JSON representation of all contacts, they might issue a <code>GET</code> request that looks like this:</p>
</div>
<div class="listingblock">
<div class="title">A Request for a JSON Representation of All Contacts</div>
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">Accept: application/json

GET /contacts</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we adopted this pattern then our request handler for <code>/contacts/</code> would need to be updated to inspect this header and,
depending on the value, return a JSON rather than HTML representation for the contacts.  Ruby on Rails has support for
this pattern baked into the framework, making it very easy to switch on the requested MIME type.</p>
</div>
<div class="paragraph">
<p>Unfortunately, our experience with this pattern has not been great, for reasons that should be clear given the
differences we outlined between Data and hypermedia APIs: they have different needs and often take on very different
&#8220;shapes&#8221;, and trying to pound them into the same set of URLs ends up creating a lot of tension in the application code.</p>
</div>
<div class="paragraph">
<p>Given the different needs of the two APIs and our experience managing multiple APIs like this, we think separating the two
 from one another, and, therefore, breaking the JSON Data API out to its own set of URLs is the right choice.  This will
allow us to evolve the two APIs separately from one another, and give us room to improve each independently, in a manner
consistent with their own individual strengths.</p>
</div>
<div class="sect3">
<h4 id="_picking_a_root_url_for_our_api">Picking a Root URL For Our API</h4>
<div class="paragraph">
<p>Given that we are going to split our JSON Data API routes out from our regular hypermedia routes, where should we place
them?  One important consideration here is that we want to make sure that we can version our API cleanly in some way,
regardless of the pattern we choose.</p>
</div>
<div class="paragraph">
<p>Looking around, a lot of places use a subdomain for their APIs, something
like <code><a href="https://api.mywebapp.example.com" class="bare">https://api.mywebapp.example.com</a></code> and, in fact, often encode versioning in the subdomain: <code><a href="https://v1.api.mywebapp.example.com" class="bare">https://v1.api.mywebapp.example.com</a></code>.</p>
</div>
<div class="paragraph">
<p>While this makes sense for large companies, it seems like a bit of overkill for our modest little Contact.app.  Rather
than using subdomains, which are a pain for local development, we will use sub-paths within the existing application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We will use <code>/api</code> as the root for our Data API functionality</p>
</li>
<li>
<p>We will use <code>/api/v1</code> as the entry point for version 1 of our Data API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If and when we decide to bump the API version, we can move to <code>/api/v2</code> and so on.</p>
</div>
<div class="paragraph">
<p>This approach isn&#8217;t perfect, of course, but it will work for our simple application and can be adapted to a subdomain
approach or various other methods at a later point, when our Contact.app has taken over the internet and we can afford
a large team of API developers.  :)</p>
</div>
</div>
<div class="sect3">
<h4 id="_our_first_json_endpoint_listing_all_contacts">Our First JSON Endpoint: Listing All Contacts</h4>
<div class="paragraph">
<p>Let&#8217;s add our first Data API end point.  It will handle an HTTP <code>GET</code> request to <code>/api/v1/contacts</code>, and return
a JSON list of all contacts in the system.  In some ways it will look quite a bit like our initial code for the
hypermedia route <code>/contacts</code>: we will load all the contacts from the contacts database and then render some text
as a response.</p>
</div>
<div class="paragraph">
<p>We are also going to take advantage of a nice feature of Flask: if you simply return an object from a handler, it will
serialized (that is, convert) that object into a JSON response.  This makes it very easy to build simple JSON APIs
in flask!</p>
</div>
<div class="paragraph">
<p>Here is our code:</p>
</div>
<div class="listingblock">
<div class="title">A JSON Data API To Return All Contacts</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/api/v1/contacts", methods=["GET"]) <b class="conum">(1)</b>
def json_contacts():
    contacts_set = Contact.all()
    contacts_dicts = [c.__dict__ for c in contacts_set] <b class="conum">(2)</b>
    return {"contacts": contacts_dicts} <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>JSON API gets its own path, starting with <code>/api</code></p>
</li>
<li>
<p>Convert the contacts array into an array of simple dictionary (map) objects</p>
</li>
<li>
<p>Return a dictionary that contains a <code>contacts</code> property of all the contacts</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This Python code might look a little foreign to you if you are not a Python developer, but all we are doing is converting
our contacts into an array of simple name/value pairs and returning that array in an enclosing object as the <code>contacts</code>
property.  This object will be serialized into a JSON response automatically by Flask.</p>
</div>
<div class="paragraph">
<p>With this in place, if we make an HTTP <code>GET</code> request to <code>/api/v1/contacts</code>, we will see a response that looks something
like this:</p>
</div>
<div class="listingblock">
<div class="title">Some Sample Data From Our API</div>
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "contacts": [
    {
      "email": "carson@example.com",
      "errors": {},
      "first": "Carson",
      "id": 2,
      "last": "Gross",
      "phone": "123-456-7890"
    },
    {
      "email": "joe@example2.com",
      "errors": {},
      "first": "",
      "id": 3,
      "last": "",
      "phone": ""
    },
    ...
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, you can see, we now have a way to get a relatively simple JSON representation of our contacts via an HTTP request.
Not perfect, but good enough for the purposes of this book!  It&#8217;s certainly good enough to write some basic automated
scripts against.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You could move your contacts to another system on a nightly basis</p>
</li>
<li>
<p>You could back your contacts up to a local file</p>
</li>
<li>
<p>You could automate an email blast to your contacts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Having this small JSON Data API opens up a lot of automation possibilities that would be messier to achieve with our existing
hypermedia API.</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_contacts">Adding Contacts</h4>
<div class="paragraph">
<p>Let&#8217;s move on the next piece of functionality: adding a new contact to the system.  Once again, our code is going
to look similar in some ways to the code that we wrote for our normal web application.  However, here we are also
going to see the JSON API and the hypermedia API for our web application begin to obviously diverge.</p>
</div>
<div class="paragraph">
<p>In the web application, we needed a separate path, <code>/contacts/new</code> to host the HTML form for creating a new contact.  In
the web application we made the decision to issue a <code>POST</code> to that same path to keep things consistent.</p>
</div>
<div class="paragraph">
<p>In the case of the JSON API, there is no such path needed: the JSON API &#8220;just is&#8221;: it doesn&#8217;t need to provide any
hypermedia representation for creating a new contact.  You simply know where to issue a <code>POST</code> to, to create a contact,
likely through some documentation provided about the API, and that&#8217;s it.</p>
</div>
<div class="paragraph">
<p>Because of that fact, we can put the &#8220;create&#8221; handler on the same path as the &#8220;list&#8221; handler: <code>/api/v1/contacts</code>, but
have it respond only to HTTP <code>POST</code> requests.</p>
</div>
<div class="paragraph">
<p>The code here is relatively straightforward: populate a new contact with the information from the <code>POST</code> request,
attempt to save it, and&#8201;&#8212;&#8201;if it is not successful&#8201;&#8212;&#8201;show error messages.  Here is the code:</p>
</div>
<div class="listingblock">
<div class="title">Adding Contacts With Our JSON API</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/api/v1/contacts", methods=["POST"]) <b class="conum">(1)</b>
def json_contacts_new():
    c = Contact(None, request.form.get('first_name'), request.form.get('last_name'), request.form.get('phone'),
                request.form.get('email')) <b class="conum">(2)</b>
    if c.save(): <b class="conum">(3)</b>
        return c.__dict__
    else:
        return {"errors": c.errors}, 400 <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This handler is on the same path as the first one for our JSON API, but handles <code>POST</code> requests.</p>
</li>
<li>
<p>We create a new Contact based on values submitted with the request.</p>
</li>
<li>
<p>We attempt to save the contact and, if successful, render it as a JSON object.</p>
</li>
<li>
<p>If the save is not successful, we render an object showing the errors, with a response code of <code>400 (Bad Request)</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In some ways this is similar to our <code>contacts_new()</code> handler from our web application; we are creating the contact and attempting
to save it. In other ways it is very different:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is no redirection happening here on a successful creation, because we are not dealing with a hypermedia client
like the browser.</p>
</li>
<li>
<p>In the case of a bad request, we simply return an error response code, <code>400 (Bad Request)</code>.  This is in contrast with
the web application, where we simply re-render the form with error messages in it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These sorts of differences, over time, build up and make the idea of keeping your JSON and hypermedia APIs
on the same set of URLs less and less appealing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_viewing_contact_details">Viewing Contact Details</h4>
<div class="paragraph">
<p>Next, let&#8217;s make it possible for a JSON API client to download the details for a single contact.  We will naturally use an
HTTP <code>GET</code> for this functionality and will follow the convention we established for our regular web application, and
put the path at <code>/api/v1/contacts/&lt;contact id&gt;</code>. So, for example, if you want to see the details of the contact with the
id <code>42</code>, you would issue an HTTP <code>GET</code> to <code>/api/v1/contacts/42</code>.</p>
</div>
<div class="paragraph">
<p>This code is quite simple:</p>
</div>
<div class="listingblock">
<div class="title">Getting the Details of a Contact in JSON</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/api/v1/contacts/&lt;contact_id&gt;", methods=["GET"]) <b class="conum">(1)</b>
def json_contacts_view(contact_id=0):
    contact = Contact.find(contact_id) <b class="conum">(2)</b>
    return contact.__dict__ <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a new <code>GET</code> route at the path we want to use for viewing contact details</p>
</li>
<li>
<p>Look the contact up via the id passed in through the path</p>
</li>
<li>
<p>Convert the contact to a dictionary, so it can be rendered as JSON response</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Nothing too complicated: we look the contact up by ID, provided in the path to the controller, and look that contact up.
We then render it as JSON.  You have to appreciate the simplicity of this code!</p>
</div>
<div class="paragraph">
<p>Next, let&#8217;s add updating and deleting a contact as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_updating_deleting_contacts">Updating &amp; Deleting Contacts</h4>
<div class="paragraph">
<p>As with the create contact API end point, because there is no HTML UI to produce for them, we can reuse the
<code>/api/v1/contacts/&lt;contact id&gt;</code> path.  We will use the <code>PUT</code> HTTP method for updating a contact and the <code>DELETE</code>
method for deleting one.</p>
</div>
<div class="paragraph">
<p>Our update code is going to look nearly identical to the create handler, except that, rather than creating a new contact,
we will look up the contact by ID and update its fields.  In this sense we are just combining the code of the create
handler and the detail view handler.</p>
</div>
<div class="listingblock">
<div class="title">Updating A Contact With Our JSON API</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/api/v1/contacts/&lt;contact_id&gt;", methods=["PUT"]) <b class="conum">(1)</b>
def json_contacts_edit(contact_id):
    c = Contact.find(contact_id) <b class="conum">(2)</b>
    c.update(request.form['first_name'], request.form['last_name'], request.form['phone'], request.form['email']) <b class="conum">(3)</b>
    if c.save(): <b class="conum">(4)</b>
        return c.__dict__
    else:
        return {"errors": c.errors}, 400</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We handle <code>PUT</code> requests to the URL for a given contact</p>
</li>
<li>
<p>Look the contact up via the id passed in through the path</p>
</li>
<li>
<p>We update the contact&#8217;s data from the values included in the request</p>
</li>
<li>
<p>From here on the logic is identical to the <code>json_contacts_create()</code> handler</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once again, very regular and, thanks to the built-in functionality in Flask, simple to implement.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at deleting a contact now.  This turns out to be even simpler: as with the update handler we are going to
look up the contact by id, and then, well, delete it.  At that point we can return a simple JSON object indicating
success.</p>
</div>
<div class="listingblock">
<div class="title">Deleting A Contact With Our JSON API</div>
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.route("/api/v1/contacts/&lt;contact_id&gt;", methods=["DELETE"]) <b class="conum">(1)</b>
def json_contacts_delete(contact_id=0):
    contact = Contact.find(contact_id)
    contact.delete() <b class="conum">(2)</b>
    return jsonify({"success": True}) <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We handle <code>DELETE</code> requests to the URL for a given contact</p>
</li>
<li>
<p>Look the contact up and invoke the <code>delete()</code> method on it</p>
</li>
<li>
<p>Return a simple JSON object indicating that the contact was successfully deleted</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And, with that, we have our simple little JSON Data API to live alongside our regular web application, nicely separated
out from the main web application, so it can evolve separately as needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_additional_data_api_considerations">Additional Data API Considerations</h4>
<div class="paragraph">
<p>Now, we obviously have a lot more to do if we want to make this a production ready JSON API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We don&#8217;t have any rate limiting, which is important for any publicly facing Data API to avoid abusive clients.</p>
</li>
<li>
<p>Even more crucially, there is currently no authentication mechanism.  (We don&#8217;t have one for our web application either!)</p>
</li>
<li>
<p>We currently don&#8217;t support paging of our contact data.</p>
</li>
<li>
<p>Lots of small issues that we aren&#8217;t addressing, such as rendering a proper <code>404 (Not Found)</code> response if someone makes
a request with a contact id that doesn&#8217;t exist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A full discussion around all of these topics is beyond the scope of this book, but we&#8217;d like to focus in on one in
particular, authentication, in order to show the difference between our hypermedia and JSON API.  In order to secure
our application we need to add <em>authentication</em>, some mechanism for determining who a request is coming from, and
also <em>authorization</em>, determining if they have the right to perform the request.</p>
</div>
<div class="paragraph">
<p>We will set authorization aside for now and consider only authentication.</p>
</div>
<div class="sect4">
<h5 id="_authentication_in_web_applications">Authentication in Web Applications</h5>
<div class="paragraph">
<p>In the HTML web application world, authentication has traditionally been done via a login page that asks a user for
their username (often their email) and a password.  This password is then checked against a database of (hashed)
passwords to establish that the user is who they say they are.  If the password is correct, then a <em>session cookie</em>
is established, indicating who the user is.  This cookie is then sent with every request that the user makes to
the web application, allowing the application to know which user is making a given request.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">HTTP Cookies</div>
        <div class="paragraph">
<p>HTTP Cookies are kind of a strange feature of HTTP.  In some ways they violate the goal of remaining stateless, a
major component of the RESTful architecture: a server will often use a session cookie as an index into state kept
on the server &#8220;on the side&#8221;, such as a cache of the last action performed by the user.</p>
</div>
<div class="paragraph">
<p>Nonetheless, cookies have proven extremely useful and so people tend not to complain about this aspect of them too much
(We are not sure what our other options would be here!)  An interesting example of pragmatism gone (relatively) right in
web development.</p>
</div>
    </aside>
<div class="paragraph">
<p>In comparison with the typical web application approach to authentication, a JSON API will typically use some sort of
<em>token based</em> authentication: an authentication token will be established via a mechanism like OAuth, and that authentication
token will then be passed, often as an HTTP Header, with every request that a client makes.</p>
</div>
<div class="paragraph">
<p>At a high level this is similar to what happens in normal web application authentication: a token is established somehow
and then then token is part of every request.  However, in practice, the mechanics tend to be wildly different:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cookies are part of the HTTP specification and can be easily <em>set</em> by an HTTP Server</p>
</li>
<li>
<p>JSON Authentication tokens, in contrast, often require elaborate exchange mechanics like OAuth to be established</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These differing mechanics for establishing authentication are yet another good reason for splitting our JSON and hypermedia
APIs up.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_shape_of_our_two_apis">The &#8220;Shape&#8221; of Our Two APIs</h4>
<div class="paragraph">
<p>When we were building out our API, we noted that in many cases the JSON API didn&#8217;t require as many end points as our
hypermedia API did: we didn&#8217;t need a <code>/contacts/new</code> handler, for example, to provide a hypermedia representation for
creating contacts.</p>
</div>
<div class="paragraph">
<p>Another aspect of our hypermedia API to consider was the performance improvement we made: we pulled the total contact count
out to a separate end point and implemented the &#8220;Lazy Load&#8221; pattern, to improve the perceived performance of our
application.</p>
</div>
<div class="paragraph">
<p>Now, if we had both our hypermedia and JSON API sharing the same paths, would we want to publish this API as a JSON
end point as well?</p>
</div>
<div class="paragraph">
<p>Maybe, but maybe not.  This was a pretty specific need for our web application, and, absent a request from a user of
our JSON API, it doesn&#8217;t make sense to include it for JSON consumers.</p>
</div>
<div class="paragraph">
<p>And what if, by some miracle, the performance issues with <code>Contact.count()</code> that we were addressing with the Lazy Load
pattern goes away?  Well, in our Hypermedia Driven Application we can simply revert to the old code and include the
count directly in the request to <code>/contacts</code>.  We can remove the <code>contacts/count</code> end point and all the logic associated
with it.  Because of the uniform interface of hypermedia, the system will continue to work just fine.</p>
</div>
<div class="paragraph">
<p>But what if we had tied our JSON API and hypermedia API together, and published <code>/contacts/count</code> as a supported end
point for our JSON API?  In that case we couldn&#8217;t simply remove the end point: a (non-hypermedia) client might be
relying on it.</p>
</div>
<div class="paragraph">
<p>Once again you can see the flexibility of the hypermedia approach and why separating your JSON API out from your
hypermedia API lets you take maximum advantage of that flexibility.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_model_view_controller_mvc_paradigm">The Model View Controller (MVC) Paradigm</h4>
<div class="paragraph">
<p>One thing you may have noticed about the handlers for our JSON API is that they are relatively simple and regular.
Most of the hard work of updating data and so forth is done within the contact model itself: the handlers act as simple
connectors that provide a go-between the HTTP requests and the model.</p>
</div>
<div class="paragraph">
<p>This is the ideal controller of the Model-View-Controller (MVC) paradigm that was so popular in the early web: a controller
should be &#8220;thin&#8221;, with the model containing the majority of the logic in the system.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The Model View Controller Pattern</div>
        <div class="paragraph">
<p>The Model View Controller design pattern is a classic architectural pattern in software development, and was a major
influence in early web development.  It is no longer emphasized as heavily, as web development has split into front-end
and back-end camps, but most web developers are still familiar with the idea.</p>
</div>
<div class="paragraph">
<p>Traditionally, the MVC pattern mapped into web development like so:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Model - A collection of &#8220;domain&#8221; classes that implement all the logic and rules for the particular domain your application
is designed for.  The model typically provides &#8220;resources&#8221; that are then presented to clients as HTML &#8220;representations&#8221;.</p>
</li>
<li>
<p>View - Typically views would be some sort of client-side templating system, and would render the aforementioned HTML representation
for a given Model instance.</p>
</li>
<li>
<p>Controller - The controllers job is to take HTTP requests, convert them into sensible requests to the Model and forward
those requests on to the appropriate Model objects.  It then passes the HTML representation back to the client as an
HTTP response.</p>
</li>
</ul>
</div>
    </aside>
<div class="paragraph">
<p>Thin controllers make it easy to split your JSON and hypermedia APIs out, because all the important logic lives in the domain
model that is shared by both.  This allows you to evolve both separately, while still keeping logic in sync with one
another.</p>
</div>
<div class="paragraph">
<p>With properly built &#8220;thin&#8221; controllers and &#8220;fat&#8221; models, keeping two separate APIs both in sync and yet
still evolving separately is not as difficult or as crazy as it might sound at first.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_bringing_hypermedia_to_mobile" class="sect0">Bringing Hypermedia To Mobile</h1>
<div class="sect1">
<h2 id="_hyperview_a_mobile_hypermedia">12. Hyperview: A Mobile Hypermedia</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Shortcomings with the current state of mobile app development</p>
</li>
<li>
<p>How a hypermedia architecture can address these problems</p>
</li>
<li>
<p>Hyperview as a mobile app framework that uses the hypermedia architecture</p>
</li>
<li>
<p>An overview of HXML, the hypermedia format used by Hyperview</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may be forgiven for thinking the hypermedia architecture is synonymous with the Web, web browsers, and HTML.
No doubt, the Web is the largest hypermedia system, and web browsers are the most popular hypermedia client.
The dominance of the Web in discussions about hypermedia make it easy to forget that hypermedia is a general concept, and can be applied to all types of platforms and applications.
In this chapter, we will see the hypermedia architecture applied to a non-web platform: native mobile applications.
Mobile as a platform has different constraints than the Web.
It requires different trade-offs and design decisions.
Nonetheless, the concepts of hypermedia, HATEOAS, and REST can be directly applied to build delightful mobile applications!</p>
</div>
<div class="sect2">
<h3 id="_the_state_of_mobile_app_development">12.1. The state of mobile app development</h3>
<div class="paragraph">
<p>Before we can discuss how to apply hypermedia to mobile platforms, we need to understand how native mobile apps are commonly built.
I&#8217;m using the word &#8220;native&#8221; to refer to code written against an SDK provided by the phone&#8217;s operating system (typically Android or iOS).
This code is packaged into an executable binary, and uploaded &amp; approved through app stores controlled by Google and Apple.
When users install or update an app, they&#8217;re downloading this executable and running the code directly on their device&#8217;s OS.
In this way, mobile apps have a lot in common with old-school desktop apps for Mac, Windows, or Linux.
There is one important difference between PC desktop apps of yesteryear and today&#8217;s mobile apps.
These days, almost all mobile apps are &#8220;networked&#8221;.
By networked, we mean the app needs to read and write data over the Internet to deliver its core functionality.
In other words, a networked mobile app needs to implement the client-server architecture.</p>
</div>
<div class="paragraph">
<p>When implementing the client-server architecture, the developer needs to make a decision: Should the app be designed as a thin client or thick client?
The current mobile ecosystems strongly push developers towards a thick-client approach.
Why?
Remember, Android and iOS require that a native mobile app be packaged and distributed as an executable binary.
There&#8217;s no way around it.
Since the developer needs to write code to package into an executable, it seems logical to implement some of the app&#8217;s logic in that code.
The code may as well initiate HTTP calls to the server to retrieve data, and then render that data using the platform&#8217;s UI libraries.
Thus, developers are naturally led into a thick-client pattern that looks something like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The client contains code to make API requests to the server, and code to translate those responses to UI updates</p>
</li>
<li>
<p>The server implements an HTTP API that speaks JSON, and knows little about the state of the client</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just like with SPAs on the web, this architecture has a big downside: the app&#8217;s logic gets spread across the client and server.
Sometimes, this means that logic gets duplicated (like to validate form data).
Other times, the client and server each implement disjoint parts of the app&#8217;s overall logic.
To understand what the app does, a developer needs to trace interactions between two very different codebases.</p>
</div>
<div class="paragraph">
<p>There&#8217;s another downside that affects mobile apps more than SPAs: API churn.
Remember, the app stores control how your app gets distributed and updated.
Users can even control if and when they get updated versions of your app.
As a mobile developer, you can&#8217;t assume that every user will be on the latest version of your app.
Your frontend code gets fragmented across many versions, and now your backend needs to support all of them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hypermedia_for_mobile_apps">12.2. Hypermedia for Mobile Apps</h3>
<div class="paragraph">
<p>We’ve seen that the hypermedia architecture can address the shortcomings of SPAs on the web.
But can hypermedia work for mobile apps as well?
The answer is yes!</p>
</div>
<div class="paragraph">
<p>Just like on the web, we can use Hypermedia formats on mobile and let it serve as the engine of application state.
All of the logic is controlled from the backend, rather than being spread between two codebases.
Hypermedia architecture also solves the annoying problem of API churn on mobile apps.
Since the backend serves a Hypermedia response containing both data and actions, there&#8217;s no way for the data and UI to get out of sync.
No more worries about backwards compatibility or maintaining multiple API versions.</p>
</div>
<div class="paragraph">
<p>So how can you use Hypermedia for your mobile app?
There are two approaches employing hypermedia to build &amp; ship native mobile apps today:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Web views, which wraps the trusty web platform in a mobile app shell</p>
</li>
<li>
<p>Hyperview, a new hypermedia format we designed specifically for mobile apps</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_web_views">Web views</h4>
<div class="paragraph">
<p>The simplest way to use hypermedia architecture on mobile is by leveraging web technologies.
Both Android and iOS SDKs provide &#8220;web views&#8221;: chromeless web browsers that can be embedded in native apps.
Tools like Apache Cordova make it easy to take the URL of a website, and spit out native iOS and Android apps based on web views.
If you already have a responsive web app, you can get a &#8220;native&#8221; Hypermedia apps for free.
Sounds too good to be true, right?</p>
</div>
<div class="paragraph">
<p>Of course, there is a fundamental limitation with this approach.
The web and mobile are different platforms, with different capabilities and UX conventions.
HTML doesn&#8217;t natively support common UI patterns of mobile apps.
One of the biggest differences is around how each platform handles navigation.
On the web, navigation is page-based, with one page replacing another and the browser providing back/forward buttons to navigate the page history.
On mobile, navigation is more complex, and tuned for the physicality of gesture-based interactions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To drill down, screens slide on top of each other, forming stacks of screens.</p>
</li>
<li>
<p>A nav bar at the bottom of the app allows switching between various stacks of screens.</p>
</li>
<li>
<p>Modals slide up from the bottom of the app, covering the other stacks and the nav bar.</p>
</li>
<li>
<p>Unlike with web pages, all of these screens are still present in memory, rendered and updating based on app state.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The navigation architecture is a major difference between how mobile and web apps function.
But it&#8217;s not the only one.
Many other UX patterns are present in mobile apps, but are not natively supported on the web:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>pull-to-refresh to refresh content in a screen</p>
</li>
<li>
<p>horizontal swipe on UI elements to reveal actions</p>
</li>
<li>
<p>sectioned lists with sticky headers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While these interactions are not natively supported by web browsers, they can be simulated with JS libraries.
Of course, these libraries will never have the same feel and performance as native gestures.
And using these libraries usually requires embracing a JS-heavy SPA architecture.
This puts us back at square 1!
To avoid using the typical thick-client architecture of native mobile apps, we turned to a web view.
The web view allows us to use good-old hypermedia-based HTML.
But to get the desired look &amp; feel of a mobile app, we end up building a SPA in JS, losing the benefits of Hypermedia in the process.</p>
</div>
<div class="paragraph">
<p>To build a hypermedia-based mobile app that feels and acts native, HTML isn&#8217;t going to cut it.
We need a format designed to represent the interactions and patterns of native mobile apps.
That&#8217;s exactly what Hyperview does.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hyperview">Hyperview</h4>
<div class="paragraph">
<p>Hyperview is an open-source framework that provides:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A pre-defined hypermedia format for defining mobile apps called HXML</p>
</li>
<li>
<p>A hypermedia client for HXML that can be embedded in an app binary on iOS and Android</p>
</li>
<li>
<p>Extension points in HXML and the client to customize the framework for a given app</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_the_format">The Format</h5>
<div class="paragraph">
<p>HXML was designed to feel familiar to web developers, used to working with HTML.
Thus the choice of XML for the base format.
In addition to familiar ergonomics, XML is compatible with server-side rendering libraries.
For example, Jinja2 is perfectly suited as a templating library to render HXML.
The familiarity of XML and the ease of integration on the backend make it simple to adopt in both new and existing codebases.
Take a look at a &#8220;Hello World&#8221; app written in HXML.
The syntax should be familiar to anyone who&#8217;s worked with HTML:</p>
</div>
<div class="listingblock">
<div class="title">Hello World</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview"&gt;
  &lt;screen&gt;
    &lt;styles /&gt;
    &lt;body&gt;
      &lt;header&gt;
        &lt;text&gt;My first app&lt;/text&gt;
      &lt;/header&gt;
      &lt;view&gt;
        &lt;text&gt;Hello World!&lt;/text&gt;
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But HXML is not just a straight port of HTML with differently named tags.
In previous chapters, we&#8217;ve seen how htmx enhances HTML with a handful of new attributes.
These additions maintain the declarative nature of HTML, while giving developers the power to create rich web apps.
In HXML, the concepts of htmx (and IntercoolerJS before it) are built into the spec.
Specifically, HXML is not limited to &#8220;click to navigate&#8221; and &#8220;press to submit&#8221; interactions like basic HTML.
It supports a range of triggers and actions for modifying the content on a screen.
These interactions are bundled together in a powerful concept of &#8220;behaviors&#8221;.
Developers can even define new behavior actions to add new capabilities to their app, without the need for scripting.
We will learn more about behaviors later in this chapter.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_client">The client</h5>
<div class="paragraph">
<p>Web developers are lucky.
They can assume their users have access to a web browser capable of rendering any web app.
In Hypermedia terms, the Hypermedia (HTML) client is already built and distributed to users.
Half the work is done!
The developer only has to build the backend to serve Hypermedia responses.</p>
</div>
<div id="figure-6-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/figure_6_1.png" alt="figure 6 1">
</div>
<div class="title">Figure 9. One HTML server, multiple HTML clients</div>
</div>
<div class="paragraph">
<p>This is possible because the web is an open ecosystem built on standards.
Any developer can build and host a web app, and any user can access it directly.</p>
</div>
<div class="paragraph">
<p>As we know, that&#8217;s not the case with mobile platforms.
There is no open standard for building and distributing native mobile apps.
And there&#8217;s definitely no widely distributed &#8220;HXML browser&#8221;.
So how can a developer deliver a Hypermedia mobile app using HXML?
Well, unlike on the web, the mobile developer must provide both the backend to serve HXML, and a mobile client app to render those HXML responses.</p>
</div>
<div id="figure-6-2" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/figure_6_2.png" alt="figure 6 2">
</div>
<div class="title">Figure 10. One HXML server, one HXML client</div>
</div>
<div class="paragraph">
<p>It would be a lot to ask from developers to write their own HXML client.
That&#8217;s why Hyperview provides an open-source client library, written in React Native.
This library can be used to bootstrap a new mobile app, or it can be embedded in an existing app.
In either case, developers get a full &#8220;HXML browser&#8221; without needing to write it from scratch.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">The Benefits of Using Your Own Client</div>
        <div class="paragraph">
<p>At first, it might seem like the Hyperview approach requires extra work to write and maintain the mobile app client.
But there is a benefit to controlling both parts of the client-server architecture.
Did you ever wish you could fix a web browser bug?
Or maybe add a new HTML element or features to the browser itself?
The open nature of the Web means that progress happens slowly.
New features go through a lengthy standardization process.
Browser vendors may prioritize bugs and features that don&#8217;t match your individual priorities.
As a Web developer, you may need to wait years until browsers support the feature you need.
Or, you can try to work around it with some kludgy JS.</p>
</div>
<div class="paragraph">
<p>Well, with Hyperview, there is no standards body or lengthy process for new features.
As a Hyperview developer, you control your backend and mobile app client.
Do you want to add a new element to HXML?
Go right ahead!
In fact, the Hyperview client library was built with extensibility in mind.
There are extension points for custom UI elements and custom behavior actions.</p>
</div>
<div class="paragraph">
<p>By extending the format and client itself, there&#8217;s no need for Hyperview to include a scripting layer in HXML.
Features that require client-side logic get &#8220;built-in&#8221; to the client browser.
HXML responses remain pure, with UI and interactions represented in declarative XML.</p>
</div>
    </aside>
</div>
</div>
<div class="sect3">
<h4 id="_which_hypermedia_architecture_should_you_use">Which Hypermedia architecture should you use?</h4>
<div class="paragraph">
<p>We&#8217;ve discussed two approaches for creating mobile apps using Hypermedia architecture:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create a backend that returns HTML, and serve it in a mobile app through a web view</p>
</li>
<li>
<p>create a backend that returns HXML, and serve it in a mobile app with the Hyperview client</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I purposefully described the two approaches in a way to highlight their similarities.
After all, they are both using the Hypermedia architecture, just with different formats and clients.
Both approaches solve the fundamental issues with traditional, SPA-like mobile app development:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The backend controls the full state of the app.</p>
</li>
<li>
<p>Our app&#8217;s logic is all in one place.</p>
</li>
<li>
<p>The app always runs the latest version, there&#8217;s no API churn to worry about</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So which approach should you use for a Hypermedia-driven mobile app?
Based on my experience building both types of apps, we strongly believe the Hyperview approach results in a better user experience.
The web-view will always feel out-of-place on iOS and Android; there&#8217;s just no good way to replicate the patterns of navigation and interaction that mobile users expect.
Hyperview was created specifically to address the limitations of thick-client and web view approaches.
After the initial investment to learn Hyperview, you&#8217;ll get all of the benefits of the Hypermedia architecture, without the downsides of a degraded user experience.</p>
</div>
<div class="paragraph">
<p>Of course, if you already have a simple, mobile-friendly web app, then using a web-view approach is sensible.
You will certainly save time from not having to serve your app as HXML in addition to HTML.
But as we will show at the end of this chapter, it doesn&#8217;t take a lot of work to convert an existing Hypermedia-driven web app into a Hyperview mobile app.
But before we get there, we need to introduce the concepts of elements and behaviors in Hyperview.
Then, we&#8217;ll re-build our contacts app in Hyperview.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introduction_to_hxml">12.3. Introduction to HXML</h3>
<div class="sect3">
<h4 id="_hello_world">Hello World!</h4>
<div class="paragraph">
<p>HXML was designed to feel natural to web developers coming from HTML.
Let&#8217;s take a closer look at the &#8220;Hello World&#8221; app defined in HXML:</p>
</div>
<div class="listingblock">
<div class="title">Hello World, revisited</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview"&gt; <b class="conum">(1)</b>
  &lt;screen&gt; <b class="conum">(2)</b>
    &lt;styles /&gt;
    &lt;body&gt; <b class="conum">(3)</b>
      &lt;header&gt; <b class="conum">(4)</b>
        &lt;text&gt;My first app&lt;/text&gt;
      &lt;/header&gt;
      &lt;view&gt; <b class="conum">(5)</b>
        &lt;text&gt;Hello World!&lt;/text&gt; <b class="conum">(6)</b>
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The root element of the HXML app</p>
</li>
<li>
<p>The element representing a screen of the app</p>
</li>
<li>
<p>The element representing the UI of the screen</p>
</li>
<li>
<p>The element representing the top header of the screen</p>
</li>
<li>
<p>A wrapper element around the content shown on the screen</p>
</li>
<li>
<p>The text content shown on the screen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Nothing too strange here, right?
Just like HTML, the syntax defines a tree of elements using start tags (<code>&lt;screen&gt;</code>) and end tags (<code>&lt;/screen&gt;</code>).
Elements can contain other elements (<code>&lt;view&gt;</code>) or text (<code>Hello World!</code>).
Elements can also be empty, represented with an empty tag (<code>&lt;styles /&gt;</code>).
However, you&#8217;ll notice that the names of the HXML element are different from those in HTML.
Let&#8217;s take a closer look at each of those elements to understand what they do.</p>
</div>
<div class="paragraph">
<p><code>&lt;doc&gt;</code> is the root of the HXML app.
Think of it as equivalent to the <code>&lt;html&gt;</code> element in HTML.
Note that the <code>&lt;doc&gt;</code> element contains an attribute <code>xmlns="https://hyperview.org/hyperview"</code>.
This defines the default namespace for the doc.
Namespaces are a feature of XML that allow one doc to contain elements defined by different developers.
To prevent conflicts when two developers use the same name for their element, each developer defines a unique namespace.
We will talk more about namespaces when we discuss custom elements &amp; behaviors later in this chapter.
For now, it&#8217;s enough to know that elements in an HXML doc without an explicit namespace are considered to be part of the <code><a href="https://hyperview.org/hyperview" class="bare">https://hyperview.org/hyperview</a></code> namespace.</p>
</div>
<div class="paragraph">
<p><code>&lt;screen&gt;</code> represents the UI that gets rendered on a single screen of a mobile app.
It&#8217;s possible for one <code>&lt;doc&gt;</code> to contain multiple <code>&lt;screen&gt;</code> elements, but we won&#8217;t get into that now.
Typically, a <code>&lt;screen&gt;</code> element will contain elements that define the content and styling of the screen.</p>
</div>
<div class="paragraph">
<p><code>&lt;styles&gt;</code> defines the styles of the UI on the screen.
We won&#8217;t get too much into styling in Hyperview in this chapter.
Suffice it to say, unlike HTML, Hyperview does not use a separate language (CSS) to define styles.
Instead, styling rules such as colors, spacing, layout, and fonts are defined in HXML.
These rules are then explicitly referenced by UI elements, much like using classes in CSS.</p>
</div>
<div class="paragraph">
<p><code>&lt;body&gt;</code> defines the actual UI of the screen.
The body includes all text, images, buttons, forms, etc that will be shown to the user.
This is equivalent to the <code>&lt;body&gt;</code> element in HTML.</p>
</div>
<div class="paragraph">
<p><code>&lt;header&gt;</code> defines the header of the screen.
Typically in mobile apps, the header includes some navigation (like a back button), and the title of the screen.
It&#8217;s useful to define the header separately from the rest of the body.
Some mobile OSes will use a different transition for the header than the rest of the screen content.</p>
</div>
<div class="paragraph">
<p><code>&lt;view&gt;</code> is the basic building block for layouts and structure within the screen&#8217;s body.
Think of it like a <code>&lt;div&gt;</code> in HTML.
Note that unlike in HTML, a <code>&lt;div&gt;</code> cannot directly contain text.</p>
</div>
<div class="paragraph">
<p><code>&lt;text&gt;</code> elements are the only way to render text in the UI.
In this example, &#8220;Hello World&#8221; is contained within a  <code>&lt;text&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all there is to define a basic &#8220;Hello World&#8221; app in HXML.
Of course, this isn&#8217;t very exciting.
Let&#8217;s cover some other built-in display elements.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ui_elements">UI Elements</h4>
<div class="sect4">
<h5 id="_lists">Lists</h5>
<div class="paragraph">
<p>A very common pattern in mobile apps is to scroll through a list of items.
The physical properties of a phone screen (long &amp; vertical) and the intuitive gesture of swiping a thumb up &amp; down makes this a good choice for many screens.</p>
</div>
<div class="paragraph">
<p>HXML has dedicated elements for representing lists and items.</p>
</div>
<div class="listingblock">
<div class="title">List element</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;list&gt; <b class="conum">(1)</b>
  &lt;item key="item1"&gt; <b class="conum">(2)</b>
    &lt;text&gt;My first item&lt;/text&gt; <b class="conum">(3)</b>
  &lt;/item&gt;
  &lt;item key="item2"&gt;
    &lt;text&gt;My second item&lt;/text&gt;
  &lt;/item&gt;
&lt;/list&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Element representing a list</p>
</li>
<li>
<p>Element representing an item in the list, with a unique key</p>
</li>
<li>
<p>The content of the item in the list.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Lists are represented with two new elements.
The <code>&lt;list&gt;</code> wraps all of the items in the list.
It can be styled like a generic <code>&lt;view&gt;</code> (width, height, etc).
A <code>&lt;list&gt;</code> element only contains <code>&lt;item&gt;</code> elements.
Of course, these represent each unique item in the list.
Note that <code>&lt;item&gt;</code> is required to have a <code>key</code> attribute, which is unique among all items in the list.</p>
</div>
<div class="paragraph">
<p>You might be asking, &#8220;Why do we need a custom syntax for lists of items?
Can&#8217;t we just use a bunch of <code>&lt;view&gt;</code> elements?&#8221;.
Yes, for lists with a small number of items, using nested <code>&lt;views&gt;</code> will work quite well.
However, often the number of items in a list can be long enough to require optimizations to support smooth scrolling interactions.
Consider browsing a feed of posts in a social media app.
As you keep scrolling through the feed, it&#8217;s not unusual for the app to show hundreds if not thousands of posts.
At any time, you can flick your finger to scroll to almost any part of the feed.
Mobile devices tend to be memory-constrained.
Keeping the fully-rendered list of items in memory could consume more resources than available.
That&#8217;s why both iOS and Android provide APIs for optimized list UIs.
These APIs know which part of the list is currently on-screen. To save memory, they clear out the non-visible list items, and recycle the item UI objects to conserve memory.
By using explicit <code>&lt;list&gt;</code> and <code>&lt;item&gt;</code> elements in HXML, the Hyperview client knows to use these optimized list APIs to make your app more performant.</p>
</div>
<div class="paragraph">
<p>It&#8217;s also worth mentioning that HXML supports section lists.
Section lists are useful for building list-based UIs, where the items in the list can be grouped for the user&#8217;s convenience.
For example, a UI showing a restaurant menu could group the offerings by dish type:</p>
</div>
<div class="listingblock">
<div class="title">Section list element</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;section-list&gt; <b class="conum">(1)</b>
  &lt;section&gt; <b class="conum">(2)</b>
    &lt;section-title&gt; <b class="conum">(3)</b>
      &lt;text&gt;Appetizers&lt;/text&gt;
    &lt;/section-title&gt;
    &lt;item key="1"&gt; <b class="conum">(4)</b>
      &lt;text&gt;French Fries&lt;/text&gt;
    &lt;/item&gt;
    &lt;item key="2"&gt;
      &lt;text&gt;Onion Rings&lt;/text&gt;
    &lt;/item&gt;
  &lt;/section&gt;

  &lt;section&gt; <b class="conum">(5)</b>
    &lt;section-title&gt;
      &lt;text&gt;Entrees&lt;/text&gt;
    &lt;/section-title&gt;
    &lt;item key="3"&gt;
      &lt;text&gt;Burger&lt;/text&gt;
    &lt;/item&gt;
  &lt;/section&gt;
&lt;/section-list&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Element representing a list with sections</p>
</li>
<li>
<p>The first section of appetizer offerings</p>
</li>
<li>
<p>Element for the title of the section, rendering the text &#8220;Appetizers&#8221;</p>
</li>
<li>
<p>An item representing an appetizer</p>
</li>
<li>
<p>A section for entree offerings</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You&#8217;ll notice a couple of differences between <code>&lt;list&gt;</code> and <code>&lt;section-list&gt;</code>.
The section list element only contains <code>&lt;section&gt;</code> elements, representing a group of items.
A section can contain a <code>&lt;section-title&gt;</code> element. This is used to render some UI that acts as the header of the section.
This header is &#8220;sticky&#8221;, meaning it stays on screen while scrolling through items that belong to the corresponding section.
Finally, <code>&lt;item&gt;</code> elements act the same as in the regular list, but can only appear within a <code>&lt;section&gt;</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_images">Images</h5>
<div class="paragraph">
<p>Showing images in Hyperview is pretty similar to HTML, but there are a few differences.</p>
</div>
<div class="listingblock">
<div class="title">Image element</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;image source="/profiles/1.jpg" style="avatar" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>source</code> attribute specifies how to load the image.
Like in HTML, the source can be an absolute or relative URL.
Additionally, the source can be an encoded data URI, for example <code>data:image/png;base64,iVBORw</code>.
However, the source can also be a &#8220;local&#8221; URL, referring to an image that is bundled as an asset in the mobile app.
The local URL is prefixed with <code>./</code>:</p>
</div>
<div class="listingblock">
<div class="title">Image element, pointing to local source</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;image source="./logo.png" style="logo" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using Local URLs is an optimization.
Since the images are on the mobile device, they don&#8217;t require a network request and will appear quickly.
However, bundling the image with the mobile app binary increases the binary size.
Using local images is a good trade-off for images that are frequently accessed but rarely change.
Good examples include the app logo, or common button icons.</p>
</div>
<div class="paragraph">
<p>The other thing to note is the presence of the <code>style</code> attribute on the <code>&lt;image&gt;</code> element.
In HXML, images are required to have a style that has rules for the image&#8217;s <code>width</code> and <code>height</code>.
This is different from HTML, where <code>&lt;img&gt;</code> elements do not need to explicitly set a width and height.
Web browsers will re-flow the content of a web page once the image is fetched and the dimensions are known.
While re-flowing content is a reasonable behavior for web-based documents, users do not expect mobile apps to re-flow as content loads.
To maintain a static layout, HXML requires the dimensions to be known before the image loads.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inputs">Inputs</h4>
<div class="paragraph">
<p>There&#8217;s a lot to cover about inputs in Hyperview.
Since this is meant to be an introduction and not an exhaustive resource, I&#8217;ll highlight just a few types of inputs.
Let&#8217;s start with an example of the simplest type of input, a text field.</p>
</div>
<div class="listingblock">
<div class="title">Text field element</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;text-field
  name="first_name" <b class="conum">(1)</b>
  style="input" <b class="conum">(2)</b>
  value="Adam" <b class="conum">(3)</b>
  placeholder="First name" <b class="conum">(4)</b>
/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name used when serializing data from this input</p>
</li>
<li>
<p>The style class applied to the UI element</p>
</li>
<li>
<p>The current value set in the field</p>
</li>
<li>
<p>A placeholder to display when the value is empty</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This element should feel familiar to anyone who&#8217;s created a text field in HTML.
One difference is that most inputs in HTML use the <code>&lt;input&gt;</code> element with a <code>type</code> attribute, eg <code>&lt;input type="text"&gt;</code>.
In Hyperview, each input has a unique name, in this case <code>&lt;text-field&gt;</code>.
By using different names, we can use more expressive XML to represent the input.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s consider a case where we want to render a UI that lets the user select one among several options.
In HTML, we would use a radio button input, something like <code>&lt;input type="radio" name="choice" value="option1" /&gt;</code>.
Each choice is represented as a unique input element.
This never struck me as ideal.
Most of the time, radio buttons are grouped together to affect the same name.
The HTML approach leads to a lot of boilerplate (duplication of <code>type="radio"</code> and <code>name="choice"</code> for each choice).
Also, unlike radio buttons on desktop, mobile OSes don&#8217;t provide a strong standard UI for selecting one option.
Most mobile apps use richer, custom UIs for these interactions.
So in HXML, we implement this UI using an element called <code>&lt;select-single&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="title">Select-single element</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;select-single name="choice"&gt; <b class="conum">(1)</b>
  &lt;option value="option1"&gt; <b class="conum">(2)</b>
    &lt;text&gt;Option 1&lt;/text&gt; <b class="conum">(3)</b>
  &lt;/option&gt;
  &lt;option value="option2"&gt;
    &lt;text&gt;Option 2&lt;/text&gt;
  &lt;/option&gt;
&lt;/select-single&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Element representing an input where a single choice is selected. The name of the selection is defined once here.</p>
</li>
<li>
<p>Element representing one of the choices. The choice value is defined here.</p>
</li>
<li>
<p>The UI of the selection. In this example, we use text, but we can use any UI elements.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>&lt;select-single&gt;</code> element is the parent of the input for selecting one choice out of many.
This element contains the <code>name</code> attribute used when serializing the selected choice.
<code>&lt;option&gt;</code> elements within <code>&lt;select-single&gt;</code> represent the available choices.
Note that each <code>&lt;option&gt;</code> element has a <code>value</code> attribute.
When pressed, this will be the selected value of the input.
The <code>&lt;option&gt;</code> element can contain any other UI elements within it.
This means that we&#8217;re not hampered by rendering the input as a list of radio buttons with labels.
We can render the options as radios, tags, images, or anything else that would be intuitive for our interface.
HXML styling supports modifiers for pressed and selected states, letting us customize the UI to highlight the selected option.</p>
</div>
<div class="paragraph">
<p>Describing all features of inputs in HXML would take an entire chapter.
Instead, I&#8217;ll summarize a few other input elements and their features.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;select-multiple&gt;</code> works like <code>&lt;select-single&gt;</code>, but it supports toggling multiple options on &amp; off. This replaces checkbox inputs in HTML.</p>
</li>
<li>
<p>The <code>&lt;switch&gt;</code> element renders an on/off switch that is common in mobile UIs</p>
</li>
<li>
<p>The <code>&lt;date-field&gt;</code> element supports entering in specific dates, and comes with a wide range of customizations for formatting, settings ranges, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two more things to mention about inputs.
First is the <code>&lt;form&gt;</code> element.
The <code>&lt;form&gt;</code> element is used to group together inputs for serialization.
When a user takes an action that triggers a backend request, the Hyperview client will serialize all inputs in the surrounding <code>&lt;form&gt;</code> and include them in the request.
This is true for both <code>GET</code> and <code>POST</code> requests.
We will cover this in more detail when talking about behaviors later in this chapter.
Also later in this chapter, I&#8217;ll talk about support for custom elements in HXML.
With custom elements, you can also create your own input elements.
Custom input elements allow you to build incredible powerful interactions with simple XML syntax that integrates well with the rest of HXML.</p>
</div>
</div>
<div class="sect3">
<h4 id="_styling">Styling</h4>
<div class="paragraph">
<p>So far, we haven&#8217;t mentioned how to apply styling to all of the HXML elements.
We&#8217;ve seen from the Hello World app that each <code>&lt;screen&gt;</code> can contain a <code>&lt;styles&gt;</code> element.
Let&#8217;s re-visit the Hello World app and fill out the <code>&lt;styles&gt;</code> element.</p>
</div>
<div class="listingblock">
<div class="title">UI styling example</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview"&gt;
  &lt;screen&gt;
    &lt;styles&gt; <b class="conum">(1)</b>
      &lt;style class="body" flex="1" flexDirection="column" /&gt; <b class="conum">(2)</b>
      &lt;style class="header" borderBottomWidth="1" borderBottomColor="#ccc" /&gt;
      &lt;style class="main" margin="24" /&gt;
      &lt;style class="h1" fontSize="32" /&gt;
      &lt;style class="info" color="blue" /&gt;
    &lt;/styles&gt;

    &lt;body style="body"&gt; <b class="conum">(3)</b>
      &lt;header style="header"&gt;
        &lt;text style="info"&gt;My first app&lt;/text&gt;
      &lt;/header&gt;
      &lt;view style="main"&gt;
        &lt;text style="h1 info"&gt;Hello World!&lt;/text&gt; <b class="conum">(4)</b>
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Element encapsulating all of the styling for the screen</p>
</li>
<li>
<p>Example of a definition of a style class for &#8220;body&#8221;</p>
</li>
<li>
<p>Applying the &#8220;body&#8221; style class to a UI element</p>
</li>
<li>
<p>Example of applying multiple style classes (h1 and info) to an element</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You&#8217;ll note that in HXML, styling is part of the XML format, rather than using a separate language like CSS.
However, we can draw some parallels between CSS rules and the <code>&lt;style&gt;</code> element.
A CSS rule consists of a selector and declarations.
In the current version of HXML, the only available selector is a class name, indicated by the <code>class</code> attribute.
The rest of the attributes on the <code>&lt;style&gt;</code> element are declarations, consisting of properties and property values.</p>
</div>
<div class="paragraph">
<p>UI elements within the <code>&lt;screen&gt;</code> can reference the <code>&lt;style&gt;</code> rules by adding the class names to their <code>&lt;style&gt;</code> property.
Note the <code>&lt;text&gt;</code> element around &#8220;Hello World!&#8221; references two style classes: <code>h1</code> and <code>info</code>. The styles from the corresponding classes are merged together in the order they appear on the element.
It&#8217;s worth noting that styling properties are similar to those in CSS (color, margins/padding, borders, etc).
Currently, the only available layout engine is based on flexbox.</p>
</div>
<div class="paragraph">
<p>Style rules can get quite verbose.
For the sake of brevity, we won&#8217;t include the <code>&lt;styles&gt;</code> element in the rest of the examples in this chapter unless necessary.</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_elements_2">Custom elements</h4>
<div class="paragraph">
<p>The core UI elements that ship with Hyperview are quite basic.
Most mobile apps require richer elements to deliver a great user experience.
Luckily, HXML can easily accommodate custom elements in its syntax.
This is because HXML is really just XML, aka &#8220;Extensible Markup Language&#8221;.
Extensibility is already built into the format!
Developers are free to define new elements and attributes to represent custom elements.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see this in action with a concrete example.
Assume that we want to add a map element to our Hello World app.
We want the map to display a defined area, and one or more markers at specific coordinates in that area.
Let&#8217;s translate these requirements into XML:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>&lt;area&gt;</code> element will represent the area displayed by the map. To specify the area, the element will include attributes for <code>latitude</code> and <code>longitude</code> for the center of the area, and a <code>latitude-delta</code> and <code>longitude-delta</code> indicating the +/- display area around the center.</p>
</li>
<li>
<p>A <code>&lt;marker&gt;</code> element will represent a marker in the area. The coordinates of the marker will be defined by <code>latitude</code> and <code>longitude</code> attributes on the marker.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using these custom XML elements, an instance of the map in our app might look like this:</p>
</div>
<div class="listingblock">
<div class="title">Custom elements in HXML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview"&gt;
  &lt;screen&gt;
    &lt;body&gt;
      &lt;view&gt;
        &lt;text&gt;Hello World!&lt;/text&gt;
        &lt;area latitude="37.8270" longitude="122.4230" latitude-delta="0.1" longitude-delta="0.1"&gt; <b class="conum">(1)</b>
          &lt;marker latitude="37.8118" longitude="-122.4177" /&gt; <b class="conum">(2)</b>
        &lt;/area&gt;
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Custom element representing the area rendered by the map</p>
</li>
<li>
<p>Custom element representing a marker rendered at specific coordinates on the map</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The syntax feels right at home among the core HXML elements.
However, there&#8217;s a potential problem.
&#8220;area&#8221; and &#8220;marker&#8221; are pretty generic names.
I could see <code>&lt;area&gt;</code> and <code>&lt;marker&gt;</code> elements being used by a customization to render charts &amp; graphs.
If our app renders both maps and charts, the HXML markup would be ambiguous.
What should the client render when it sees <code>&lt;area&gt;</code> or <code>&lt;marker&gt;</code>?</p>
</div>
<div class="paragraph">
<p>This is where XML namespaces come in. XML namespaces eliminate ambiguity and collisions between elements and attributes used to represent different things.
Remember that the <code>&lt;doc&gt;</code> element declares that <code><a href="https://hyperview.org/hyperview" class="bare">https://hyperview.org/hyperview</a></code> is the default namespace for the entire document.
Since no other elements define namespaces, every element in the example above is part of the <code><a href="https://hyperview.org/hyperview" class="bare">https://hyperview.org/hyperview</a></code> namespace.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s define a new namespace for our map elements. Since this namespace will not be the default for the document, we also need to assign the namespace to a prefix we will add to our elements:</p>
</div>
<div class="paragraph">
<p><code>&lt;doc xmlns="https://hyperview.org/hyperview" xmlns:map="https://mycompany.com/hyperview-map"&gt;</code></p>
</div>
<div class="paragraph">
<p>This new attribute declares that the <code>map:</code> prefix is associated with the namespace "https://mycompany.com/hyperview-map".
This namespace could be anything, but remember the goal is to use something unique that won&#8217;t have collisions.
Using your company/app domain is a good way to guarantee uniqueness.
Now that we have a namespace and prefix, we need to use it for our elements:</p>
</div>
<div class="listingblock">
<div class="title">Namespacing the custom elements</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview" xmlns:map="https://mycompany.com/hyperview-map"&gt; <b class="conum">(1)</b>
  &lt;screen&gt;
    &lt;body&gt;
      &lt;view&gt;
        &lt;text&gt;Hello World!&lt;/text&gt;
        &lt;map:area latitude="37.8270" longitude="122.4230" latitude-delta="0.1" longitude=delta="0.1"&gt; <b class="conum">(2)</b>
          &lt;map:marker latitude="37.8118" longitude="-122.4177" /&gt; <b class="conum">(3)</b>
        &lt;/map:area&gt; <b class="conum">(4)</b>
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Definition of namespace aliased to &#8220;map&#8221;</p>
</li>
<li>
<p>Adding the namespace to the &#8220;area&#8221; start tag</p>
</li>
<li>
<p>Adding the namespace to the &#8220;marker&#8221; self-closing tag</p>
</li>
<li>
<p>Adding the namespace to the &#8220;area&#8221; end tag</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That&#8217;s it! If we introduced a custom charting library with &#8220;area&#8221; and &#8220;marker&#8221; elements, we would create a unique namespace for those elements as well. Within the HXML doc, we could easily disambiguate <code>&lt;map:area&gt;</code> from <code>&lt;chart:area&gt;</code>.</p>
</div>
<div class="paragraph">
<p>At this point you might be wondering, &#8220;how does the Hyperview client know to render a map when my doc includes &lt;map:area&gt;?&#8221;
It&#8217;s true, so far we only defined the custom element format, but we haven&#8217;t implemented the element as a feature in our app.
We will get into the details of implementing custom elements in the next chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_behaviors">Behaviors</h4>
<div class="paragraph">
<p>As discussed in earlier chapters, HTML supports two basic types of interactions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clicking a hyperlink: the client will make a GET request and render the response as a new web page.</p>
</li>
<li>
<p>Submitting a form: the client will (typically) make a POST request with the serialized content of the form, and render the response as a new web page.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Clicking hyperlinks and submitting forms is enough to build simple web applications.
But relying on just these two interactions limits our ability to build richer UIs.
What if we want something to happen when the user mouses over a certain element, or perhaps when they scroll some content into the viewport?
We can&#8217;t do that with basic HTML.
Additionally, both clicks and form submits result in loading a full new web page.
What if we only want to update a small part of the current page?
This is a very common scenario in rich web applications, where users expect to fetch and update content without navigating to a new page.</p>
</div>
<div class="paragraph">
<p>So with basic HTML, interactions (clicks and submits) are limited and tightly coupled to a single action (loading a new page).
Of course, using JavaScript, we can extend HTML and add some new syntax to support our desired interactions.
htmx (and Intercooler before it) do exactly that with a new set of attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interactions can be added to any element, not just links and forms.</p>
</li>
<li>
<p>The interaction can be triggered via a click, submit, mouseover, or any other JavaScript event.</p>
</li>
<li>
<p>The actions resulting from the trigger can modify the current page, not just request a new page.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By decoupling elements, triggers, and actions, htmx allows us to build rich Hypermedia-driven applications in a way that feels very compatible with HTML syntax and server-side web development.</p>
</div>
<div class="paragraph">
<p>HXML takes the idea of defining interactions via triggers &amp; actions and builds them into the spec.
We call these interactions &#8220;behaviors&#8221;.
We use a special <code>&lt;behavior&gt;</code> element to define them.
Here&#8217;s an example of a simple behavior that pushes a new mobile screen onto the navigation stack:</p>
</div>
<div class="listingblock">
<div class="title">Basic behavior</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;text&gt;
  &lt;behavior <b class="conum">(1)</b>
    trigger="press" <b class="conum">(2)</b>
    action="push" <b class="conum">(3)</b>
    href="/next-screen" <b class="conum">(4)</b>
  /&gt;
  Press me!
&lt;/text&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The element encapsulating an interaction on the parent <code>&lt;text&gt;</code> element.</p>
</li>
<li>
<p>The trigger that will execute the interaction, in this case pressing the <code>&lt;text&gt;</code> element.</p>
</li>
<li>
<p>The action that will execute when triggered, in this case pushing a new screen onto the current stack.</p>
</li>
<li>
<p>The href to load on the new screen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s break down what&#8217;s happening in this example.
First, we have a <code>&lt;text&gt;</code> element with the content "Press me!".
We&#8217;ve shown <code>&lt;text&gt;</code> elements before in examples of HXML, so this is nothing new.
But now, the <code>&lt;text&gt;</code> element contains a new child element, <code>&lt;behavior&gt;</code>.
This <code>&lt;behavior&gt;</code> element defines an interaction on the parent <code>&lt;text&gt;</code> element.
It contains two attributes that are required for any behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>trigger</code>: defines the user action that triggers the behavior</p>
</li>
<li>
<p><code>action</code>: defines what happens when triggered</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this example, the <code>trigger</code> is set to <code>press</code>, meaning this interaction will happen when the user presses the <code>&lt;text&gt;</code> element.
The <code>action</code> attribute is set to <code>push</code>.
<code>push</code> is an action that will push a new screen onto the navigation stack.
Finally, Hyperview needs to know what content to load on the newly pushed screen.
This is where the <code>href</code> attribute comes in.
Notice we don&#8217;t need to define the full URL.
Much like in HTML, the <code>href</code> can be an absolute or relative URL.</p>
</div>
<div class="paragraph">
<p>So that&#8217;s a first example of behaviors in HXML.
You may be thinking this syntax seems quite verbose.
Indeed, pressing elements to navigate to a new screen is one of the most common interactions in a mobile app.
It would be nice to have a simpler syntax for the common case.
Luckily, <code>trigger</code> and <code>action</code> attributes have default values of <code>press</code> and <code>push</code>, respectively.
Therefore, they can be ommitted to clean up the syntax:</p>
</div>
<div class="listingblock">
<div class="title">Basic behavior with defaults</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;text&gt;
  &lt;behavior href="/next-screen" /&gt; <b class="conum">(1)</b>
  Press me!
&lt;/text&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>When pressed, this behavior will open a new screen with the given URL.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This markup for the <code>&lt;behavior&gt;</code> will produce the same interaction as the earlier example.
With the default attributes, the <code>&lt;behavior&gt;</code> element looks similar to an anchor <code>&lt;a&gt;</code> in HTML.
But the full syntax achieves our goals of decoupling elements, triggers, and actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Behaviors can be added to any element, they are not limited to links and forms.</p>
</li>
<li>
<p>Behaviors can specify an explicit <code>trigger</code>, not just clicks or form submits.</p>
</li>
<li>
<p>Behaviors can specify an explicit <code>action</code>, not just a request for a new page.</p>
</li>
<li>
<p>Extra attributes like <code>href</code> provide more context for the action.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, using a dedicated <code>&lt;behavior&gt;</code> element means a single element can define multiple behaviors.
This lets us execute several actions from the same trigger.
Or, we can execute different actions for different triggers on the same element.
We will show examples of the power of multiple behaviors at the end of this chapter.
First we need to show the variety of supported actions and triggers.</p>
</div>
<div class="sect4">
<h5 id="_actions">Actions</h5>
<div class="paragraph">
<p>Behavior actions in Hyperview fall into four general categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Navigation actions, which load new screens and move between them</p>
</li>
<li>
<p>Update actions, which modify the HXML of the current screen</p>
</li>
<li>
<p>System actions, which interact with OS-level capabilities.</p>
</li>
<li>
<p>Custom actions, which can execute any code you add to the client.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_navigation_actions">Navigation Actions</h6>
<div class="paragraph">
<p>We&#8217;ve already seen the simplest type of action, <code>push</code>.
We classify <code>push</code> as a &#8220;navigation action&#8221;, since it&#8217;s related to navigating screens in the mobile app.
Pushing a screen onto the navigation stack is just one of several navigation actions supported in Hyperview.
Users also need to be able to go back to previous screens, open and close modals, switch between tabs, or jump to arbitrary screens.
Each of these types of navigations is supported through a different value for the <code>action</code> attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>push</code>: Push a new screen into the current navigation stack. This looks like a screen sliding in from the right, on top of the current screen.</p>
</li>
<li>
<p><code>new</code>: Open a new navigation stack as a modal. This looks like a screen sliding in from the bottom, on top of the current screen.</p>
</li>
<li>
<p><code>back</code>: This is a complement to the <code>push</code> action. It pops the current screen off of the navigation stack (sliding it to the right).</p>
</li>
<li>
<p><code>close</code>: This is a complement to the <code>new</code> action. It closes the current navigation stack (sliding it down).</p>
</li>
<li>
<p><code>reload</code>: Similar to a browser&#8217;s &#8220;refresh&#8221; button, this will re-request the content of the current screen.</p>
</li>
<li>
<p><code>navigate</code>: This action will attempt to find a screen with the given <code>href</code> already loaded in the app. If the screen exists, the app will jump to that screen. If it doesn&#8217;t exist, it will act the same as <code>push</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>push</code>, <code>new</code>, and <code>navigate</code> all load a new screen.
Thus, they require an <code>href</code> attribute so that Hyperview knows what content to request for the new screen.
<code>back</code> and <code>close</code> do not load new screens, and thus do not require the <code>href</code> attribute.
<code>reload</code> is an interesting case.
By default, it will use the URL of the screen when re-requesting the content for the screen.
However, if you want to replace the screen with a different one, you can provide an <code>href</code> attribute with <code>reload</code> on the behavior element.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example &#8220;widgets&#8221; app that uses several navigation actions on one screen:</p>
</div>
<div class="listingblock">
<div class="title">Navigation action examples</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;screen&gt;
  &lt;body&gt;
    &lt;header&gt;
      &lt;text&gt;
        &lt;behavior action="back" /&gt; <b class="conum">(1)</b>
        Back
      &lt;/text&gt;

      &lt;text&gt;
        &lt;behavior action="new" href="/widgets/new" /&gt; <b class="conum">(2)</b>
        New Widget
      &lt;/text&gt;
    &lt;/header&gt;
    &lt;text&gt;
      &lt;behavior action="reload" /&gt; <b class="conum">(3)</b>
      Check for new widgets
    &lt;/text&gt;
    &lt;list&gt;
      &lt;item key="widget1"&gt;
        &lt;behavior action="push" href="/widgets/1" /&gt; <b class="conum">(4)</b>
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/body&gt;
&lt;/screen&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Takes the user to the previous screen</p>
</li>
<li>
<p>Opens a new modal to add a widget</p>
</li>
<li>
<p>Reloads the content of the screen, showing new widgets from the backend</p>
</li>
<li>
<p>Pushes a new screen with details for a specific widget</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Most screens in your app will need a way for the user to backtrack to the previous screen.
This is usually done with a button in the header that uses either a &#8220;back&#8221; or &#8220;close&#8221; action, depending on how the screen was opened.
In this example, we&#8217;re assuming the widgets screen was pushed onto the navigation stack, so the &#8220;back&#8221; action is appropriate.
The header contains a second button that allows the user to enter data for a new widget.
Pressing this button will open a modal with a &#8220;New Widget&#8221; screen.
Since this &#8220;New Widget&#8221; screen will open as a modal, it will need a corresponding &#8220;close&#8221; action to dismiss itself and show our &#8220;widgets&#8221; screen again.
Finally, to see more details about a specific widget, each <code>&lt;item&gt;</code> element contains a behavior with a &#8220;push&#8221; action.
This action will push a &#8220;Widget Detail&#8221; screen onto the current navigation stack.
Like in the &#8220;Widgets&#8221; screen, &#8220;Widget Detail&#8221; will need a button in the header that uses the &#8220;back&#8221; action to let the user backtrack.</p>
</div>
<div class="paragraph">
<p>On the web, the browser handles basic navigation needs such as going back/forward, reloading the current page, or jumping to a bookmark.
iOS and Android don&#8217;t provide this sort of universal navigation for native mobile apps.
It&#8217;s on the app developers to handle this themselves.
Navigation actions in HXML provide an easy but powerful way for developers to build an architecture that makes sense for their app.</p>
</div>
</div>
<div class="sect5">
<h6 id="_update_actions">Update Actions</h6>
<div class="paragraph">
<p>Behavior actions are not just limited to navigating between screens.
They can also be used to change the content on the current screen.
We call these &#8220;update actions&#8221;.
Much like navigation actions, update actions make a request to the backend.
However, the response is not an entire HXML document, but a fragment of HXML.
This fragment is added to the HXML of the current screen, resulting in an update to the UI.
The <code>action</code> attribute of the <code>&lt;behavior&gt;</code> determines how the fragment gets incorporated into the HXML.
We also need to introduce a new <code>target</code> attribute on <code>&lt;behavior&gt;</code> to define where the fragment gets incorporated in the existing doc.
The <code>target</code> attribute is an ID reference to an existing element on the screen.</p>
</div>
<div class="paragraph">
<p>Hyperview currently supports these update actions, representing different ways to incorporate the fragment into the screen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>replace</code>: replaces the entire target element with the fragment</p>
</li>
<li>
<p><code>replace-inner</code>: replaces the children of the target element with the fragment</p>
</li>
<li>
<p><code>append</code>: adds the fragment after the last child of the target element</p>
</li>
<li>
<p><code>prepend</code>: adds the fragment before the first child of the target element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look at some examples to make this more concrete.
For these examples, let&#8217;s assume our backend accepts <code>GET</code> requests to <code>/fragment</code>, and the response is a fragment of HXML that looks like <code>&lt;text&gt;My fragment&lt;/text&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Update action examples</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;screen&gt;
  &lt;body&gt;
    &lt;text&gt;
      &lt;behavior action="replace" href="/fragment" target="area1" /&gt; <b class="conum">(1)</b>
      Replace
    &lt;/text&gt;
    &lt;view id="area1"&gt;
      &lt;text&gt;Existing content&lt;/text&gt;
    &lt;/view&gt;

    &lt;text&gt;
      &lt;behavior action="replace-inner" href="/fragment" target="area2" /&gt; <b class="conum">(2)</b>
      Replace-inner
    &lt;/text&gt;
    &lt;view id="area2"&gt;
      &lt;text&gt;Existing content&lt;/text&gt;
    &lt;/view&gt;

    &lt;text&gt;
      &lt;behavior action="append" href="/fragment" target="area3" /&gt; <b class="conum">(3)</b>
      Append
    &lt;/text&gt;
    &lt;view id="area3"&gt;
      &lt;text&gt;Existing content&lt;/text&gt;
    &lt;/view&gt;

    &lt;text&gt;
      &lt;behavior action="prepend" href="/fragment" target="area4" /&gt; <b class="conum">(4)</b>
      Prepend
    &lt;/text&gt;
    &lt;view id="area4"&gt;
      &lt;text&gt;Existing content&lt;/text&gt;
    &lt;/view&gt;

  &lt;/body&gt;
&lt;/screen&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Replaces the area1 element with fetched fragment</p>
</li>
<li>
<p>Replaces the child elements of area2 with fetched fragment</p>
</li>
<li>
<p>Appends the fetched fragment to area3</p>
</li>
<li>
<p>Prepends the fetched fragment to area4</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this example, we have a screen with four buttons corresponding to the four update actions: <code>replace</code>, <code>replace-inner</code>, <code>append</code>, <code>prepend</code>.
Below each button, there&#8217;s a corresponding <code>&lt;view&gt;</code> containing some text.
Note that the <code>id</code> of each view matches the <code>target</code> on the behaviors of the corresponding button.</p>
</div>
<div class="paragraph">
<p>When the user presses the first button, the Hyperview client makes a request for <code>/fragment</code>.
Next, it looks for the target, ie the element with id &#8220;area1&#8221;.
Finally, it replaces the <code>&lt;view id="area1"&gt;</code> element with the fetched fragment, <code>&lt;text&gt;My fragment&lt;/text&gt;</code>.
The existing view and text contained in that view will be replaced.
To the user, it will look like &#8220;Existing content&#8221; was changed to &#8220;My fragment&#8221;.
In the HXML, the element <code>&lt;view id="area1"&gt;</code> will also be gone.</p>
</div>
<div class="paragraph">
<p>The second button behaves in a similar way to the first one.
However, the <code>replace-inner</code> action does not remove the target element from the screen, it only replaces the children.
This means the resulting markup will look like <code>&lt;view id="area2"&gt;&lt;text&gt;My fragment&lt;/text&gt;&lt;/view&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The third and fourth buttons do not remove any content from the screen.
Instead, the fragment will be added either after (in the case of <code>append</code>) or before (<code>prepend</code>) the children of the target element.</p>
</div>
<div class="paragraph">
<p>For completeness, let&#8217;s look at the state of the screen after a user presses all four buttons:</p>
</div>
<div class="listingblock">
<div class="title">Update actions, after pressing buttons</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;screen&gt;
  &lt;body&gt;
    &lt;text&gt;
      &lt;behavior action="replace" href="/fragment" target="area1" /&gt;
      Replace
    &lt;/text&gt;
    &lt;text&gt;My fragment&lt;/text&gt; <b class="conum">(1)</b>

    &lt;text&gt;
      &lt;behavior action="replace-inner" href="/fragment" target="area2" /&gt;
      Replace-inner
    &lt;/text&gt;
    &lt;view id="area2"&gt;
      &lt;text&gt;My fragment&lt;/text&gt; <b class="conum">(2)</b>
    &lt;/view&gt;

    &lt;text&gt;
      &lt;behavior action="append" href="/fragment" target="area3" /&gt;
      Append
    &lt;/text&gt;
    &lt;view id="area3"&gt;
      &lt;text&gt;Existing content&lt;/text&gt;
      &lt;text&gt;My fragment&lt;/text&gt; <b class="conum">(3)</b>
    &lt;/view&gt;

    &lt;text&gt;
      &lt;behavior action="prepend" href="/fragment" target="area4" /&gt;
      Prepend
    &lt;/text&gt;
    &lt;view id="area4"&gt;
      &lt;text&gt;My fragment&lt;/text&gt; <b class="conum">(4)</b>
      &lt;text&gt;Existing content&lt;/text&gt;
    &lt;/view&gt;

  &lt;/body&gt;
&lt;/screen&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Fragment completely replaced the target using <code>replace</code> action</p>
</li>
<li>
<p>Fragment replaced the children of the target using <code>replace-inner</code> action</p>
</li>
<li>
<p>Fragment added as last child of the target using <code>append</code> action</p>
</li>
<li>
<p>fragment added as the first child of the target using <code>prepend</code> action</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The examples above show actions making <code>GET</code> requests to the backend.
But these actions can also make <code>POST</code> requests by setting <code>verb="post"</code> on the <code>&lt;behavior&gt;</code> element.
For both <code>GET</code> and <code>POST</code> requests, the data from the parent <code>&lt;form&gt;</code> element will be serialized and included in the request.
For <code>GET</code> requests, the content will be URL-encoded and added as query params.
For <code>POST</code> requests, the content will be form-URL encoded and set on the request body.
Since they support <code>POST</code> and form data, update actions are often used to send data to the backend.</p>
</div>
<div class="paragraph">
<p>So far, our example of update actions require getting new content from the backend and adding it to the screen.
But sometimes we just want to change the state of existing elements.
The most common state to change for an element is its visibility.
Hyperview has <code>hide</code>, <code>show</code>, and <code>toggle</code> actions that do just that.
Like the other update actions, <code>hide</code>, <code>show</code>, and <code>toggle</code> use the <code>target</code> attribute to apply the action to an element on the current screen.</p>
</div>
<div class="listingblock">
<div class="title">Show, hide, and toggle actions</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;screen&gt;
  &lt;body&gt;
    &lt;text&gt;
      &lt;behavior action="hide" target="area" /&gt; <b class="conum">(1)</b>
      Hide
    &lt;/text&gt;

    &lt;text&gt;
      &lt;behavior action="show" target="area" /&gt; <b class="conum">(2)</b>
      Show
    &lt;/text&gt;

    &lt;text&gt;
      &lt;behavior action="toggle" target="area" /&gt; <b class="conum">(3)</b>
      Toggle
    &lt;/text&gt;

    &lt;view id="area"&gt; <b class="conum">(4)</b>
      &lt;text&gt;My fragment&lt;/text&gt;
    &lt;/view&gt;
  &lt;/body&gt;
&lt;/screen&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Hides the element with id &#8220;area&#8221;.</p>
</li>
<li>
<p>Shows the element with id &#8220;area&#8221;.</p>
</li>
<li>
<p>Toggles the visibility of the element with id &#8220;area&#8221;.</p>
</li>
<li>
<p>The element targeted by the actions.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this example, the three buttons labeled &#8220;Hide&#8221;, &#8220;Show&#8221;, and &#8220;Toggle&#8221; will modify the display state of the <code>&lt;view&gt;</code> with ID &#8220;area&#8221;.
Pressing &#8220;Hide&#8221; multiple times will have no affect once the view is hidden.
Likewise, pressing &#8220;Show&#8221; multiple times will have no affect once the view is showing.
Pressing &#8220;Toggle&#8221; will keep flipping the visibility status of the element between showing and hidden.</p>
</div>
<div class="paragraph">
<p>Hyperview comes with other actions that modify the existing HXML.
We won&#8217;t cover them in detail, but I&#8217;ll mention them briefly here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>set-value</code>: this action can set the value of an input element such as <code>&lt;text-field&gt;</code>, <code>&lt;switch&gt;</code>, <code>&lt;select-single&gt;</code>, etc.</p>
</li>
<li>
<p><code>select-all</code> and <code>unselect-all</code> work with the <code>&lt;select-multiple&gt;</code> element to select/deselect all options.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_system_actions">System Actions</h6>
<div class="paragraph">
<p>Some standard Hyperview actions don&#8217;t interact with the HXML at all.
Instead, they expose functionality provided by the mobile OS.
For example, both Android and iOS support a system-level &#8220;Share&#8221; UI.
This UI allows sharing URLs and messages from one app to another app.
Hyperview has a <code>share</code> action to support this interaction.
It involves a custom namespace, and share-specific attributes.</p>
</div>
<div class="listingblock">
<div class="title">System Share action</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;behavior
  xmlns:share="https://instawork.com/hyperview-share" <b class="conum">(1)</b>
  trigger="press"
  action="share" <b class="conum">(2)</b>
  share:url="https://www.instawork.com" <b class="conum">(3)</b>
  share:message="Check out this website!" <b class="conum">(4)</b>
/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Defines the namespace for the share action.</p>
</li>
<li>
<p>The action of this behavior will bring up the share sheet.</p>
</li>
<li>
<p>URL to be shared</p>
</li>
<li>
<p>Message to be shared</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;ve seen XML namespaces when talking about custom elements.
Here, we are using a namespace for the <code>url</code> and <code>message</code> attributes on the <code>&lt;behavior&gt;</code>.
These attribute names are generic and likely used by other components and behaviors, so the namespace ensures there will be no ambiguity.
When pressed, the &#8220;share&#8221; action will trigger.
The values of the <code>url</code> and <code>message</code> attributes will be passed to the system Share UI.
From there, the user will be able to share the URL &amp; message via SMS, email, or other communication apps.</p>
</div>
<div class="paragraph">
<p>The <code>share</code> action shows how a behavior action can use custom attributes to pass along extra data needed for the interactions.
But some actions require even more structured data.
This can be provided via child elements on the <code>&lt;behavior&gt;</code>.
Hyperview uses this to implement the <code>alert</code> action.
The <code>alert</code> action shows a customized system-level dialog box.
This dialog needs configuration for a title and message, but also for customized buttons.
Each button needs to then trigger another behavior when pressed.
This level of configuration cannot be done with just attributes, so we use custom child elements to represent the behavior of each button.</p>
</div>
<div class="listingblock">
<div class="title">System alert action</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;behavior
  xmlns:alert="https://hyperview.org/hyperview-alert" <b class="conum">(1)</b>
  trigger="press"
  action="alert" <b class="conum">(2)</b>
  alert:title="Continue to next screen?" <b class="conum">(3)</b>
  alert:message="Are you sure you want to navigate to the next screen?" <b class="conum">(4)</b>
&gt;
  &lt;alert:option alert:label="Continue"&gt; <b class="conum">(5)</b>
    &lt;behavior action="push" href="/next" /&gt; <b class="conum">(6)</b>
  &lt;/alert:option&gt;
  &lt;alert:option alert:label="Cancel" /&gt; <b class="conum">(7)</b>
&lt;/behavior&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Defines the namespace for the alert action.</p>
</li>
<li>
<p>The action of this behavior will bring up a system dialog box.</p>
</li>
<li>
<p>Title of the dialog box.</p>
</li>
<li>
<p>Content of the dialog box.</p>
</li>
<li>
<p>A &#8220;continue&#8221; option in the dialog box</p>
</li>
<li>
<p>When &#8220;continue&#8221; is pressed, push a new screen onto the navigation stack.</p>
</li>
<li>
<p>A &#8220;cancel&#8221; option that dismisses the dialog box.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Like the <code>share</code> behavior, <code>alert</code> uses a namespace to define some attributes and elements.
The <code>&lt;behavior&gt;</code> element itself contains the <code>title</code> and <code>message</code> attributes for the dialog box.
The button options for the dialog are defined using a new <code>&lt;option&gt;</code> element nested in the <code>&lt;behavior&gt;</code>.
Notice that each <code>&lt;option&gt;</code> element has a label, and then optionally contains a <code>&lt;behavior&gt;</code> itself!
This structure of the HXML allows the system dialog to trigger any interaction that can be defined as a <code>&lt;behavior&gt;</code>.
In the example above, pressing the &#8220;Continue&#8221; button will open a new screen.
But we could just as easily trigger an update action to change the current screen.
We could even open a share sheet, or a second dialog box.
But please don&#8217;t do that in a real app!
With great power comes great responsibility.</p>
</div>
</div>
<div class="sect5">
<h6 id="_custom_actions">Custom Actions</h6>
<div class="paragraph">
<p>You can build a lot of mobile UIs with Hyperview&#8217;s standard navigation, update, and system actions.
But the standard set may not cover all interactions you will need for your mobile app.
Luckily, the action system is extensible.
In the same way you can add custom elements to Hyperview, you can also add custom behavior actions.
Custom actions have a similar syntax to the <code>share</code> and <code>alert</code> actions, using namespaces for attributes that pass along extra data.
Custom actions also have full access to the HXML of the current screen, so they can modify the state or add/remove elements from the current screen.
In the next chapter, we will create a custom behavior action to enhance our mobile contacts app.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_triggers">Triggers</h5>
<div class="paragraph">
<p>We&#8217;ve already seen the simplest type of trigger, a <code>press</code> on an element. Hyperview supports many other common triggers used in mobile apps.</p>
</div>
<div class="sect5">
<h6 id="_longpress">longPress</h6>
<div class="paragraph">
<p>Closely related to a press is a long-press.
A behavior with <code>trigger="longPress"</code> will trigger when the user presses and holds on the element.
&#8220;Long-press&#8221; interactions are often used for shortcuts and power features.
Sometimes, elements will support different actions for both a <code>press</code> and <code>longPress</code>.
This is done using multiple <code>&lt;behavior&gt;</code> elements on the same UI element.</p>
</div>
<div class="listingblock">
<div class="title">Long-press trigger example</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;text&gt;
  &lt;behavior trigger="press" action="push" href="/next-screen" /&gt; <b class="conum">(1)</b>
  &lt;behavior trigger="longPress" action="push" href="/secret-screen" /&gt; <b class="conum">(2)</b>
  Press (or long-press) me!
&lt;/text&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Normal press will open the next screen</p>
</li>
<li>
<p>Long press will open a different screen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this example, a normal press will open a new screen and request content from <code>/next-screen</code>.
However, a long press will open a new screen with content from <code>/secret-screen</code>.
This is a contrived example for the sake of brevity.
A better UX would be for the long-press to bring up a contextual menu of shortcuts and advanced options.
This could be achieved by using <code>action="alert"</code> and opening a system dialog box with the shortcuts.</p>
</div>
</div>
<div class="sect5">
<h6 id="_load">load</h6>
<div class="paragraph">
<p>Sometimes we want an action to trigger as soon as the screen loads.
<code>trigger="load"</code> does exactly this.
One use case is to quickly load a shell of the screen, and then fill in the main content on the screen with a second update action.</p>
</div>
<div class="listingblock">
<div class="title">Load trigger example</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;body&gt;
  &lt;view&gt;
    &lt;text&gt;My app&lt;/text&gt;
    &lt;view id="container"&gt; <b class="conum">(1)</b>
      &lt;behavior trigger="load" action="replace" href="/content" target="container"&gt; <b class="conum">(2)</b>
      &lt;text&gt;Loading...&lt;/text&gt; <b class="conum">(3)</b>
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Container element without the actual content</p>
</li>
<li>
<p>Behavior that immediately fires off a request for /content to replace the container</p>
</li>
<li>
<p>Loading UI that appears until the content is fetched and replaced.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this example, We load a screen with a heading (&#8220;My app&#8221;) but no content.
Instead, we show a <code>&lt;view&gt;</code> with ID &#8220;container&#8221; and some &#8220;Loading&#8230;&#8203;&#8221; text.
As soon as this screen loads, the behavior with <code>trigger=&#8220;load&#8221;</code> fires off the <code>replace</code> action.
It requests content from the <code>/content</code> path and replaces the container view with the response.</p>
</div>
</div>
<div class="sect5">
<h6 id="_visible">visible</h6>
<div class="paragraph">
<p>Unlike <code>load</code>, the <code>visible</code> trigger will only execute the behavior when the element with the behavior is scrolled into the viewport on the mobile device.
The <code>visible</code> action is commonly used to implement an infinite-scroll interaction on a <code>&lt;list&gt;</code> of <code>&lt;item&gt;</code> elements.
The last item in the list includes a behavior with <code>trigger="visible"</code>.
The <code>append</code> action will fetch the next page of items and append them to the list.</p>
</div>
</div>
<div class="sect5">
<h6 id="_refresh">refresh</h6>
<div class="paragraph">
<p>This trigger captures a &#8220;pull to refresh&#8221; action on <code>&lt;list&gt;</code> and <code>&lt;view&gt;</code> items.
This interaction is associated with fetching up-to-date content from the backend.
Thus, it&#8217;s typically paired with an update or reload action to show the latest data on the screen.</p>
</div>
<div class="listingblock">
<div class="title">Pull-to-refresh trigger example</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;body&gt;
  &lt;view scroll="true"&gt;
    &lt;behavior trigger="refresh" action="reload" /&gt; <b class="conum">(1)</b>
    &lt;text&gt;No items yet&lt;/text&gt;
  &lt;/view&gt;
&lt;/body&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>When the view is pulled down to refresh, reload the screen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that adding a behavior with <code>trigger="refresh"</code> to a <code>&lt;view&gt;</code> or <code>&lt;list&gt;</code> will add the pull-to-refresh interaction to the element, including showing a spinner as the element is pulled down.</p>
</div>
</div>
<div class="sect5">
<h6 id="_focus_blur_and_change"><code>focus</code>, <code>blur</code>, and <code>change</code></h6>
<div class="paragraph">
<p>These triggers are related to interactions with input elements.
Thus, they will only trigger behaviors attached to elements like <code>&lt;text-field&gt;</code>.
<code>focus</code> and <code>blur</code> will trigger when the user focuses and blurs the input element, respectively.
<code>change</code> will trigger when the value of the input element changes, like when the user types a letter in a text field.
These triggers are often used with behaviors that need to perform some server-side validation on the form fields.
For example, when the user types in a username and then blurs the field, a behavior could trigger on <code>blur</code> to make a request to the backend and check for uniqueness of the username.
If the entered username is not unique, the response could include an error message letting the user know they need to pick a different username.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_multiple_behaviors">Using Multiple Behaviors</h5>
<div class="paragraph">
<p>Most of the examples shown above attach a single <code>&lt;behavior&gt;</code> to an element.
But there&#8217;s no such limitation in Hyperview; elements can define multiple behaviors.
We already saw an example where a single element had different actions triggered on <code>press</code> and <code>longPress</code>.
But we can also trigger multiple actions on the same trigger.</p>
</div>
<div class="paragraph">
<p>In this admittedly contrived example, we want to hide two elements on the screen when pressing the &#8220;Hide&#8221; button.
The two elements are far apart in the HXML, and cannot be hidden by hiding a common parent element.
But, we can trigger two behaviors at the same time, each one executing a &#8220;hide&#8221; action but targeting different elements.</p>
</div>
<div class="listingblock">
<div class="title">Multiple behaviors triggering on press</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;screen&gt;
  &lt;body&gt;
    &lt;text id="area1"&gt;Area 1&lt;/text&gt;

    &lt;text&gt;
      &lt;behavior trigger="press" action="hide" target="area1" /&gt; <b class="conum">(1)</b>
      &lt;behavior trigger="press" action="hide" target="area2" /&gt; <b class="conum">(2)</b>
      Hide
    &lt;/text&gt;

    &lt;text id="area2"&gt;Area 2&lt;/text&gt;
  &lt;/body&gt;
&lt;/screen&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Hide element with ID &#8220;area1&#8221; when pressed</p>
</li>
<li>
<p>Hide element with ID &#8220;area2&#8221; when pressed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Hyperview processes behaviors in the order they appear in the markup.
In this case, the element with ID &#8220;area1&#8221; will be hidden first, followed by the element with ID &#8220;area2&#8221;.
Since &#8220;hide&#8221; is an instantaneous action (ie, it doesn&#8217;t make an HTTP request), both elements will appear to hide simultaneously.
But what if we triggered two actions that depend on responses from HTTP requests (like &#8220;replace-inner&#8221;)?
In that case, each individual action is processed as soon as Hyperview receives the HTTP response.
Depending on network latency, the two actions could take effect in any order, and they are not guaranteed to be applied simultaneously.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve seen elements with multiple behaviors and different triggers.
And we&#8217;ve seen elements with multiple behaviors with the same trigger.
These concepts can be mixed together too.
It&#8217;s not unusual for a production Hyperview app to contain several behaviors, some triggering together and others triggering on different interactions.
Using multiple behaviors with custom actions keeps HXML declarative, without sacrificing functionality.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary">12.4. Summary</h3>
<div class="ulist">
<ul>
<li>
<p>Mobile app platforms push developers towards a thick-client architecture. But apps that use a thick client suffer from the same problems as SPAs on the web.</p>
</li>
<li>
<p>Using the hypermedia architecture for mobile apps solves the problems with thick-client apps.</p>
</li>
<li>
<p>HTML web views are one way to implement the hypermedia architecture for mobile apps. But HTML is not designed for mobile UIs, so this approach does not deliver a great user experience.</p>
</li>
<li>
<p>Hyperview is an alternative approach to build mobile apps using the hypermedia architecture. Hyperview introduces a new format called HXML. It also provides an open-source mobile thin-client to render HXML.</p>
</li>
<li>
<p>HXML looks similar to HTML, but it uses elements that correspond to mobile UIs, like <code>&lt;screen&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;list&gt;</code> and more.</p>
</li>
<li>
<p>HXML also includes input elements that implement common patterns in mobile apps, such as <code>&lt;switch&gt;</code>, <code>&lt;select-single&gt;</code>, and <code>&lt;select-multiple&gt;</code>.</p>
</li>
<li>
<p>New UI components can be added to HXML using namespaced elements. The Hyperview client can be easily extended to render these new elements.</p>
</li>
<li>
<p>Interactions in HXML are defined using <code>&lt;behavior&gt;</code> elements. Inspired by htmx, <code>&lt;behavior&gt;</code> elements decouple user interactions (triggers) from the resulting actions.</p>
</li>
<li>
<p>Navigation between screens in Hyperview is done using behaviors with navigation actions, like <code>push</code>, <code>back</code>, <code>new</code>, and <code>close</code>.</p>
</li>
<li>
<p>Updates to screens in Hyperview are defined using behaviors with update actions, such as <code>replace</code> and <code>append</code>.</p>
</li>
<li>
<p>System interactions in Hyperview are defined using behaviors with system actions, such as <code>alert</code> and <code>share</code>.</p>
</li>
<li>
<p>New actions can be added to HXML using namespaced attributes. The Hyperview client can be easily extended to interpret the new actions.</p>
</li>
<li>
<p>The extensibility of HXML and the Hyperview client make it easy for developers to define custom elements and behaviors. Developers can evolve Hyperview to suit their apps' requirements, while fully embracing the hypermedia architecture.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_a_contacts_app_with_hyperview">13. Building a Contacts App With Hyperview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transforming the existing Contacts web app into a native mobile app using Hyperview</p>
</li>
<li>
<p>Using Hyperview behaviors to navigate between screens using stacks and modals</p>
</li>
<li>
<p>Communicating between screens using the Events system</p>
</li>
<li>
<p>Using the same backend to power both the web app and mobile app</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Earlier chapters in this book explained the benefits of building apps using the hypermedia architecture.
These benefits were demonstrated by building a robust Contacts web application.
Then, Chapter 6 argued that hypermedia concepts can and should be applied to platforms other than the Web.
We introduced Hyperview as an example of a hypermedia format and client specifically designed for building mobile apps.
But you may still be wondering: what is it like to create a fully-featured, production-ready mobile app using Hyperview?
Do we have to learn a whole new language and framework?
In this chapter, we will show Hyperview in action by porting the Contacts web app to a native mobile app.
You will see that many web development techniques (and indeed, much of the code) are completely identical when developing with Hyperview.
How is that possible?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Our Contacts web app was built with the principle of HATEOAS (Hypermedia as the Engine of Application State).
All of the app&#8217;s features (retrieving, searching, editing, and creating contacts) are implemented in the backend (the <code>Contacts</code> Python class).
Our mobile app, built with Hyperview, also leverages HATEOAS and relies on the backend for all of the app&#8217;s logic.
That means the <code>Contacts</code> Python class can power our mobile app the same way it powers the web app, without any changes required.</p>
</li>
<li>
<p>The client-server communication in the web app happens using HTTP.
The HTTP server for our web app is written using the Flask framework.
Hyperview also uses HTTP for client-server communication.
So we can re-use the Flask routes and views from the web app for the mobile app as well.</p>
</li>
<li>
<p>The web app uses HTML for its hypermedia format, and Hyperview uses HXML.
HTML and HXML are different formats, but the base syntax is similar (nested tags with attributes).
This means we can use the same templating library (Jinja) for HTML and HXML.
Additionally, many of the concepts of htmx are built into HXML.
We can directly port web app features implemented with htmx (search, infinite loading) to HXML.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Essentially, we can re-use almost everything from the web app backend, but we will need to replace the HTML templates with HXML templates.
Most of the sections in this chapter will assume we have the web contacts app running locally and listening on port 5000.
The focus will be on creating new HXML templates for our mobile app&#8217;s UI.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_mobile_app">13.1. Creating a mobile app</h3>
<div class="paragraph">
<p>But before we dive into HXML, there&#8217;s one pesky requirement: the Hyperview client.
When developing web applications, you only need to worry about the server because the client (web browser) is universally available.
There&#8217;s no equivalent Hyperview client installed on every mobile device.
Instead, we will create our own Hyperview client, customized to only talk to our server.
This client can be packaged up into an Android or iOS mobile app, and distributed through the respective app stores.</p>
</div>
<div class="paragraph">
<p>Luckily, we don&#8217;t need to start from scratch to implement a Hyperview client.
The Hyperview code repository comes with a demo backend and a demo client built using Expo.
We will use this demo client but point it to our contacts app backend as a starting point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">&gt; git clone git@github.com:Instawork/hyperview.git
&gt; cd hyperview/demo
&gt; yarn <b class="conum">(1)</b>
&gt; yarn start <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Install dependencies for the demo app</p>
</li>
<li>
<p>Start the Expo server to run the mobile app in the iOS simulator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After running <code>yarn start</code>, you will be presented with a prompt asking you to open the mobile app using an Android emulator or iOS simulator.
Select an option based on which developer SDK you have installed.
(The screenshots in this chapter will be taken from the iOS simulator.)
With any luck, you will see the Expo mobile app installed in the simulator.
The mobile app will automatically launch and show a screen saying &#8220;Network request failed.&#8221;
That&#8217;s because by default, this app is configured to make a request to <code><a href="http://0.0.0.0:8085/index.xml" class="bare">http://0.0.0.0:8085/index.xml</a></code>, but our backend is listening on port 5000.
To fix this, we can make a simple configuration change in the <code>demo/src/constants.js</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">//export const ENTRY_POINT_URL = 'http://0.0.0.0:8085/index.xml'; <b class="conum">(1)</b>
export const ENTRY_POINT_URL = 'http://0.0.0.0:5000/'; <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The default entrypoint URL in the demo app</p>
</li>
<li>
<p>Setting the URL to point to our contacts app</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;re not up and running yet.
With our Hyperview client now pointing to the right endpoint, we see a different error, a &#8220;ParseError&#8221;.
That&#8217;s because the backend is responding to requests with HTML content, but the Hyperview client expects an XML response (specifically, HXML).
So it&#8217;s time to turn our attention to our Flask backend.
We will go through the Flask views, and replace the HTML templates with HXML templates.
Specifically, let&#8217;s support the following features to our mobile app:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A searchable list of contacts</p>
</li>
<li>
<p>Viewing the details of a contact</p>
</li>
<li>
<p>Editing a contact</p>
</li>
<li>
<p>Deleting a contact</p>
</li>
<li>
<p>Adding a new contact</p>
</li>
</ul>
</div>
<aside class="sidebar">
        <div class="titlebar">Zero Client-Configuration in Hypermedia Applications</div>
        <div class="paragraph">
<p>For many mobile apps that use the Hyperview client, configuring this entrypoint URL is the only on-device code you need to write to deliver a full-featured app.
Think of the entrypoint URL as the address you type into a web browser to open a web app.
Except in Hyperview, there is no address bar, and the browser is hard-coded to only open one URL.
This URL will load the first screen when a user launches the app.
Every other action the user can take will be declared in the HXML of that first screen.
This minimal configuration is one elegant aspect of the Hypermedia-driven architecture!</p>
</div>
<div class="paragraph">
<p>Of course, you may want to write more on-device code to support more features in your mobile app.
We will demonstrate how to do that later in this chapter, in the section called &#8220;Extending the Client&#8221;.</p>
</div>
    </aside>
</div>
<div class="sect2">
<h3 id="_a_searchable_list_of_contacts">13.2. A Searchable List of Contacts</h3>
<div class="paragraph">
<p>We will start building our Hyperview app with the entrypoint screen, the list of contacts.
For the initial version of this screen, let&#8217;s support the following features from the web app:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>display a scrollable list of contacts</p>
</li>
<li>
<p>&#8220;search-as-you-type&#8221; field above the list</p>
</li>
<li>
<p>&#8220;infinite-scroll&#8221; to load more contacts as the user scrolls through</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, we will add a &#8220;pull-to-refresh&#8221; interaction on the list, since users expect this from list UIs in mobile apps.</p>
</div>
<div class="paragraph">
<p>If you recall, all of the pages in the Contacts web app extended a common base template, <code>layout.html</code>.
We need a similar base template for the screens of the mobile app.
This base template will contain the style rules or our UI, and a basic structure common to all screens.
Let&#8217;s call it <code>layout.xml</code>.</p>
</div>
<div class="listingblock">
<div class="title">Base template <code>hv/layout.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;doc xmlns="https://hyperview.org/hyperview"&gt;
  &lt;screen&gt;
    &lt;styles&gt;&lt;!-- omitted for brevity --&gt;&lt;/styles&gt;
    &lt;body style="body" safe-area="true"&gt;
      &lt;header style="header"&gt;
        {% block header %} <b class="conum">(1)</b>
          &lt;text style="header-title"&gt;Contact.app&lt;/text&gt;
        {% endblock %}
      &lt;/header&gt;

      &lt;view style="main"&gt;
        {% block content %}{% endblock %} <b class="conum">(2)</b>
      &lt;/view&gt;
    &lt;/body&gt;
  &lt;/screen&gt;
&lt;/doc&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The header section of the template, with a default title</p>
</li>
<li>
<p>The content section of the template, to be provided by other templates.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We covered the HXML tags and attributes in the previous chapter.
This template sets up a basic screen layout using <code>&lt;doc&gt;</code>, <code>&lt;screen&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;header&gt;</code>, and <code>&lt;view&gt;</code> tags.
Note that the HXML syntax plays well with the Jinja templating library.
Here, we&#8217;re using Jinja&#8217;s blocks to define two sections (<code>header</code> and <code>content</code>) that will hold the unique content of a screen.
With our base template completed, we can create a template specifically for the contacts list screen.</p>
</div>
<div class="listingblock">
<div class="title">Start of <code>hv/index.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% extends 'hv/layout.xml' %} <b class="conum">(1)</b>

{% block content %} <b class="conum">(2)</b>
  &lt;form&gt; <b class="conum">(3)</b>
    &lt;text-field name="q" value="" placeholder="Search..." style="search-field" /&gt;
    &lt;list id="contacts-list"&gt; <b class="conum">(4)</b>
      {% include 'hv/rows.xml' %}
    &lt;/list&gt;
  &lt;/form&gt;
{% endblock %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Extend the base layout template</p>
</li>
<li>
<p>Override the <code>content</code> block of the layout template</p>
</li>
<li>
<p>Create a search form that will issue an HTTP <code>GET</code> to <code>/contacts</code></p>
</li>
<li>
<p>The list of contacts, using a Jinja <code>include</code> tag.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This template extends the base <code>layout.xml</code>, and overrides the <code>content</code> block with a <code>&lt;form&gt;</code>.
At first, it might seem strange that the form wraps both the <code>&lt;text-field&gt;</code> and the <code>&lt;list&gt;</code> elements.
But remember: in Hyperview, the form data gets included in any request originating from a child element.
We will soon add interactions to the list (pull to refresh) that will require the form data.
Note the use of a Jinja <code>include</code> tag to render the HXML for the rows of contacts in the list (<code>hv/rows.xml</code>).
Just like in the HTML templates, we can use the <code>include</code> to break up our HXML into smaller pieces.
It also allows the server to respond with just the <code>rows.xml</code> template for interactions like searching, infinite scroll, and pull-to-refresh.</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;items xmlns="https://hyperview.org/hyperview"&gt; <b class="conum">(1)</b>
  {% for contact in contacts %} <b class="conum">(2)</b>
    &lt;item key="{{ contact.id }}" style="contact-item"&gt; <b class="conum">(3)</b>
      &lt;text style="contact-item-label"&gt;
        {% if contact.first %}
          {{ contact.first }} {{ contact.last }}
        {% elif contact.phone %}
          {{ contact.phone }}
        {% elif contact.email %}
          {{ contact.email }}
        {% endif %}
      &lt;/text&gt;
    &lt;/item&gt;
  {% endfor %}
&lt;/items&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An HXML element that groups a set of <code>&lt;item&gt;</code> elements in a common parent</p>
</li>
<li>
<p>Iterate over the contacts that were passed in to the template</p>
</li>
<li>
<p>Render an <code>&lt;item&gt;</code> for each contact, showing the name, phone number, or email.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the web app, each row in the list showed the contact&#8217;s name, phone number, and email address.
But in a mobile app, we have less real-estate.
It would be hard to cram all this information into one line.
Instead, the row just shows the contact&#8217;s first and last name, and falls back to email or phone if the name is not set.
To render the row, we again make use of Jinja template syntax to render dynamic text with data passed to the template.</p>
</div>
<div class="paragraph">
<p>We now have templates for the base layout, the contacts screen, and the contact rows.
But we still have to update the Flask views to use these templates.
Let&#8217;s take a look at the <code>contacts()</code> view in its current form, written for the web app:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    page = int(request.args.get("page", 1))
    if search:
        contacts_set = Contact.search(search)
        if request.headers.get('HX-Trigger') == 'search':
            return render_template("rows.html", contacts=contacts_set, page=page)
    else:
        contacts_set = Contact.all(page)
    return render_template("index.html", contacts=contacts_set, page=page)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This view supports fetching a set of contacts based on two query params, <code>q</code> and <code>page</code>.
It also decides whether to render the full page (<code>index.html</code>) or just the contact rows (<code>rows.html</code>) based on the <code>HX-Trigger</code> header.
This presents a minor problem.
The <code>HX-Trigger</code> header is set by the htmx library; there&#8217;s no equivalent feature in Hyperview.
Moreover, there are multiple scenarios in Hyperview that require us to respond with just the contact rows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>searching</p>
</li>
<li>
<p>pull-to-refresh</p>
</li>
<li>
<p>loading the next page of contacts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since we can&#8217;t depend on a header like <code>HX-Trigger</code>, we need a different way to detect if the client needs the full screen or just the rows in the response.
We can do this by introducing a new query param, <code>rows_only</code>.
When this param has the value <code>true</code>, the view will respond to the request by rendering the <code>rows.xml</code> template.
Otherwise, it will respond with the <code>index.xml</code> template:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/contacts")
def contacts():
    search = request.args.get("q")
    page = int(request.args.get("page", 1))
    rows_only = request.args.get("rows_only") == "true" <b class="conum">(1)</b>
    if search:
        contacts_set = Contact.search(search)
    else:
        contacts_set = Contact.all(page)

    template_name = "hv/rows.xml" if rows_only else "hv/index.xml" <b class="conum">(2)</b>
    return render_template(template_name, contacts=contacts_set, page=page)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Check for a new <code>rows_only</code> query param</p>
</li>
<li>
<p>Render the appropriate HXML template based on <code>rows_only</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There&#8217;s one more change we have to make.
Flask assumes that most views will respond with HTML.
So Flask defaults the <code>Content-Type</code> response header to a value of <code>text/html</code>.
But the Hyperview client expects to receive HXML content, indicated by a <code>Content-Type</code> response header with value <code>application/vnd.hyperview+xml</code>.
The client will reject responses with a different content type.
To fix this, we need to explicitly set the <code>Content-Type</code> response header in our Flask views.
We will do this by introducing a new helper function, <code>render_to_response()</code>:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">def render_to_response(template_name, *args, **kwargs):
    content = render_template(template_name, *args, **kwargs) <b class="conum">(1)</b>
    response = make_response(content) <b class="conum">(2)</b>
    response.headers['Content-Type'] = 'application/vnd.hyperview+xml' <b class="conum">(3)</b>
    return response</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Renders the given template with the supplied arguments and keyword arguments.</p>
</li>
<li>
<p>Create an explicit response object with the rendered template</p>
</li>
<li>
<p>Sets the response <code>Content-Type</code> header to XML.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, this helper function uses <code>render_template()</code> under the hood.
<code>render_template()</code> returns a string.
This helper function uses that string to create an explicit <code>Response</code> object.
The response object has a <code>headers</code> attribute, allowing us to set and change the response headers.
Specifically, <code>render_to_response()</code> sets <code>Content-Type</code> to <code>application/xml</code> so that the Hyperview client recognizes the content.
This helper is a drop-in replacement for <code>render_template</code> in our views.
So all we need to do is update the last line of the <code>contacts()</code> function.</p>
</div>
<div class="listingblock">
<div class="title"><code>contacts() function</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">return render_to_response(template_name, contacts=contacts_set, page=page) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Render the HXML template to an XML response.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With these changes to the <code>contacts()</code> view, we can finally see the fruits of our labor.
After restarting the backend and refreshing the screen in our mobile app, we can see the contacts screen!</p>
</div>
<div id="figure-7-1" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_list.png" alt="screenshot hyperview list">
</div>
<div class="title">Figure 11. Contacts Screen</div>
</div>
<div class="sect3">
<h4 id="_searching_contacts">Searching Contacts</h4>
<div class="paragraph">
<p>So far, we have a mobile app that displays a screen with a list of contacts.
But our UI doesn&#8217;t support any interactions.
Typing a query in the search field doesn&#8217;t filter the list of contacts.
Let&#8217;s add a behavior to the search field to implement a search-as-you-type interaction.
This requires expanding <code>&lt;text-field&gt;</code> to add a <code>&lt;behavior&gt;</code> element.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/index.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;text-field name="q" value="" placeholder="Search..." style="search-field"&gt;
  &lt;behavior
    trigger="change" <b class="conum">(1)</b>
    action="replace-inner" <b class="conum">(2)</b>
    target="contacts-list" <b class="conum">(3)</b>
    href="/contacts?rows_only=true" <b class="conum">(4)</b>
    verb="get" <b class="conum">(5)</b>
  /&gt;
&lt;/text-field&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This behavior will trigger when the value of the text field changes</p>
</li>
<li>
<p>When the behavior triggers, the action will replace the content inside the target element.</p>
</li>
<li>
<p>The target of the action is the element with ID <code>contacts-list</code>.</p>
</li>
<li>
<p>The replacement content will be fetched from this URL path.</p>
</li>
<li>
<p>The replacement content will be fetched with the <code>GET</code> HTTP method.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first thing you&#8217;ll notice is that we changed the text field from using a self-closing tag (<code>&lt;text-field /&gt;</code>) to using opening and closing tags (<code>&lt;text-field&gt;&#8230;&#8203;&lt;/text-field&gt;</code>).
This allows us to add a child <code>&lt;behavior&gt;</code> element to define an interaction.
The <code>trigger="change"</code> attribute tells Hyperview that a change to the value of the text field will trigger an action.
Any time the user edits the content of the text field by adding or deleting characters, an action will trigger.
The remaining attributes on the <code>&lt;behavior&gt;</code> element define the action.
<code>action="replace-inner"</code> means the action will update content on the screen, by replacing the HXML content of an element with new content.
For <code>replace-inner</code> to do its thing, we need to know two things: the current element on the screen that will be targeted by the action, and the content that will used for the replacement.
<code>target="contacts-list"</code> tells us the ID of the current element.
Note that we set <code>id="contacts-list"</code> on the <code>&lt;list&gt;</code> element in <code>index.xml</code>.
So when the user enters a search query into the text field, Hyperview will replace the content of <code>&lt;list&gt;</code> (a bunch of <code>&lt;item&gt;</code> elements)
with new content (<code>&lt;item&gt;</code> elements that match the search query) received in the relative href response
(the domain is inferred from the domain used to fetch the screen).
Note that <code>href</code> includes our <code>rows_only</code> query param; we want the response to only include the rows and not the entire screen.</p>
</div>
<div id="figure-7-2" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_search.png" alt="screenshot hyperview search">
</div>
<div class="title">Figure 12. Searching for Contacts</div>
</div>
<div class="paragraph">
<p>That&#8217;s all it takes to add search-as-you-type functionality to our mobile app!
As the user types a search query, the client will make requests to the backend and replace the list with the search results.
You may be wondering, how does the backend know the query to use?
The <code>href</code> attribute in the behavior does not include the <code>q</code> param expected by our backend.
But remember, in <code>index.xml</code>, we wrapped the <code>&lt;text-field&gt;</code> and <code>&lt;list&gt;</code> elements with a parent <code>&lt;form&gt;</code> element.
The <code>&lt;form&gt;</code> element defines a group of inputs that will be serialized and included in any HTTP requests triggered by its child elements.
In this case, the <code>&lt;form&gt;</code> element surrounds the search behavior and the text field.
So the value of the <code>&lt;text-field&gt;</code> will be included in our HTTP request for the search results.
Since we are making a <code>GET</code> request, the name and value of the text field will be serialized as a query param.
Any existing query params on the <code>href</code> will be preserved.
This means the actual HTTP request to our backend looks like <code>GET /contacts?rows_only=true&amp;q=Car</code>.
Our backend already supports the <code>q</code> param for searching, so the response will include rows that match the string &#8220;Car&#8221;.</p>
</div>
</div>
<div class="sect3">
<h4 id="_infinite_scroll_2">Infinite scroll</h4>
<div class="paragraph">
<p>If the user has hundreds or thousands of contacts, loading them all at once may result in poor app performance.
That&#8217;s why most mobile apps with long lists implement an interaction known as &#8220;infinite scroll&#8221;.
The app loads a fixed number of initial items in the list, let&#8217;s say 100 items.
If the user scrolls to the bottom of the list, they see a spinner indicating more content is loading.
Once the content is available, the spinner is replaced with the next page of 100 items.
These items are appended to the list, they don&#8217;t replace the first set of items.
So the list now contains 200 items.
If the user scrolls to the bottom of the list again, they will see another spinner, and the app will load the next set of content.
Infinite scroll improves app performance in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The initial request for 100 items will be processed quickly, with predictable latency.</p>
</li>
<li>
<p>Subsequent requests can also be fast and predictable.</p>
</li>
<li>
<p>If the user doesn&#8217;t scroll to the bottom of the list, the app won&#8217;t have to make subsequent requests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our Flask backend already supports pagination on the <code>/contacts</code> endpoint via the <code>page</code> query param.
We just need to modify our HXML templates to make use of this parameter.
To do this, let&#8217;s edit <code>rows.xml</code> to add a new <code>&lt;item&gt;</code> below the Jinja for-loop:</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;items xmlns="https://hyperview.org/hyperview"&gt;
  {% for contact in contacts %}
    &lt;item key="{{ contact.id }}" style="contact-item"&gt;
      &lt;!-- omitted for brevity --&gt;
    &lt;/item&gt;
  {% endfor %}
  {% if contacts|length &gt; 0 %}
    &lt;item key="load-more" id="load-more" style="load-more-item"&gt; <b class="conum">(1)</b>
      &lt;behavior
        trigger="visible" <b class="conum">(2)</b>
        action="replace" <b class="conum">(3)</b>
        target="load-more" <b class="conum">(4)</b>
        href="/contacts?rows_only=true&amp;page={{ page + 1 }}" <b class="conum">(5)</b>
        verb="get"
      /&gt;
      &lt;spinner /&gt; <b class="conum">(6)</b>
    &lt;/item&gt;
  {% endif %}
&lt;/items&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Include an extra <code>&lt;item&gt;</code> in the list to show the spinner</p>
</li>
<li>
<p>The item behavior triggers when visible in the viewport</p>
</li>
<li>
<p>When triggered, the behavior will replace an element on the screen</p>
</li>
<li>
<p>The element to be replaced is the item itself (ID <code>load-more</code>)</p>
</li>
<li>
<p>Replace the item with the next page of content</p>
</li>
<li>
<p>The spinner element</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the current list of contacts passed to the template is empty, we can assume there&#8217;s no more contacts to fetch from the backend.
So we use a Jinja conditional to only include this new <code>&lt;item&gt;</code> if the list of contacts is non-empty.
This new <code>&lt;item&gt;</code> element gets an ID and a behavior.
The behavior defines the infinite scroll interaction.
Up until now, we&#8217;ve seen <code>trigger</code> values of <code>change</code> and <code>refresh</code>.
But to implement infinite scroll, we need a way to trigger the action when the user scrolls to the bottom of the list.
The <code>visible</code> trigger can be used for this exact purpose.
It will trigger the action when the element with the behavior is visible in the device viewport.
In this case, the new <code>&lt;item&gt;</code> element is the last item in the list, so the action will trigger when the user scrolls down far enough for the item to enter the viewport.
As soon as the item is visible, the action will make an HTTP GET request, and replace the loading <code>&lt;item&gt;</code> element with the response content.
Note that our href must include the <code>rows_only=true</code> query param, so that our response will only include HXML for the contact items, and not the entire screen.
Also, we&#8217;re passing the <code>page</code> query param, incrementing the current page number to ensure we load the next page.</p>
</div>
<div class="paragraph">
<p>What happens when there&#8217;s more than one page of items?
The initial screen will include the first 100 items, plus the &#8220;load-more&#8221; item at the bottom.
When the user scrolls to the bottom of the screen, Hyperview will request the second page of items (<code>&amp;page=2</code>), and replace the &#8220;load-more&#8221; item with the new items.
But this second page of items will include a new &#8220;load-more&#8221; item.
So once the user scrolls through all of the items from the second page, Hyperview will again request more items (<code>&amp;page=3</code>).
And once again, the &#8220;load-more&#8221; item will be replaced with the new items.
This will continue until all of the items will be loaded on the screen.
At that point, there will be no more contacts to return, the response will not include another &#8220;load-more&#8221; item, and our pagination is over.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pull_to_refresh">Pull-to-refresh</h4>
<div class="paragraph">
<p>Pull-to-refresh is a common interaction in mobile apps, especially on screens featuring dynamic content.
It works like this:
At the top of a scrolling view, the user pulls the scrolling content downwards with a swipe-down gesture.
This reveals a spinner &#8220;below&#8221; the content.
Pulling the content down sufficiently far will trigger a refresh.
While the content refreshes, the spinner remains visible on screen, indicating to the user that the action is still taking place.
Once the content is refreshed, the content retracts back up to its default position, hiding the spinner and letting the user know that the interaction is done.</p>
</div>
<div id="figure-7-3" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_refresh_cropped.png" alt="screenshot hyperview refresh cropped">
</div>
<div class="title">Figure 13. Pull-to-refresh</div>
</div>
<div class="paragraph">
<p>This pattern is so common and useful that it&#8217;s built in to Hyperview via the <code>refresh</code> action.
Let&#8217;s add pull-to-refresh to our list of contacts to see it in action.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/index.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;list id="contacts-list"
  trigger="refresh" <b class="conum">(1)</b>
  action="replace-inner" <b class="conum">(2)</b>
  target="contacts-list" <b class="conum">(3)</b>
  href="/contacts?rows_only=true" <b class="conum">(4)</b>
  verb="get" <b class="conum">(5)</b>
&gt;
  {% include 'hv/rows.xml' %}
&lt;/list&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This behavior will trigger when the user does a &#8220;pull-to-refresh&#8221; gesture.</p>
</li>
<li>
<p>When the behavior triggers, this action will replace the content inside the target element.</p>
</li>
<li>
<p>The target of the action is the <code>&lt;list&gt;</code> element itself.</p>
</li>
<li>
<p>The replacement content will be fetched from this URL path.</p>
</li>
<li>
<p>The replacement content will be fetched with the <code>GET</code> HTTP method.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You&#8217;ll notice something unusual in the snippet above: rather than adding a <code>&lt;behavior&gt;</code> element to the <code>&lt;list&gt;</code>, we added the behavior attributes directly to the <code>&lt;list&gt;</code> element.
This is a shorthand notation that&#8217;s sometimes useful for specifying single behaviors on an element.
It is equivalent to adding a <code>&lt;behavior&gt;</code> element to the <code>&lt;list&gt;</code> with the same attributes.
So why did we use the shorthand syntax here?
It has to do with the action, <code>replace-inner</code>.
Remember, this action replaces all child elements of the target with the new content.
This includes <code>&lt;behavior&gt;</code> elements too!
Let&#8217;s say our <code>&lt;list&gt;</code> did contain a <code>&lt;behavior&gt;</code>.
If the user did a search or pull-to-refresh, we would replace the content of <code>&lt;list&gt;</code> with the content from <code>rows.xml</code>.
The <code>&lt;behavior&gt;</code> would no longer be defined on the <code>&lt;list&gt;</code>, and subsequent attempts to pull-to-refresh would not work.
By defining the behavior as attributes of <code>&lt;list&gt;</code>, the behavior will persist even when replacing the items in the list.
Generally, we prefer to use explicit <code>&lt;behavior&gt;</code> elements in my HXML.
It makes it easier to define multiple behaviors, and to move the behavior around while refactoring.
But the shorthand syntax is good to apply in situations like this.</p>
</div>
</div>
<div class="sect3">
<h4 id="_viewing_the_details_of_a_contact_2">Viewing The Details Of A Contact</h4>
<div class="paragraph">
<p>Now that our contacts list screen is in good shape, we can start adding other screens to our app.
The natural next step is to create a details screen, which appears when the user taps an item in the contacts list.
Let&#8217;s update the template that renders the contact <code>&lt;item&gt;</code> elements, and add a behavior to show the details screen.</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;items xmlns="https://hyperview.org/hyperview"&gt;
  {% for contact in contacts %}
    &lt;item key="{{ contact.id }}" style="contact-item"&gt;
      &lt;behavior trigger="press" action="push" href="/contacts/{{ contact.id }}" /&gt; <b class="conum">(1)</b>
      &lt;text style="contact-item-label"&gt;
        &lt;!-- omitted for brevity --&gt;
      &lt;/text&gt;
    &lt;/item&gt;
  {% endfor %}
&lt;/items&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Behavior to push the contact details screen onto the stack when pressed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Our Flask backend already has a route for serving the contact details at <code>/contacts/&lt;contact_id&gt;</code>.
In our template, we use a Jinja variable to dynamically generate the URL path for the current contact in the for-loop.
We also used the &#8220;push&#8221; action to show the details by pushing a new screen onto the stack.
If you reload the app, you can now tap any contact in the list, and Hyperview will open the new screen.
However, the new screen will show an error message.
That&#8217;s because our backend is still returning HTML in the response, and the Hyperview client expects HXML.
Let&#8217;s update the backend to respond with HXML and the proper headers.</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/contacts/&lt;contact_id&gt;")
def contacts_view(contact_id=0):
    contact = Contact.find(contact_id)
    return render_to_response("hv/show.xml", contact=contact) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Generate an XML response from a new template file.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Just like with the <code>contacts()</code> view, <code>contacts_view()</code> uses <code>render_to_response()</code> to set the <code>Content-Type</code> header on the response.
We&#8217;re also generating the response from a new HXML template, which we can create now:</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/show.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% extends 'hv/layout.xml' %} <b class="conum">(1)</b>

{% block header %} <b class="conum">(2)</b>
  &lt;text style="header-button"&gt;
    &lt;behavior trigger="press" action="back" /&gt; <b class="conum">(3)</b>
    Back
  &lt;/text&gt;
{% endblock %}

{% block content %} <b class="conum">(4)</b>
&lt;view style="details"&gt;
  &lt;text style="contact-name"&gt;{{ contact.first }} {{ contact.last }}&lt;/text&gt;

  &lt;view style="contact-section"&gt;
    &lt;text style="contact-section-label"&gt;Phone&lt;/text&gt;
    &lt;text style="contact-section-info"&gt;{{contact.phone}}&lt;/text&gt;
  &lt;/view&gt;

  &lt;view style="contact-section"&gt;
    &lt;text style="contact-section-label"&gt;Email&lt;/text&gt;
    &lt;text style="contact-section-info"&gt;{{contact.email}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
{% endblock %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Extend the base layout template</p>
</li>
<li>
<p>Override the <code>header</code> block of the layout template to include a "Back" button</p>
</li>
<li>
<p>Behavior to navigate to the previous screen when pressed</p>
</li>
<li>
<p>Override the <code>content</code> block to show the full details of the selected contact.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The contacts detail screen extends the base <code>layout.xml</code> template, just like we did in <code>index.xml</code>.
This time, we&#8217;re overriding content in both the <code>header</code> block and <code>content</code> block.
Overriding the header block lets us add a "Back" button with a behavior.
When pressed, the Hyperview client will unwind the navigation stack and return the user to the contacts list.
Note that triggering this behavior is not the only way to navigate back.
The Hyperview client respects navigation conventions on different platforms.
On iOS, users can also navigate to the previous screen by swiping right from the left edge of the device.
On Android, users can also navigate to the previous screen by pressing the hardware back button.
We don&#8217;t need to specify anything extra in the HXML to get these interactions!</p>
</div>
<div id="figure-7-4" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_detail_cropped.png" alt="screenshot hyperview detail cropped">
</div>
<div class="title">Figure 14. Contact Details Screen</div>
</div>
<div class="paragraph">
<p>With just a few simple changes, we&#8217;ve gone from a single-screen app to a multi-screen app.
Note that we didn&#8217;t need to change anything in the actual mobile app code to support our new screen.
This is a big deal.
In traditional mobile app development, adding screens can be a significant task.
Developers need to create the new screen, insert it into the appropriate place of the navigation hierarchy, and write code to open the new screen from existing screens.
In Hyperview, we just added a behavior with <code>action="push"</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editing_a_contact">13.3. Editing a Contact</h3>
<div class="paragraph">
<p>So far, our app lets us browse a list of contacts, and view details of a specific contact.
Wouldn&#8217;t it be nice to update the name, phone number, or email of a contact?
Let&#8217;s add UI to edit contacts as our next enhancement.</p>
</div>
<div class="paragraph">
<p>First we have to figure out how we want to display the editing UI.
We could push a new editing screen onto the stack, the same way we pushed the contact details screen.
But that&#8217;s not the best design from a user-experience perspective.
Pushing new screens makes sense when drilling down into data, like going from a list to a single item.
But editing is not a &#8220;drill-down&#8221; interaction, it&#8217;s a mode switch between viewing and editing.
So instead of pushing a new screen, let&#8217;s replace the current screen with the editing UI.
That means we need to add a button and behavior that use the <code>reload</code> action.
This button can be added to the header of the contact details screen.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/show.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% block header %}
  &lt;text style="header-button"&gt;
    &lt;behavior trigger="press" action="back" /&gt;
    Back
  &lt;/text&gt;

  &lt;text style="header-button"&gt; <b class="conum">(1)</b>
    &lt;behavior trigger="press" action="reload" href="/contacts/{{contact.id}}/edit" /&gt; <b class="conum">(2)</b>
    Edit
  &lt;/text&gt;
{% endblock %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The new &#8220;Edit&#8221; button</p>
</li>
<li>
<p>Behavior to reload the current screen with the edit screen when pressed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once again, we&#8217;re reusing an existing Flask route (<code>/contacts/&lt;contact_id&gt;/edit</code>) for the edit UI, and filling in the contact ID using data passed to the Jinja template.
We also need to update the <code>contacts_edit_get()</code> view to return an XML response based on an HXML template (<code>hv/edit.xml</code>).
I&#8217;ll skip the code sample because the needed changes are identical to what we applied to <code>contacts_view()</code> in the previous section.
Instead, let&#8217;s focus on the template for the edit screen.</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/edit.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% extends 'hv/layout.xml' %}

{% block header %}
  &lt;text style="header-button"&gt;
    &lt;behavior trigger="press" action="back" href="#" /&gt;
    Back
  &lt;/text&gt;
{% endblock %}

{% block content %}
&lt;form&gt; <b class="conum">(1)</b>
  &lt;view id="form-fields"&gt; <b class="conum">(2)</b>
    {% include 'hv/form_fields.xml' %} <b class="conum">(3)</b>
  &lt;/view&gt;

  &lt;view style="button"&gt; <b class="conum">(4)</b>
    &lt;behavior
      trigger="press"
      action="replace-inner"
      target="form-fields"
      href="/contacts/{{contact.id}}/edit"
      verb="post"
    /&gt;
    &lt;text style="button-label"&gt;Save&lt;/text&gt;
  &lt;/view&gt;
&lt;/form&gt;
{% endblock %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Form wrapping the input fields and buttons</p>
</li>
<li>
<p>Container with ID, containing the input fields</p>
</li>
<li>
<p>Template include to render the input fields</p>
</li>
<li>
<p>Button to submit the form data and update the input fields container</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Since the edit screen needs to send data to the backend, we wrap the entire content section in a <code>&lt;form&gt;</code> element.
This ensures the form field data will be included in the HTTP requests to our backend.
Within the <code>&lt;form&gt;</code> element, our UI is divided into two sections: the form fields, and the Save button.
The actual form fields are defined in a separate template (<code>form_fields.xml</code>) and added to the edit screen using a Jinja include tag.</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/form_fields.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view style="edit-group"&gt;
  &lt;view style="edit-field"&gt;
    &lt;text-field name="first_name" placeholder="First name" value="{{ contact.first }}" /&gt; <b class="conum">(1)</b>
    &lt;text style="edit-field-error"&gt;{{ contact.errors.first }}&lt;/text&gt; <b class="conum">(2)</b>
  &lt;/view&gt;

  &lt;view style="edit-field"&gt; <b class="conum">(3)</b>
    &lt;text-field name="last_name" placeholder="Last name" value="{{ contact.last }}" /&gt;
    &lt;text style="edit-field-error"&gt;{{ contact.errors.last }}&lt;/text&gt;
  &lt;/view&gt;

  &lt;!-- same markup for contact.email and contact.phone --&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Text input holding the current value for the contact&#8217;s first name</p>
</li>
<li>
<p>Text element that could display errors from the contact model</p>
</li>
<li>
<p>Another text field, this time for the contact&#8217;s last name</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I omitted the code for the contact&#8217;s phone number and email address, because they follow the same pattern as the first and last name.
Each contact field has its own <code>&lt;text-field&gt;</code>, and a <code>&lt;text&gt;</code> element below it to display possible errors.
The <code>&lt;text-field&gt;</code> has two important attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code> defines the name to use when serializing the text-field&#8217;s value into form data for HTTP requests.
We are using the same names as the web app from previous chapters (<code>first_name</code>, <code>last_name</code>, <code>phone</code>, <code>email</code>).
That way, we don&#8217;t need to make changes in our backend to parse the form data.</p>
</li>
<li>
<p><code>value</code> defines the pre-filled data in the text field.
Since we are editing an existing contact, it makes sense to pre-fill the text field with the current name, phone, or email.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You might be wondering, why did we choose to define the form fields in a separate template (<code>form_fields.xml</code>)?
To understand that decision, we need to first discuss the &#8220;Save&#8221; button.
When pressed, the Hyperview client will make an HTTP <code>POST</code> request to <code>contacts/&lt;contact_id&gt;/edit</code>, with form data serialized from the <code>&lt;text-field&gt;</code> inputs.
The HXML response will replace the contents of form field container (ID <code>form-fields</code>).
But what should that response be?
That depends on the validity of the form data:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the data is invalid (eg duplicate email address), our UI will remain in the editing mode and show error messages on the invalid fields.
This allows the user to correct the errors and try saving again.</p>
</li>
<li>
<p>If the data is valid, our backend will persist the edits, and our UI will switch back to a display mode (the contact details UI).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So our backend needs to distinguish between a valid and invalid edit.
To support these two scenarios, let&#8217;s make some changes to the existing <code>contacts_edit_post()</code> view in the Flask app.</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/contacts/&lt;contact_id&gt;/edit", methods=["POST"])
def contacts_edit_post(contact_id=0):
    c = Contact.find(contact_id)
    c.update(request.form['first_name'], request.form['last_name'], request.form['phone'], request.form['email']) <b class="conum">(1)</b>
    if c.save(): <b class="conum">(2)</b>
        flash("Updated Contact!")
        return render_to_response("hv/form_fields.xml", contact=c, saved=True) <b class="conum">(3)</b>
    else:
        return render_to_response("hv/form_fields.xml", contact=c) <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Update the contact object from the request&#8217;s form data.</p>
</li>
<li>
<p>Attempt to persist the updates. This returns <code>False</code> for invalid data.</p>
</li>
<li>
<p>On success, render the form fields template, and pass a <code>saved</code> flag to the template</p>
</li>
<li>
<p>On failure, render the form fields template. Error messages are present on the contact object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This view already contains conditional logic based on whether the contact model <code>save()</code> succeeds.
If <code>save()</code> fails, we render the <code>form_fields.xml</code> template.
<code>contact.errors</code> will contain error messages for the invalid fields, which will be rendered into the <code>&lt;text style="edit-field-error"&gt;</code> elements.
If <code>save()</code> succeeds, we will also render the <code>form_fields.xml</code> template.
But this time, the template will get a <code>saved</code> flag, indicating success.
We will update the template to use this flag to implement our desired UI: switching the UI back to display mode.</p>
</div>
<div class="listingblock">
<div class="title"><code>hv/form_fields.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view style="edit-group"&gt;
  {% if saved %} <b class="conum">(1)</b>
    &lt;behavior
      trigger="load" <b class="conum">(2)</b>
      action="reload" <b class="conum">(3)</b>
      href="/contacts/{{contact.id}}" <b class="conum">(4)</b>
    /&gt;
  {% endif %}

  &lt;view style="edit-field"&gt;
    &lt;text-field name="first_name" placeholder="First name" value="{{ contact.first }}" /&gt;
    &lt;text style="edit-field-error"&gt;{{ contact.errors.first }}&lt;/text&gt;
  &lt;/view&gt;

  &lt;!-- same markup for the other fields --&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only include this behavior after successfully saving a contact.</p>
</li>
<li>
<p>Trigger the behavior immediately</p>
</li>
<li>
<p>The behavior will reload the entire screen</p>
</li>
<li>
<p>The screen will be reloaded with the contact details screen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Jinja template conditional ensures that our behavior only renders on successful saves, and not when the screen first opens (or the user submits invalid data).
On success, the template includes a behavior that triggers immediately thanks to <code>trigger="load"</code>.
The action reloads the current screen with the Contact Details screen (from the <code>/contacts/&lt;contact_id&gt;</code> route).
The result?
When the user hits &#8220;Save&#8221;, our backend persists the new contact data, and the screen switches back to the Details screen.
Since the app will make a new HTTP request to get the contact details, it&#8217;s guaranteed to show the freshly saved edits.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Why not use a redirect?</div>
        <div class="paragraph">
<p>You may remember the web app version of this code behaved a little differently.
On a successful save, the view returned <code>redirect("/contacts/" + str(contact_id))</code>.
This HTTP redirect would tell the web browser to navigate to the contact details page.</p>
</div>
<div class="paragraph">
<p>This approach is not supported in Hyperview.
Why?
A web app&#8217;s navigation stack is simple: a linear sequence of pages, with only one active page at a time.
Navigation in a mobile app is considerably more complex.
Mobile apps use a nested hierarchy of navigation stacks, modals, and tabs.
All screens in this hierarchy are active, and may be displayed instantly in response to user actions.
In this world, how would the Hyperview client interpret an HTTP redirect?
Should it reload the current screen, push a new one, or navigate to a screen in the stack with the same URL?
Instead of making a choice that would be suboptimal for many scenarios, Hyperview takes a different approach.
Server-controlled redirects are not possible, but the backend can render navigation behaviors into the HXML.
This is what we do to switch from the Edit UI to the Details UI in the code above.
Think of these as client-side redirects, or better yet client-side navigations.</p>
</div>
    </aside>
<div class="paragraph">
<p>We now have a working Edit UI in our contacts app.
Users can enter the Edit mode by pressing a button on the contact details screen.
In the Edit mode, they can update the contact&#8217;s data and save it to the backend.
If the backend rejects the edits as invalid, the app stays in Edit mode and shows the validation errors.
If the backend accepts and persists the edits, the app will switch back to the details mode, showing the updated contact data.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add one more enhancement to the Edit UI.
It would be nice to let the user switch away from the Edit mode without needing to save the contact.
This is typically done by providing a &#8220;Cancel&#8221; action.
We can add this as a new button below the &#8220;Save&#8221; button.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/edit.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view style="button"&gt;
  &lt;behavior trigger="press" action="replace-inner" target="form-fields" href="/contacts/{{contact.id}}/edit" verb="post" /&gt;
  &lt;text style="button-label"&gt;Save&lt;/text&gt;
&lt;/view&gt;
&lt;view style="button"&gt; <b class="conum">(1)</b>
  &lt;behavior
    trigger="press"
    action="reload" <b class="conum">(2)</b>
    href="/contacts/{{contact.id}}" <b class="conum">(3)</b>
  /&gt;
  &lt;text style="button-label"&gt;Cancel&lt;/text&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New Cancel button on the edit screen</p>
</li>
<li>
<p>When pressed, reload the entire screen</p>
</li>
<li>
<p>The screen will be reloaded with the contact details screen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is the same technique we used to switch from the edit UI to the details UI upon successfully editing the contact.
But pressing &#8220;Cancel&#8221; will update the UI faster than pressing &#8220;Save&#8221;.
On save, the app will first make a <code>POST</code> request to save the data, and then a <code>GET</code> request for the details screen.
Cancelling skips the <code>POST</code>, and immediately makes the <code>GET</code> request.</p>
</div>
<div id="figure-7-5" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_edit.png" alt="screenshot hyperview edit">
</div>
<div class="title">Figure 15. Contact Edit Screen</div>
</div>
<div class="sect3">
<h4 id="_updating_the_contacts_list">Updating the Contacts List</h4>
<div class="paragraph">
<p>At this point, we can claim to have fully implemented the Edit UI.
But there&#8217;s a problem.
In fact, if we stopped here, users may even consider the app to be buggy!
Why?
It has to do with syncing the app state across multiple screens.
Let&#8217;s walk through this series of interactions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Launch the app to the Contacts List.</p>
</li>
<li>
<p>Press on the contact &#8220;Joe Blow&#8221; to load his Contact Details.</p>
</li>
<li>
<p>Press Edit to switch to the edit mode, and change the contact&#8217;s first name to &#8220;Joseph&#8221;.</p>
</li>
<li>
<p>Press Save to switch back to viewing mode. The contact&#8217;s name is now &#8220;Joseph Blow&#8221;.</p>
</li>
<li>
<p>Hit the back button to return to the Contacts List.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Did you catch the issue?
Our Contacts list is still showing the same list of names as when we launched the app.
The contact we just renamed to &#8220;Joseph&#8221; is still showing up in the list as &#8220;Joe&#8221;.
This is a general problem in Hypermedia applications.
The client does not have a notion of shared data across different parts of the UI.
Updates in one part of the app will not automatically update other parts of the app.
Luckily, there&#8217;s a solution to this problem in Hyperview: events.
Events are built into the behavior system, and allow lightweight communication between different parts of the UI.</p>
</div>
<aside class="sidebar">
        <div class="titlebar">Event Behaviors</div>
        <div class="paragraph">
<p>Events are a client-side feature of Hyperview.
You are probably familiar with events from working with HTML and the DOM.
DOM Elements will dispatch events as a result of user interactions.
Scripts can listen for these events, and respond to them by running arbitrary JavaScript code.
Events in Hyperview are a good deal simpler, but they don&#8217;t require any scripting and can be defined declaratively in the HXML.
This is done through the behavior system.
Events require adding a new behavior attribute, action type, and trigger type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>event-name</code>: This attribute of <code>&lt;behavior&gt;</code> defines the name of the event that will either be dispatched or listened for.</p>
</li>
<li>
<p><code>action="dispatch-event"</code>: When triggered, this behavior will dispatch an event with the name defined by the <code>event-name</code> attribute.
This event is dispatched globally across the entire Hyperview app.</p>
</li>
<li>
<p><code>trigger="on-event"</code>: This behavior will trigger if another behavior in the app dispatches an event matching the <code>event-name</code> attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a <code>&lt;behavior&gt;</code> element uses <code>action="dispatch-event"</code> or <code>trigger="on-event"</code>, it must also define an <code>event-name</code>.
Note that multiple behaviors can dispatch an event with the same name.
Likewise, multiple behaviors can trigger on the same event name.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at this simple behavior:</p>
</div>
<div class="paragraph">
<p><code>&lt;behavior trigger="press" action="toggle" target="container" /&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Pressing an element containing this behavior will toggle the visibility of an element with the ID &#8220;container&#8221;.
But what if the element we want to toggle is on a different screen?
The &#8220;toggle&#8221; action and target ID lookup only work on the current screen, so this solution wouldn&#8217;t work.
The solution is to create two behaviors, one on each screen, communicating via events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Screen A: <code>&lt;behavior trigger="press" action="dispatch-event" event-name="button-pressed" /&gt;</code></p>
</li>
<li>
<p>Screen B: <code>&lt;behavior trigger="on-event" event-name="button-pressed" action="toggle" target="container" /&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pressing an element containing the first behavior (on Screen A) will dispatch an event with the name &#8220;button-pressed&#8221;.
The second behavior (on Screen B) will trigger on an event with this name, and toggle the visibility of an element with ID &#8220;container&#8221;.</p>
</div>
<div class="paragraph">
<p>Events have plenty of uses, but the most common is to inform different screens about backend state changes that require the UI to be re-fetched.</p>
</div>
    </aside>
<div class="paragraph">
<p>We know enough about Hyperview&#8217;s event system to solve the bug in our app.
When the user saves a change to a contact, we need to dispatch an event from the Details screen.
And the Contacts screen needs to listen to that event, and reload itself to reflect the edits.
Since the <code>form_fields.xml</code> template already gets the <code>saved</code> flag when the backend successfully saves a contact, it&#8217;s a good place to dispatch the event:</p>
</div>
<div class="listingblock">
<div class="title">Snippet from <code>hv/form_fields.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% if saved %}
  &lt;behavior
    trigger="load" <b class="conum">(1)</b>
    action="dispatch-event" <b class="conum">(2)</b>
    event-name="contact-updated" <b class="conum">(3)</b>
  /&gt;
  &lt;behavior <b class="conum">(4)</b>
    trigger="load"
    action="reload"
    href="/contacts/{{contact.id}}"
  /&gt;
{% endif %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Trigger the behavior immediately</p>
</li>
<li>
<p>The behavior will dispatch an event</p>
</li>
<li>
<p>The event name is "contact-updated"</p>
</li>
<li>
<p>The existing behavior to show the Details UI.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, we just need the contacts list to listen for the <code>contact-updated</code> event, and reload itself:</p>
</div>
<div class="listingblock">
<div class="title">Snippet from <code>hv/index.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;form&gt;
  &lt;behavior
    trigger="on-event" <b class="conum">(1)</b>
    event-name="contact-updated" <b class="conum">(2)</b>
    action="replace-inner" <b class="conum">(3)</b>
    target="contacts-list"
    href="/contacts?rows_only=true"
    verb="get"
  /&gt;
  &lt;!-- text-field omitted --&gt;
  &lt;list id="contacts-list"&gt;
    {% include 'hv/rows.xml' %}
  &lt;/list&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Trigger the behavior on event dispatch</p>
</li>
<li>
<p>Trigger the behavior for dispatched events with the name &#8220;contact-updated&#8221;</p>
</li>
<li>
<p>When triggered, replace the contents of the <code>&lt;list&gt;</code> element with rows from the backend</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Any time the user edits a contact, the Contacts List screen will update to reflect the edits.
The addition of these two <code>&lt;behavior&gt;</code> elements fixes the bug: the Contacts List screen will correctly show &#8220;Joseph Blow&#8221; in the list.
Note that we intentionally added the new behavior inside the <code>&lt;form&gt;</code> element.
The ensures the triggered request will preserve any search query.
To show what we mean, let&#8217;s revisit the set of steps that demonstrated the buggy behavior.
Assume that before pressing on &#8220;Joe Blow&#8221;, the user had searched the contacts by typing &#8220;Joe&#8221; in the search field.
When the user later updates the contact to &#8220;Joseph Blow&#8221;, our template dispatches the &#8220;contact-updated&#8221; event, which triggers the <code>replace-inner</code> behavior on the contact list screen.
Due to the parent <code>&lt;form&gt;</code> element, the search query &#8220;Joe&#8221; will be serialized with the request: <code>GET /contacts?rows_only=true&amp;q=Joe</code>.
Since the name &#8220;Joseph&#8221; doesn&#8217;t match the query &#8220;Joe&#8221;, the contact we edited will not appear in the list (until the user clears out the query).
Our app&#8217;s state remains consistent across our backend and all active screens.</p>
</div>
<div class="paragraph">
<p>Events introduce a level of abstraction to behaviors.
So far, we&#8217;ve seen that editing a contact will cause the list of contacts to refresh.
But the list of contacts should also refresh after other actions, such as deleting a contact or adding a new contact.
As long as our HXML responses for deletion or creation include a behavior to dispatch a <code>contact-updated</code> event, then we will get the desired refresh behavior on the contacts list screen.
The screen doesn&#8217;t care what causes the <code>contact-updated</code> event to be dispatched.
It just knows what it needs to do when it happens.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_a_contact_2">13.4. Deleting a Contact</h3>
<div class="paragraph">
<p>Speaking of deleting a contact, this is a good next feature to implement.
We will let users delete a contact from the Edit UI.
So let&#8217;s add a new button to <code>edit.xml</code>.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/edit.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view style="button"&gt;
  &lt;behavior trigger="press" action="replace-inner" target="form-fields" href="/contacts/{{contact.id}}/edit" verb="post" /&gt;
  &lt;text style="button-label"&gt;Save&lt;/text&gt;
&lt;/view&gt;
&lt;view style="button"&gt;
  &lt;behavior trigger="press" action="reload" href="/contacts/{{contact.id}}" /&gt;
  &lt;text style="button-label"&gt;Cancel&lt;/text&gt;
&lt;/view&gt;
&lt;view style="button"&gt; <b class="conum">(1)</b>
  &lt;behavior
    trigger="press"
    action="append" <b class="conum">(2)</b>
    target="form-fields"
    href="/contacts/{{contact.id}}/delete" <b class="conum">(3)</b>
    verb="post"
  /&gt;
  &lt;text style="button-label button-label-delete"&gt;Delete Contact&lt;/text&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>New Delete Contact button on the edit screen</p>
</li>
<li>
<p>When pressed, append HXML to a container on the screen</p>
</li>
<li>
<p>The HXML will be fetched by making a <code>POST /contacts/&lt;contact_id&gt;/delete</code> request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The HXML for the Delete button is pretty similar to the Save button, but there are a few subtle differences.
Remember, pressing the Save button results in one of two expected outcomes: failing and showing validation errors on the form, or succeeding and switching to the contact details screen.
To support the first outcome (failing and showing validation errors), the save behavior replaces the contents of the <code>&lt;view id="form-fields"&gt;</code> container with a re-rendered version of <code>form_fields.xml</code>.
Therefore, using the <code>replace-inner</code> action makes sense.</p>
</div>
<div class="paragraph">
<p>Deletion does not involve a validation step, so there&#8217;s only one expected outcome: successfully deleting the contact.
When deletion succeeds, the contact no longer exists.
It doesn&#8217;t make sense to show the edit UI or contact details for a non-existent contact.
Instead, our app will navigate back to the previous screen (the contacts list).
Our response will only include behaviors that trigger immediately, there&#8217;s no UI to change.
Therefore, using the <code>append</code> action will preserve the current UI while Hyperview runs the actions.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/deleted.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view&gt;
  &lt;behavior trigger="load" action="dispatch-event" event-name="contact-updated" /&gt; <b class="conum">(1)</b>
  &lt;behavior trigger="load" action="back" /&gt; <b class="conum">(2)</b>
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>On load, dispatch the <code>contact-updated</code> event to update the contact lists screen</p>
</li>
<li>
<p>Navigate back to the contacts list screen.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that in addition to behavior to navigate back, this template also includes a behavior to dispatch the <code>contact-updated</code> event.
In the previous chapter section, we added a behavior to <code>index.xml</code> to refresh the list when that event is dispatched.
By dispatching the event after a deletion, we will make sure the deleted contact gets removed from the list.</p>
</div>
<div class="paragraph">
<p>Once again, I&#8217;m going to skip over the changes to the Flask backend.
Suffice it to say, we will need to update the <code>contacts_delete()</code> view to respond with the <code>hv/deleted.xml</code> template.
And we need to update the route to support <code>POST</code> in addition to <code>DELETE</code>, since the Hyperview client only understands <code>GET</code> and <code>POST</code>.</p>
</div>
<div class="paragraph">
<p>We now have a fully functioning deletion feature!
But it&#8217;s not the most user-friendly: it takes one accidental tap to permanently delete a contact.
For destructive actions like deleting a contact, it&#8217;s always a good idea to ask the user for confirmation.
We can add a confirmation to the delete behavior by using the <code>alert</code> system action described in the previous chapter.
As you recall, the <code>alert</code> action will show a system dialog box with buttons that can trigger other behaviors.
All we have to do is wrap the delete <code>&lt;behavior&gt;</code> in a behavior that uses <code>action="alert"</code>.</p>
</div>
<div class="listingblock">
<div class="title">Delete button in <code>hv/edit.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view style="button"&gt;
  &lt;behavior <b class="conum">(1)</b>
    xmlns:alert="https://hyperview.org/hyperview-alert"
    trigger="press"
    action="alert"
    alert:title="Confirm delete"
    alert:message="Are you sure you want to delete {{ contact.first }}?"
  &gt;
    &lt;alert:option alert:label="Confirm"&gt; <b class="conum">(2)</b>
      &lt;behavior <b class="conum">(3)</b>
        trigger="press"
        action="append"
        target="form-fields"
        href="/contacts/{{contact.id}}/delete"
        verb="post"
      /&gt;
    &lt;/alert:option&gt;
    &lt;alert:option alert:label="Cancel" /&gt; <b class="conum">(4)</b>
  &lt;/behavior&gt;
  &lt;text style="button-label button-label-delete"&gt;Delete Contact&lt;/text&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Pressing "Delete" triggers an action to show the system dialog with the given title and message.</p>
</li>
<li>
<p>The first pressable option in the system dialog</p>
</li>
<li>
<p>Pressing the first option will trigger contact deletion</p>
</li>
<li>
<p>The second pressable option has no behavior, so it only closes the dialog.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Unlike before, pressing the delete button will not have an immediate effect.
Instead, the user will be presented with the dialog box and asked to confirm or cancel.
Our core deletion behavior didn&#8217;t change, we just chained it from another behavior.</p>
</div>
<div id="figure-7-6" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_delete_cropped.png" alt="screenshot hyperview delete cropped">
</div>
<div class="title">Figure 16. Delete Contact confirmation</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_new_contact_2">13.5. Adding a New Contact</h3>
<div class="paragraph">
<p>Adding a new contact is the last feature we want to support in our mobile app.
And luckily, it&#8217;s also the easiest.
We can reuse the concepts (and even some templates) from features we&#8217;ve already implemented.
In particular, adding a new contact is very similar to editing an existing contact.
Both features need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Show a form to collect information about the contact</p>
</li>
<li>
<p>Have a way to save the entered information</p>
</li>
<li>
<p>Show validation errors on the form</p>
</li>
<li>
<p>Persist the contact when there are no validation errors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since the functionality is so similar, I&#8217;m going to summarize the changes here without showing the code.
Hopefully, you can follow along:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Update <code>index.xml</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Override the <code>header</code> block to add a new &#8220;Add&#8221; button.</p>
</li>
<li>
<p>Include a behavior in the button. When pressed, push a new screen as a modal by using <code>action="new"</code>, and request the screen content from <code>/contacts/new</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Create a template <code>hv/new.xml</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Override the header block to include a button that closes the modal, using <code>action="close"</code>.</p>
</li>
<li>
<p>Include the <code>hv/form_fields.xml</code> template to render empty form fields</p>
</li>
<li>
<p>Add a &#8220;Add Contact&#8221; button below the form fields.</p>
</li>
<li>
<p>Include a behavior in the button. When pressed, make a <code>POST</code> request to <code>/contacts/new</code>, and use <code>action="replace-inner"</code> to update the form fields.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Update the Flask view.</p>
<div class="ulist">
<ul>
<li>
<p>Change <code>contacts_new_get()</code> to use <code>render_to_response()</code> with the <code>hv/new.xml</code> template.</p>
</li>
<li>
<p>Change <code>contacts_new()</code> to use <code>render_to_response()</code> with the <code>hv/form_fields.xml</code> template. Pass <code>saved=True</code> when rendering the template after successfully persisting the new contact.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>By reusing <code>form_fields.xml</code> for both editing and adding a contact, we get to reuse some code and ensure the two features have a consistent UI.
Also, our &#8220;Add Contact&#8221; screen will benefit from the &#8220;saved&#8221; logic that&#8217;s already a part of <code>form_fields.xml</code>.
After successfully adding a new contact, the screen will dispatch the <code>contact-updated</code> event, which will refresh the contacts list and show the newly added contact.
The screen will reload itself to show the Contact Details.</p>
</div>
<div id="figure-7-7" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_add.png" alt="screenshot hyperview add">
</div>
<div class="title">Figure 17. Add Contact modal</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_the_app">13.6. Deploying the App</h3>
<div class="paragraph">
<p>With the completion of the contact creation UI, we have a fully implemented mobile app!
It supports searching a list of contacts, viewing the details of a contact, editing and deleting a contact, and adding a new contact.
But so far, we&#8217;ve been developing the app using a simulator on our desktop computer.
How can we see it running on a mobile device?
And how can we get it into the hands of our users?</p>
</div>
<div class="paragraph">
<p>To see the app running on a physical device, let&#8217;s take advantage of the Expo platform&#8217;s app preview functionality.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Download the Expo Go app on an Android or iOS device.</p>
</li>
<li>
<p>Restart the Flask app, binding to an interface accessible on your network.
This might look something like <code>flask run --host 192.168.7.229</code>, where the host is your computer&#8217;s IP address on the network.</p>
</li>
<li>
<p>Update the Hyperview client code so that <code>ENTRY_POINT_URL</code> (in <code>demo/src/constants.js</code>) points to the IP and port that the Flask server is bound to.</p>
</li>
<li>
<p>After running <code>yarn start</code> in the Hyperview demo app, you will see a QR code printed in the console, with instructions on how to scan it on Android and iOS.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once you scan the QR code, the full app will run on the device!
As you interact with the app, you will see HTTP requests made to the Flask server.
You can even use the physical device during development.
Any time you make a change in the HXML, just reload the screen to see the UI updates.</p>
</div>
<div class="paragraph">
<p>So we have the app running on a physical device, but it&#8217;s still not production ready.
To get the app into the hands of our users, there&#8217;s a few things we need to do:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Deploy our backend in production.
We need to use a production-grade web server like Gunicorn instead of the Flask development server.
And we should run our app on a machine reachable on the Internet, most likely using a cloud provider like AWS or Heroku.</p>
</li>
<li>
<p>Create standalone binary apps.
By following the instructions from the Expo project, we can create a <code>.ipa</code> or <code>.apk</code> file, for the iOS and Android platforms.
Remember to update <code>ENTRY_POINT_URL</code> in the Hyperview client to point to the production backend.</p>
</li>
<li>
<p>Submit our binaries to the iOS App Store or Google Play Store, and wait for app approval.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once the app is approved, congratulations!
Our mobile app can be downloaded by Android and iOS users.
And here&#8217;s the best part:
Because our app uses the hypermedia architecture, we can add features to our app by simply updating the backend.
The UI and interactions are completely specified with the HXML generated from server-side templates.
Want to add a new section to a screen?
Just update an existing HXML template.
Want to add a new type of screen to the app?
Create a new route, view, and HXML template.
Then, add a behavior to an existing screen that will open the new screen.
To push these changes to your users, you just need to re-deploy the backend.
Our app knows how to interpret HXML, and that&#8217;s enough for it to understand how to handle the new features.</p>
</div>
</div>
<div class="sect2">
<h3 id="_one_backend_multiple_hypermedia_formats">13.7. One Backend, Multiple Hypermedia formats</h3>
<div class="paragraph">
<p>To create a mobile app using the hypermedia architecture, we started with the web-based contacts app and made a few changes, primarily replacing HTML templates with HXML templates.
But in the process of porting the backend to serve our mobile app, we lost the web application functionality.
Indeed, if you tried to visit <code><a href="http://0.0.0.0:5000" class="bare">http://0.0.0.0:5000</a></code> in a web browser, you would see a jumble of text and XML markup.
That&#8217;s because web browsers don&#8217;t know how to render plain XML, and they certainly don&#8217;t know how to interpret the tags and attributes of HXML to render an app.
It&#8217;s a shame, because the Flask code for the web application and mobile app are nearly identical.
The database and model logic are shared, and most of the views are unchanged as well.</p>
</div>
<div class="paragraph">
<p>At this point you&#8217;re surely wondering: is it possible to use the same backend to serve both a web application and mobile app?
The answer is yes!
In fact, this is one of the benefits of using a hypermedia architecture across multiple platforms.
We don&#8217;t need to port any client-side logic from one platform to another, we just need to respond to requests with the appropriate Hypermedia format.
To do this, we will utilize content negotiation built into HTTP.</p>
</div>
<div class="sect3">
<h4 id="_what_is_content_negotiation">What is Content Negotiation?</h4>
<div class="paragraph">
<p>Imagine a German speaker and Japanese speaker both visit <code><a href="https://google.com" class="bare">https://google.com</a></code> in their web browser.
They will see the Google home page localized in German and Japanese, respectively.
How does Google know to return a different version of the homepage based on the user&#8217;s preferred language?
The answer lies in the REST architecture, and how it separates the concepts of resources and representations.</p>
</div>
<div class="paragraph">
<p>In the REST architecture, the Google homepage is considered to be a single &#8220;resource&#8221;, represented by a unique URL.
However, that single resource can have multiple &#8220;representations&#8221;.
Representations are variations on how the content of the resource is presented to the client.
The German and Japanese versions of the Google homepage are two representations of the same resource.
To determine the best representation of a resource to return, HTTP clients and servers engage in a process called &#8220;content negotiation&#8221;.
It works like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clients specify the preferred representation through <code>Accept-*</code> request headers.</p>
</li>
<li>
<p>The server tries to match the preferred representation as best it can, and communicates back the chosen representation using <code>Content-*</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the Google homepage example, the German speaker uses a browser that is set to prefer content localized for German.
Every HTTP request made by the web browser will include a header <code>Accept-Language: de-DE</code>.
The server sees the request header, and it will return a response localized for German (if it can).
The HTTP response will include a <code>Content-Language: de-DE</code> header to inform the client of the language of the response content.</p>
</div>
<div class="paragraph">
<p>Language is just one factor for resource representation.
More importantly for us, resources can be represented using different content types, such as HTML or HXML.
Content negotiation over content type is done using the <code>Accept</code> request header and <code>Content-Type</code> response header.
Web browsers set <code>text/html</code> as the preferred content type in the <code>Accept</code> header.
The Hyperview client sets <code>application/vnd.hyperview+xml</code> as the preferred content type.
This gives our backend a way to distinguish requests coming from a web browser or Hyperview client, and serve the appropriate content to each.
There are two main approaches: fine-grained and global.</p>
</div>
</div>
<div class="sect3">
<h4 id="_approach_1_template_switching">Approach 1: Template Switching</h4>
<div class="paragraph">
<p>When we ported the Contacts app from the web to mobile, we kept all of the Flask views but made some minor changes.
Specifically, we introduced a new function <code>render_to_response()</code> and called it in the return statement of each view.
Here&#8217;s the function again to refresh your memory:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">def render_to_response(template_name, *args, **kwargs):
    content = render_template(template_name, *args, **kwargs)
    response = make_response(content)
    response.headers['Content-Type'] = 'application/vnd.hyperview+xml'
    return response</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>render_to_response()</code> renders a template with the given context, and turns it into an Flask response object with the appropriate Hyperview <code>Content-Type</code> header.
Obviously, the implementation is highly-specific to serving our Hyperview mobile app.
But we can modify the function to do content negotiation based on the request&#8217;s <code>Accept</code> header:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">HTML_MIME = 'text/html'
HXML_MIME = 'application/vnd.hyperview+xml'

def render_to_response(html_template_name, hxml_template_name, *args, **kwargs): <b class="conum">(1)</b>
    response_type = request.accept_mimetypes.best_match([HTML_MIME, HXML_MIME], default=HTML_MIME) <b class="conum">(2)</b>
    template_name = hxml_template_name if response_type == HXML_MIME else html_template_name <b class="conum">(3)</b>
    content = render_template(template_name, *args, **kwargs)
    response = make_response(content)
    response.headers['Content-Type'] = response_type <b class="conum">(4)</b>
    return response</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Function signature takes two templates, one for HTML and one for HXML</p>
</li>
<li>
<p>Determine whether the client wants HTML or HXML</p>
</li>
<li>
<p>Select the template based on the best match for the client</p>
</li>
<li>
<p>Set the <code>Content-Type</code> header based on the best match for the client</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Flask&#8217;s request object exposes an <code>accept_mimetypes</code> property to help with content negotiation.
We pass our two content MIME types to <code>request.accept_mimetypes.best_match()</code> and get back the MIME type that works for our client.
Based on the best matching MIME type, we choose to either render an HTML template or HXML template.
We also make sure to set the <code>Content-Type</code> header to the appropriate MIME type.
The only difference in our Flask views is that we need to provide both an HTML and HXML template:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/contacts/&lt;contact_id&gt;")
def contacts_view(contact_id=0):
    contact = Contact.find(contact_id)
    return render_to_response("show.html", "hv/show.xml", contact=contact) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Template switching between an HTML and HXML template, based on the client.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After updating all of the Flask views to support both templates, our backend will support both web browsers and our mobile app!
This technique works well for the Contacts app because the screens in the mobile app map directly to pages of the web application.
Each app has a dedicated page (or screen) for listing contacts, showing and editing details, and creating a new contact.
This meant the Flask views could be as-is without major changes.
But what if we wanted to re-imagine the Contacts app UI for our mobile app?
Perhaps we want the mobile app to use a single screen, with rows that expanded in-line to support viewing and editing the information?
In situations where the UI diverges between platforms, Template Switching becomes cumbersome or impossible.
We need a different approach to have one backend serve both hypermedia formats.</p>
</div>
</div>
<div class="sect3">
<h4 id="_approach_2_the_redirect_fork">Approach 2: The Redirect Fork</h4>
<div class="paragraph">
<p>If you recall, the Contacts web app has an <code>index</code> view, routed from the root path <code>/</code>:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/")
def index():
    return redirect("/contacts") <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Redirect requests from "/" to "/contacts"</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When someone requests to the root path of the web application, Flask redirects them to the <code>/contacts</code> path.
This redirect also works in our Hyperview mobile app.
The Hyperview client&#8217;s <code>ENTRY_POINT_URL</code> points to <code><a href="http://0.0.0.0:5000/" class="bare">http://0.0.0.0:5000/</a></code>, and the server redirects it to <code><a href="http://0.0.0.0:5000/contacts" class="bare">http://0.0.0.0:5000/contacts</a></code>.
But there&#8217;s no law that says we need to redirect to the same path in our web application and mobile app.
What if we used the <code>Accept</code> header to redirect to decide on the redirect path?</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">HTML_MIME = 'text/html'
HXML_MIME = 'application/vnd.hyperview+xml'

@app.route("/")
def index():
    response_type = request.accept_mimetypes.best_match([HTML_MIME, HXML_MIME], default=HTML_MIME) <b class="conum">(1)</b>
    if response_type == HXML_MIME:
      return redirect("/mobile/contacts") <b class="conum">(2)</b>
    else:
      return redirect("/web/contacts") <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Determine whether the client wants HTML or HXML</p>
</li>
<li>
<p>If the client wants HXML, redirect them to <code>/mobile/contacts</code></p>
</li>
<li>
<p>If the client wants HTML, redirect them to <code>/web/contacts</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The entrypoint is a fork in the road: if the client wants HTML, we redirect them to one path.
If the client wants HXML, we redirect them to a different path.
These redirects would be handled by different Flask views:</p>
</div>
<div class="listingblock">
<div class="title"><code>app.py</code></div>
<div class="content">
<pre class="highlight"><code class="language-py" data-lang="py">@app.route("/mobile/contacts")
def mobile_contacts():
  # Render an HXML response

@app.route("/web/contacts")
def web_contacts():
  # Render an HTML response</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mobile_contacts()</code> view would render an HXML template with a list of contacts.
Tapping a contact item would open a screen requested from <code>/mobile/contacts/1</code>, handled by a view <code>mobile_contacts_view</code>.
After the initial fork, all subsequent requests from our mobile app go to paths prefixed with <code>/mobile/</code>, and get handled by mobile-specific Flask views.
Likewise, all subsequent requests from the web app go to paths prefixed with <code>/web/</code>, and get handled by web-specific Flask views.
(Note that in practice, we would want to separate the web and mobile views into separate parts of our codebase: <code>web_app.py</code> and <code>mobile_app.py</code>. We may also choose not to prefix the web paths with <code>/web/</code>, if we want more elegant URLs displayed in the browser&#8217;s address bar.)</p>
</div>
<div class="paragraph">
<p>You may be thinking that the Redirect Fork leads to a lot of code duplication.
After all, we need to write double the number of views: one set for the web application, and one set for the mobile app.
That is true, which is why the Redirect Fork is only preferred if the two platforms require a disjointed set of view logic.
If the apps are similar on both platforms, Template Switching will save a lot of time and keep the apps consistent.
Even if we need to use the Redirect Fork, the bulk of the logic in our models can be shared by both sets of views.
In practice, you may start out using Template Switching, but then realize you need to implement a fork for platform-specific features.
In fact, we&#8217;re already doing that in the Contacts app.
When porting the app from web to mobile, we didn&#8217;t bring over certain features like archiving functionality.
The dynamic archive UI is a power feature that wouldn&#8217;t make sense on a mobile device.
Since our HXML templates don&#8217;t expose any entrypoints to the Archive functionality, we can treat it as &#8220;web-only&#8221; and not worry about supporting it in Hyperview.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_2">13.8. Summary</h3>
<div class="ulist">
<ul>
<li>
<p>Creating a Hyperview-powered mobile app is as simple as cloning a Git repo and configuring a single entrypoint URL.</p>
</li>
<li>
<p>Flask is perfectly suited for serving a Hyperview mobile app. The Jinja templating system can generate dynamic HXML based on the context from a view.</p>
</li>
<li>
<p>Using elements like <code>&lt;view&gt;</code>, <code>&lt;text&gt;</code>, <code>&lt;list&gt;</code>, and <code>&lt;item&gt;</code>, we can create native-feeling screens in HXML.</p>
</li>
<li>
<p>Using behaviors, we can implement interactions on the contacts list such as infinite scroll, search-as-you-type, and pull-to-refresh.</p>
</li>
<li>
<p>Events are a client-side feature of Hyperview that allows triggering behaviors across screens. They are useful to keep state in sync throughout the app, such as after editing or deleting a contact.</p>
</li>
<li>
<p>A Hyperview-powered mobile app can be bundled and released through the iOS and Android app stores. New screens and features can be added to the app just by updating the backend!</p>
</li>
<li>
<p>The same Flask backend can support both web and mobile apps. Using HTTP content negotiation, a server can render either HTML or HXML responses from the same view. More complex apps may require the use of redirects and platform-specific views.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_the_hyperview_client">14. Extending the Hyperview Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding phone call and email integration with a custom behavior action</p>
</li>
<li>
<p>Showing confirmation toast messages with a custom behavior action</p>
</li>
<li>
<p>Supporting a &#8220;swipeable row&#8221; UI with a custom Hyperview component</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the previous chapter, we created a fully-featured native mobile version of our Contacts app.
Aside from customizing the entrypoint URL, we didn&#8217;t need to touch any code that runs on the mobile device.
We defined our mobile app&#8217;s UI and logic completely in the backend code, using Flask and HXML templates.
This is possible because the standard Hyperview client supports all of the basic features by mobile apps.
But the standard Hyperview client can&#8217;t do everything out of the box.
App developers want their apps to have unique touches like custom UIs or deep integration with platform capabilities.
To support these needs, the Hyperview client was designed to be extended with custom behavior actions and UI elements.
In this section, we will enhance our mobile app with examples of both.</p>
</div>
<div class="paragraph">
<p>Before diving in, a quick introduction on the tech stack we&#8217;ll be using.
The Hyperview client is written in React Native.
If you&#8217;re not familiar with React Native, it is a popular cross-platform framework for creating mobile apps.
It uses the same component-based API as React.
This means developers familiar with JavaScript and React can quickly pick up React Native.
React Native has a healthy ecosystem of open-source libraries.
We&#8217;ll be leveraging these libraries to create our custom extensions to the Hyperview client.</p>
</div>
<div class="sect2">
<h3 id="_adding_phone_calls_and_email">14.1. Adding Phone Calls and Email</h3>
<div class="paragraph">
<p>Let&#8217;s start with the most obvious feature missing from our Contacts app: phone calls.
Mobile devices can make phone calls.
The contacts in our app have phone numbers.
Shouldn&#8217;t our app support calling those phone numbers?
And while we&#8217;re at it, our app should also support e-mailing the contacts.</p>
</div>
<div class="paragraph">
<p>On the web, calling phone numbers is supported with the <code>tel:</code> URI scheme, and e-mails are supported with the <code>mailto:</code> URI scheme:</p>
</div>
<div class="listingblock">
<div class="title"><code>tel</code> and <code>mailto</code> schemes in HTML</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="tel:555-555-5555"&gt;Call&lt;/a&gt; <b class="conum">(1)</b>
&lt;a href="mailto:joe@example.com"&gt;Email&lt;/a&gt; <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>When clicked, prompt the user to call the given phone number</p>
</li>
<li>
<p>When clicked, open an e-mail client with the given address populated in the <code>to:</code> field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Hyperview client doesn&#8217;t support the <code>tel:</code> and <code>mailto:</code> URI schemes.
But we can add these capabilities to the client with custom behavior actions.
Remember that behaviors are interactions defined in HXML.
Behaviors have triggers (&#8220;press&#8221;, &#8220;refresh&#8221;) and actions (&#8220;update&#8221;, &#8220;share&#8221;).
The values of &#8220;action&#8221; are not limited to the set that comes in the Hyperview library.
So let&#8217;s define two new actions, &#8220;open-phone&#8221; and &#8220;open-email&#8221;.</p>
</div>
<div class="listingblock">
<div class="title">Phone and Email actions</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view xmlns:comms="https://manning.com/hyperview/communications"&gt; <b class="conum">(1)</b>
  &lt;text&gt;
    &lt;behavior action="open-phone" comms:phone-number="555-555-5555" /&gt; <b class="conum">(2)</b>
    Call
  &lt;/text&gt;
  &lt;text&gt;
    &lt;behavior action="open-email" comms:email-address="joe@example.com" /&gt; <b class="conum">(3)</b>
    Email
  &lt;/text&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define an alias for an XML namespace used by our new attributes</p>
</li>
<li>
<p>When pressed, prompt the user to call the given phone number</p>
</li>
<li>
<p>When pressed, open an e-mail client with the given address populated in the <code>to:</code> field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Notice we defined the actual phone number and email address using separate attributes.
In HTML, the scheme and data are crammed into the <code>href</code> attribute.
HXML&#8217;s <code>&lt;behavior&gt;</code> elements give more options for representing the data.
I chose to use attributes, but we could&#8217;ve represented the phone number or email using child elements.
I&#8217;m also using a namespace to avoid potential future conflicts with other client extensions.</p>
</div>
<div class="paragraph">
<p>So far so good, but how does the Hyperview client know how to interpret <code>open-phone</code> and <code>open-email</code>, and how to reference the <code>phone-number</code> and <code>email-address</code> attributes?
This is where we finally need to write some JavaScript.</p>
</div>
<div class="paragraph">
<p>First, I&#8217;m going to add a 3rd-party library (<code>react-native-communications</code>) to our demo app.
This library provides a simple API that interacts with OS-level functionality for calls and emails.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">&gt; cd hyperview/demo
&gt; yarn add react-native-communications <b class="conum">(1)</b>
&gt; yarn start <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add dependency on <code>react-native-communications</code></p>
</li>
<li>
<p>Re-start the mobile app</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, we&#8217;ll create a new file, <code>phone.js</code>, that will implement the code associated with the <code>open-phone</code> action:</p>
</div>
<div class="listingblock">
<div class="title">demo/src/phone.js</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { phonecall } from 'react-native-communications'; <b class="conum">(1)</b>

const namespace = "https://manning.com/hyperview/communications";

export default {
  action: "open-phone", <b class="conum">(2)</b>
  callback: (behaviorElement) =&gt; { <b class="conum">(3)</b>
    const number = behaviorElement.getAttributeNS(namespace, "phone-number"); <b class="conum">(4)</b>
    if (number != null) {
      phonecall(number, false); <b class="conum">(5)</b>
    }
  },
};</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Import the function we need from the 3rd party library.</p>
</li>
<li>
<p>The name of the action</p>
</li>
<li>
<p>The callback that runs when the action triggers.</p>
</li>
<li>
<p>Get the phone number from the <code>&lt;behavior&gt;</code> element.</p>
</li>
<li>
<p>Pass the phone number to the function from the 3rd party library.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Custom actions are defined as a JavaScript object with two keys: <code>action</code> and <code>callback</code>.
This is how the Hyperview client associates a custom action in the HXML with our custom code.
The callback value is a function that takes a single parameter, <code>behaviorElement</code>.
This parameter is an XML DOM representation of the <code>&lt;behavior&gt;</code> element that triggered the action.
That means we can call methods on it like <code>getAttribute</code>, or access attributes like <code>childNodes</code>.
In this case, we use <code>getAttributeNS</code> to read the phone number from the <code>phone-number</code> attribute on the <code>&lt;behavior&gt;</code> element.
If the phone number is defined on the element, we can call the <code>phonecall()</code> function provided by the <code>react-native-communications</code> library.</p>
</div>
<div class="paragraph">
<p>There&#8217;s one more thing we need to do before we can use our custom action: register the action with the Hyperview client.
The Hyperview client is represented as a React Native component called <code>Hyperview</code>.
This component takes a prop called <code>behaviors</code>, which is an array of custom action objects like our &#8220;open-phone&#8221; action.
Let&#8217;s pass our &#8220;open-phone&#8221; implementation to the <code>Hyperview</code> component in our demo app.</p>
</div>
<div class="listingblock">
<div class="title">demo/src/HyperviewScreen.js</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import React, { PureComponent } from 'react';
import Hyperview from 'hyperview';
import OpenPhone from './phone'; <b class="conum">(1)</b>

export default class HyperviewScreen extends PureComponent {
  // ... omitted for brevity

  behaviors = [OpenPhone]; <b class="conum">(2)</b>

  render() {
    return (
      &lt;Hyperview
        behaviors={this.behaviors} <b class="conum">(3)</b>
        entrypointUrl={this.entrypointUrl}
        // more props...
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Import the open-phone action</p>
</li>
<li>
<p>Create an array of custom actions</p>
</li>
<li>
<p>Pass the custom actions to the <code>Hyperview</code> component, as a prop called <code>behaviors</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Under the hood, the <code>Hyperview</code> component is responsible for taking HXML and turning it into mobile UI elements.
It also handles triggering behavior actions based on user interactions.
By passing the &#8220;open-phone&#8221; action to Hyperview, we can now use it as a value for the <code>action</code> attribute on <code>&lt;behavior&gt;</code> elements.
In fact, let&#8217;s do that now by updating the <code>show.xml</code> template in our Flask app:</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/show.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% block content %}
&lt;view style="details"&gt;
  &lt;text style="contact-name"&gt;{{ contact.first }} {{ contact.last }}&lt;/text&gt;

  &lt;view style="contact-section"&gt;
    &lt;behavior <b class="conum">(1)</b>
      xmlns:comms="https://manning.com/hyperview/communications"
      trigger="press"
      action="open-phone" <b class="conum">(2)</b>
      comms:phone-number="{{contact.phone}}" <b class="conum">(3)</b>
    /&gt;
    &lt;text style="contact-section-label"&gt;Phone&lt;/text&gt;
    &lt;text style="contact-section-info"&gt;{{contact.phone}}&lt;/text&gt;
  &lt;/view&gt;

  &lt;view style="contact-section"&gt;
    &lt;behavior <b class="conum">(4)</b>
      xmlns:comms="https://manning.com/hyperview/communications"
      trigger="press"
      action="open-email"
      comms:email-address="{{contact.email}}"
    /&gt;
    &lt;text style="contact-section-label"&gt;Email&lt;/text&gt;
    &lt;text style="contact-section-info"&gt;{{contact.email}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
{% endblock %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a behavior to the phone number section that triggers on &#8220;press&#8221;.</p>
</li>
<li>
<p>Trigger the new &#8220;open-phone&#8221; action.</p>
</li>
<li>
<p>Set the attribute expected by the &#8220;open-phone&#8221; action.</p>
</li>
<li>
<p>Same idea, with a different action (&#8220;open-email&#8221;)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I skipped over the implementation of the second custom action, &#8220;open-email&#8221;.
As you can guess, this action will open a system-level email composer to let the user send an email to their contact.
The implementation of &#8220;open-email&#8221; is almost identical to &#8220;open-phone&#8221;.
The <code>react-native-communications</code> library exposes a function called <code>email()</code>, so we just wrap it and pass arguments to it in the same way.</p>
</div>
<div class="paragraph">
<p>There we have a complete example of extending the client with some custom behavior actions!
We chose a new name for our actions (&#8220;open-phone&#8221; and &#8220;open-email&#8221;), and mapped those names to functions.
The functions take <code>&lt;behavior&gt;</code> elements and can run any arbitrary React Native code.
We wrapped an existing 3rd party library, and read attributes set on the <code>&lt;behavior&gt;</code> element to pass data to the library.
After re-starting our demo app, our client has new capabilities we can immediately utilize by referencing the actions from our HXML templates.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_toast_messages">14.2. Adding Toast Messages</h3>
<div class="paragraph">
<p>The phone and email actions added in the previous section are examples of &#8220;system actions&#8221;.
System actions trigger some UI or capability provided by the device&#8217;s OS.
But custom actions are not limited to only interacting with OS-level APIs.
Remember, the callbacks that implement actions can run arbitrary code, including code that renders our own UI elements.
This next custom action example will do just that: render a custom confirmation toast UI element.</p>
</div>
<div class="paragraph">
<p>If you recall, our Contacts web app shows messages upon successful actions, such as deleting or creating a contact.
These messages are generated in the Flask backend using the <code>flash()</code> function, called from the views.
Then the base <code>layout.html</code> template rendered the messages into the final web page.</p>
</div>
<div class="listingblock">
<div class="title">Snippet templates/layout.html</div>
<div class="content">
<pre>{% for message in get_flashed_messages() %}
  &lt;div class="flash"&gt;{{ message }}&lt;/div&gt;
{% endfor %}</pre>
</div>
</div>
<div class="paragraph">
<p>Our Flask app still includes the calls to <code>flash()</code>, but the Hyperview app is not accessing the flashed message to display to the user.
Let&#8217;s add that support now.
We could just show the messages using a similar technique to the web app: loop through the messages and render some <code>&lt;text&gt;</code> elements in <code>layout.xml</code>.
This approach has a major downside: the rendered messages would be tied to a specific screen.
If that screen was hidden by a navigation action, the message would be hidden too.
What we really want is for our toast UI to display &#8220;above&#8221; all of the screens in the navigation stack.
That way, the toast would remain visible (fading away after a few seconds), even if the stack of screens changes below.
To display some UI outside of the <code>&lt;screen&gt;</code> elements, we&#8217;re going to need to extend the Hyperview client with a new custom action, <code>show-toast</code>.
This is another opportunity to use an open-source library, <code>react-native-root-toast</code>.
Let&#8217;s add this library to our demo app.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">&gt; cd hyperview/demo
&gt; yarn add react-native-root-toast <b class="conum">(1)</b>
&gt; yarn start <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add dependency on <code>react-native-root-toast</code></p>
</li>
<li>
<p>Re-start the mobile app</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, we can write the code to implement the toast UI as a custom action.</p>
</div>
<div class="listingblock">
<div class="title">demo/src/toast.js</div>
<div class="content">
<pre>import Toast from 'react-native-root-toast'; <b class="conum">(1)</b>

const namespace = "https://manning.com/hyperview/toast";

export default {
  action: "show-toast", <b class="conum">(2)</b>
  callback: (behaviorElement) =&gt; { <b class="conum">(3)</b>
    const message = behaviorElement.getAttributeNS(namespace, "message");
    if (message != null) {
      Toast.show(message, {position: Toast.positions.TOP, duration: 2000}); <b class="conum">(4)</b>
    }
  },
};</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Import the <code>Toast</code> API.</p>
</li>
<li>
<p>The name of the action</p>
</li>
<li>
<p>The callback that runs when the action triggers</p>
</li>
<li>
<p>Pass the message to the toast library</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code looks very similar to the implementation of <code>open-phone</code>.
Both callbacks follow a similar pattern: read namespaced attributes from the <code>&lt;behavior&gt;</code> element, and pass those values to a 3rd party library.
For simplicity, I&#8217;m hard-coding options to show the toast at the top of the screen, fading out after 2 seconds.
But <code>react-native-root-toast</code> exposes many options for positioning, timing of animations, colors, and more.
We could specify these options using extra attributes on <code>behaviorElement</code> to make the action more configurable.
For our purposes, we will just stick to a bare-bones implementation.</p>
</div>
<div class="paragraph">
<p>Now we just need to register our custom action with the <code>&lt;Hyperview&gt;</code> component, by passing it to the <code>behaviors</code> prop.</p>
</div>
<div class="listingblock">
<div class="title">demo/src/HyperviewScreen.js</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import React, { PureComponent } from 'react';
import Hyperview from 'hyperview';
import OpenEmail from './email';
import OpenPhone from './phone';
import ShowToast from './toast'; <b class="conum">(1)</b>

export default class HyperviewScreen extends PureComponent {
  // ... omitted for brevity

  behaviors = [OpenEmail, OpenPhone, ShowToast]; <b class="conum">(2)</b>

  // ... omitted for brevity
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Import the show-toast action</p>
</li>
<li>
<p>Pass the action to the <code>Hyperview</code> component, as a prop called <code>behaviors</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All that&#8217;s left to do is trigger the <code>show-toast</code> action from our HXML.
There are three user actions that result in showing a toast message:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creating a new contact</p>
</li>
<li>
<p>Updating an existing contact</p>
</li>
<li>
<p>Deleting a contact</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first two actions are implemented in our app using the same HXML template, <code>form_fields.xml</code>.
Upon successfully creating or updating a contact, this template will reload the screen and trigger an event, using behaviors that trigger on &#8220;load&#8221;.
The deletion action also uses behaviors that trigger on &#8220;load&#8221;, defined in the <code>deleted.xml</code> template.
So both <code>form_fields.xml</code> and <code>deleted.xml</code> need to be modified to also show toasts on load.
Since the actual behaviors will be the same in both templates, let&#8217;s create a shared template to reuse the HXML.</p>
</div>
<div class="listingblock">
<div class="title">hv/templates/toasts.xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">{% for message in get_flashed_messages() %}
  &lt;behavior <b class="conum">(1)</b>
    xmlns:toast="https://manning.com/hyperview/toast"
    trigger="load" <b class="conum">(2)</b>
    action="show-toast" <b class="conum">(3)</b>
    toast:message="{{ message }}" <b class="conum">(4)</b>
  /&gt;
{% endfor %}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define a behavior for each message to display</p>
</li>
<li>
<p>Trigger this behavior as soon as the screen loads</p>
</li>
<li>
<p>Trigger the new &#8220;show-toast&#8221; action.</p>
</li>
<li>
<p>The &#8220;show-toast&#8221; action will display the flashed message in its UI.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Like in <code>layout.html</code> of the web app, we loop through all of the flashed messages and render some markup for each message.
However, in the web app, the message was directly rendered into the web page.
In the Hyperview app, each message is displayed using a behavior that triggers our custom UI.
Now we just need to include this template in <code>form_fields.xml</code>:</p>
</div>
<div class="listingblock">
<div class="title">Snippet of hv/templates/form_fields.xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view xmlns="https://hyperview.org/hyperview" style="edit-group"&gt;
  {% if saved %}
    {% include "hv/toasts.xml" %} <b class="conum">(1)</b>
    &lt;behavior trigger="load" once="true" action="dispatch-event" event-name="contact-updated" /&gt;
    &lt;behavior trigger="load" once="true" action="reload" href="/contacts/{{contact.id}}" /&gt;
  {% endif %}
  &lt;!-- omitted for brevity --&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Show the toasts as soon as the screen loads.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>And we can do the same thing in <code>deleted.xml</code>:</p>
</div>
<div class="listingblock">
<div class="title">hv/templates/deleted.xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;view xmlns="https://hyperview.org/hyperview"&gt;
  {% include "hv/toasts.xml" %} <b class="conum">(1)</b>
  &lt;behavior trigger="load" action="dispatch-event" event-name="contact-updated" /&gt;
  &lt;behavior trigger="load" action="back" /&gt;
&lt;/view&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Show the toasts as soon as the screen loads.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In both <code>form_fields.xml</code> and <code>deleted.xml</code>, multiple behaviors get triggered on &#8220;load&#8221;.
In <code>deleted.xml</code>, we immediately navigate back to the previous screen.
In <code>form_fields.xml</code>, we immediately reload the current screen to show the Contact details.
If we rendered our toast UI elements directly in the screen, the user would barely see them before the screen disappeared or reloaded.
By using a custom action, the toast UI remains visible even while the screens change beneath them.</p>
</div>
<div id="figure-7-8" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_toast.png" alt="screenshot hyperview toast">
</div>
<div class="title">Figure 18. Toast shown during back navigation</div>
</div>
</div>
<div class="sect2">
<h3 id="_swipe_gesture_on_contacts">14.3. Swipe gesture on Contacts</h3>
<div class="paragraph">
<p>To add communication capabilities and the toast UI, we extended the client with custom behavior actions.
But the Hyperview client can also be extended with custom UI components that render on the screen.
Custom components are implemented as React Native components.
That means anything that&#8217;s possible in React Native can be done in Hyperview as well!
Custom components open up endless possibilities to build rich mobile apps with the Hypermedia architecture.</p>
</div>
<div class="paragraph">
<p>To illustrate the possibilities, we will extend the Hyperview client in our mobile app to add a &#8220;swipeable row&#8221; component.
How does it work?
The &#8220;swipeable row&#8221; component supports a horizontal swiping gesture.
As the user swipes this component from right to left, the component will slide over, revealing a series of action buttons.
Each action button will be able to trigger standard Hyperview behaviors when pressed.
We will use this custom component in our Contacts List screen.
Each contact item will be a &#8220;swipeable row&#8221;, and the actions will give quick access to edit and delete actions for the contact.</p>
</div>
<div id="figure-7-9" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_swipe.png" alt="screenshot hyperview swipe">
</div>
<div class="title">Figure 19. Swipeable contact item</div>
</div>
<div class="sect3">
<h4 id="_designing_the_component">Designing The Component</h4>
<div class="paragraph">
<p>Rather than implementing the swipe gesture from scratch, we will once again use an open-source third-party library: <code>react-native-swipeable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">&gt; cd hyperview/demo
&gt; yarn add react-native-swipeable <b class="conum">(1)</b>
&gt; yarn start <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add dependency on <code>react-native-swipeable</code></p>
</li>
<li>
<p>Re-start the mobile app</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This library provides a React Native component called <code>Swipeable</code>.
It can render any React Native components as its main content (the part that can be swiped).
It also takes an array of React Native components as a prop to render as the action buttons.
When designing a custom component, we like to define the HXML of the component before writing the code.
This way, we can make sure the markup is expressive but succinct, and will work with the underlying library.
For the swipeable row, we need a way to represent the entire component, the main content, and one of many buttons.
I came up with something that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;swipe:row xmlns:swipe="https://manning.com/hyperview/swipeable"&gt; <b class="conum">(1)</b>
  &lt;swipe:main&gt; <b class="conum">(2)</b>
    &lt;!-- main content shown here --&gt;
  &lt;/swipe:main&gt;

  &lt;swipe:button&gt; <b class="conum">(3)</b>
    &lt;!-- first button that appears when swiping --&gt;
  &lt;/swipe:button&gt;

  &lt;swipe:button&gt; <b class="conum">(4)</b>
    &lt;!-- second button that appears when swiping --&gt;
  &lt;/swipe:button&gt;
&lt;/swipe:row&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Parent element encapsulating the entire swipeable row, with custom namespace</p>
</li>
<li>
<p>The main content of the swipeable row, can hold any HXML</p>
</li>
<li>
<p>The first button that appears when swiping, can hold any HXML</p>
</li>
<li>
<p>The second button that appears when swiping, can hold any HXML</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This structure clearly separates the main content from the buttons.
It also supports one, two, or more buttons.
Buttons appear in the order of definition, making it easy to swap the order.
This design covers everything we need to implement a swipeable row for our contacts list.
But it&#8217;s also generic enough to be reusable.
The markup above contains nothing specific to the contact name, editing the contact, or deleting the contact.
If down the line, we add another list screen to our app, we can use this component to make the items in that list swipeable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_the_component">Implementing The Component</h4>
<div class="paragraph">
<p>Now that we know the HXML structure of our custom component, we can write the code to implement it.
What does that code look like?
Hyperview components are written as React Native components.
These React Native components are mapped to a unique XML namespace and tag name.
When the Hyperview client encounters that namespace and tag name in the HXML, it delegates rendering of the HXML element to the matching React Native component.
As part of delegation, the Hyperview Client passes several props to the React Native component:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>element</code>: The XML DOM element that maps to the React Native component</p>
</li>
<li>
<p><code>stylesheets</code>: The styles defined in the <code>&lt;screen&gt;</code></p>
</li>
<li>
<p><code>onUpdate</code>: The function to call when the component triggers a behavior</p>
</li>
<li>
<p><code>option</code>: Miscellaneous settings used by the Hyperview client.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our swipeable row component is a container with slots to render arbitrary main content and buttons.
That means it needs to delegate rendering back to the Hyperview client to render those parts of the UI.
This is done with a public function exposed by the Hyperview client, <code>Hyperview.renderChildren()</code>.</p>
</div>
<div class="paragraph">
<p>Now that we know how custom Hyperview components are implemented, let&#8217;s write the code for our swipeable row.</p>
</div>
<div class="listingblock">
<div class="title">demo/src/swipeable.js</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import React, { PureComponent } from 'react';
import Hyperview from 'hyperview';
import Swipeable from 'react-native-swipeable';

const NAMESPACE_URI = 'https://manning.com/hyperview/swipeable';

export default class SwipeableRow extends PureComponent { <b class="conum">(1)</b>
  static namespaceURI = NAMESPACE_URI; <b class="conum">(2)</b>
  static localName = "row"; <b class="conum">(3)</b>

  getElements = (tagName) =&gt; {
    return Array.from(this.props.element.getElementsByTagNameNS(NAMESPACE_URI, tagName));
  };

  getButtons = () =&gt; { <b class="conum">(4)</b>
    return this.getElements("button").map((buttonElement) =&gt; {
      return Hyperview.renderChildren(buttonElement, this.props.stylesheets, this.props.onUpdate, this.props.options); <b class="conum">(5)</b>
    });
  };

  render() {
    const [main] = this.getElements("main");
    if (!main) {
      return null;
    }

    return (
      &lt;Swipeable rightButtons={this.getButtons()}&gt; <b class="conum">(6)</b>
        {Hyperview.renderChildren(main, this.props.stylesheets, this.props.onUpdate, this.props.options)} <b class="conum">(7)</b>
      &lt;/Swipeable&gt;
    );
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Class-based React Native component</p>
</li>
<li>
<p>Map this component to the given HXML namespace</p>
</li>
<li>
<p>Map this component to the given HXML tag name</p>
</li>
<li>
<p>Function that returns an array of React Native components for each <code>&lt;button&gt;</code> element.</p>
</li>
<li>
<p>Delegate to the Hyperview client to render each button</p>
</li>
<li>
<p>Pass the buttons and main content to the third-party library</p>
</li>
<li>
<p>Delegate to the Hyperview client to render the main content</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>SwipeableRow</code> class implements a React Native component.
At the top of the class, we set a static <code>namespaceURI</code> property and <code>localName</code> property.
These properties map the React Native component to a unique namespace and tag name pair in the HXML.
This is how the Hyperview client knows to delegate to <code>SwipeableRow</code> when encountering custom elements in the HXML.
At the bottom of the class, you&#8217;ll see a <code>render()</code> method.
<code>render()</code> gets called by React Native to return the rendered component.
Since React Native is built on principle of composition, <code>render()</code> typically returns a composition of other React Native components.
In this case, we return the <code>Swipeable</code> component (provided by the <code>react-native-swipeable</code> library), composed with React Native components for the buttons and main content.
The React Native components for the buttons and main content are created using a similar process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Find the specific child elements (<code>&lt;button&gt;</code> or <code>&lt;main&gt;</code>)</p>
</li>
<li>
<p>Turn those elements into React Native components using <code>Hyperview.renderChildren()</code></p>
</li>
<li>
<p>Set the components as children or props of <code>Swipeable</code>.</p>
</li>
</ul>
</div>
<div id="figure-7-10" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/figure_hyperview_components.png" alt="figure hyperview components">
</div>
<div class="title">Figure 20. Component rendering delegation</div>
</div>
<div class="paragraph">
<p>I realize this code may be hard to follow if you&#8217;ve never worked with React or React Native.
That&#8217;s ok.
The important takeaway is: we can write code to translate arbitrary HXML into React Native components.
The structure of the HXML (both attributes and elements) can be used to represent multiple facets of the UI (in this case, the buttons and main content).
Finally, the code can delegate rendering of child components back to the Hyperview client.
That means this swipeable row component is completely generic.
The actual structure and styling and interactions of the main content and buttons can be defined in the HXML.
Creating a generic component means we can reuse it across multiple screens for different purposes.
If we add more custom components or new behavior actions in the future, they will work with our swipeable row implementation.</p>
</div>
<div class="paragraph">
<p>The last thing to do is register this new component with the Hyperview client.
The process is similar to registering custom actions.
Custom components are passed as a separate <code>components</code> prop to the <code>Hyperview</code> component.</p>
</div>
<div class="listingblock">
<div class="title">demo/src/HyperviewScreen.js</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import React, { PureComponent } from 'react';
import Hyperview from 'hyperview';
import OpenEmail from './email';
import OpenPhone from './phone';
import ShowToast from './toast';
import SwipeableRow from './swipeable'; <b class="conum">(1)</b>

export default class HyperviewScreen extends PureComponent {
  // ... omitted for brevity

  behaviors = [OpenEmail, OpenPhone, ShowToast];
  components = [SwipeableRow]; <b class="conum">(2)</b>

  render() {
    return (
      &lt;Hyperview
        behaviors={this.behaviors}
        components={this.components} <b class="conum">(3)</b>
        entrypointUrl={this.entrypointUrl}
        // more props...
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Import the <code>SwipeableRow</code> component</p>
</li>
<li>
<p>Create an array of custom components</p>
</li>
<li>
<p>Pass the custom component to the <code>Hyperview</code> component, as a prop called <code>components</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to update our HXML templates to make use of the new swipeable row component!</p>
</div>
<div class="sect4">
<h5 id="_using_the_component">Using The Component</h5>
<div class="paragraph">
<p>Currently, the HXML for a contact item in the list consists of a <code>&lt;behavior&gt;</code> and <code>&lt;text&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;item key="{{ contact.id }}" style="contact-item"&gt;
  &lt;behavior trigger="press" action="push" href="/contacts/{{ contact.id }}" /&gt; <b class="conum">(1)</b>
  &lt;text style="contact-item-label"&gt;
    &lt;!-- omitted for brevity --&gt;
  &lt;/text&gt;
&lt;/item&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With our swipeable row component, this markup will become the &#8220;main&#8221; UI.
So let&#8217;s start by adding <code>&lt;row&gt;</code> and <code>&lt;main&gt;</code> as parent elements.</p>
</div>
<div class="listingblock">
<div class="title">Adding swipeable row <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;item key="{{ contact.id }}"&gt;
  &lt;swipe:row xmlns:swipe="https://manning.com/hyperview/swipeable"&gt; <b class="conum">(1)</b>
    &lt;swipe:main&gt; <b class="conum">(2)</b>
      &lt;view style="contact-item"&gt; <b class="conum">(3)</b>
        &lt;behavior trigger="press" action="push" href="/contacts/{{ contact.id }}" /&gt; <b class="conum">(1)</b>
        &lt;text style="contact-item-label"&gt;
          &lt;!-- omitted for brevity --&gt;
        &lt;/text&gt;
      &lt;/view&gt;
    &lt;/swipe:main&gt;
  &lt;/swipe:row&gt;
&lt;/item&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Added <code>&lt;swipe:row&gt;</code> parent element, with namespace alias for <code>swipe</code>.</p>
</li>
<li>
<p>Added <code>&lt;swipe:main&gt;</code> element to define the main content</p>
</li>
<li>
<p>Wrapped the existing <code>&lt;behavior&gt;</code> and <code>&lt;text&gt;</code> elements in a <code>&lt;view&gt;</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Previously, the <code>contact-item</code> style was set on the <code>&lt;item&gt;</code> element.
That made sense when the <code>&lt;item&gt;</code> element was the container for the main content of the list item.
Now that the main content is a child of <code>&lt;swipe:main&gt;</code>, we need to introduce a new <code>&lt;view&gt;</code> where we apply the styles.</p>
</div>
<div class="paragraph">
<p>If we reload our backend and mobile app, you won&#8217;t experience any changes on the Contacts List screen yet.
Without any action buttons defined, there&#8217;s nothing to reveal when swiping a row.
Let&#8217;s add two buttons to the swipeable row.</p>
</div>
<div class="listingblock">
<div class="title">Adding swipeable row <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;item key="{{ contact.id }}"&gt;
  &lt;swipe:row xmlns:swipe="https://manning.com/hyperview/swipeable"&gt; <b class="conum">(1)</b>
    &lt;swipe:main&gt;
      &lt;!-- omitted for brevity --&gt;
    &lt;/swipe:main&gt;

    &lt;swipe:button&gt; <b class="conum">(1)</b>
      &lt;view style="swipe-button"&gt;
        &lt;text style="button-label"&gt;Edit&lt;/text&gt;
      &lt;/view&gt;
    &lt;/swipe:button&gt;

    &lt;swipe:button&gt; <b class="conum">(2)</b>
      &lt;view style="swipe-button"&gt;
        &lt;text style="button-label-delete"&gt;Delete&lt;/text&gt;
      &lt;/view&gt;
    &lt;/swipe:button&gt;
  &lt;/swipe:row&gt;
&lt;/item&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Added <code>&lt;swipe:button&gt;</code> for edit action</p>
</li>
<li>
<p>Added <code>&lt;swipe:button&gt;</code> for delete action</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now if we use our mobile app, we can see the swipeable row in action!
As you swipe the contact item, the &#8220;Edit&#8221; and &#8220;Delete&#8221; buttons reveal themselves.
But they don&#8217;t do anything yet. We need to add some behaviors to these buttons.
The &#8220;Edit&#8221; button is straight-forward: pressing it should open the contact details screen in edit mode.</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;swipe:button&gt;
  &lt;view style="swipe-button"&gt;
    &lt;behavior trigger="press" action="push" href="/contacts/{{ contact.id }}/edit" /&gt; <b class="conum">(1)</b>
    &lt;text style="button-label"&gt;Edit&lt;/text&gt;
  &lt;/view&gt;
&lt;/swipe:button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>When pressed, push a new screen with the Edit Contact UI.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The &#8220;Delete&#8221; button is a bit more complicated.
There&#8217;s no screen to open for deletion, so what should happen when the user presses this button?
Perhaps we use the same interaction as the &#8220;Delete&#8221; button on the Edit Contact screen.
That interaction brings up a system dialog, asking the user to confirm the deletion.
If the user confirms, the Hyperview client makes a <code>POST</code> request to <code>/contacts/&lt;contact_id&gt;/delete</code>, and appends the response to the screen.
The response triggers a few behaviors immediately to reload the contacts list and show a toast message.
This interaction will work for our action button as well:</p>
</div>
<div class="listingblock">
<div class="title">Snippet of <code>hv/rows.xml</code></div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;swipe:button&gt;
  &lt;view style="swipe-button"&gt;
    &lt;behavior <b class="conum">(1)</b>
      xmlns:alert="https://hyperview.org/hyperview-alert"
      trigger="press"
      action="alert"
      alert:title="Confirm delete"
      alert:message="Are you sure you want to delete {{ contact.first }}?"
    &gt;
      &lt;alert:option alert:label="Confirm"&gt;
        &lt;behavior <b class="conum">(2)</b>
          trigger="press"
          action="append"
          target="item-{{ contact.id }}"
          href="/contacts/{{ contact.id }}/delete"
          verb="post"
        /&gt;
      &lt;/alert:option&gt;
      &lt;alert:option alert:label="Cancel" /&gt;
    &lt;/behavior&gt;
    &lt;text style="button-label-delete"&gt;Delete&lt;/text&gt;
  &lt;/view&gt;
&lt;/swipe:button&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>When pressed, open a system dialog box asking the user to confirm the action</p>
</li>
<li>
<p>If confirmed, make a POST request to the deletion endpoint, and append the response to the parent <code>&lt;item&gt;</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now when we press &#8220;Delete&#8221;, we get the confirmation dialog as expected.
After pressing confirm, the backend response triggers behaviors that show a confirmation toast and reload the list of contacts.
The item for the deleted contact disappears from the list.</p>
</div>
<div id="figure-7-11" class="imageblock">
<div class="content">
<img src="/home/dz4k/Documents/Projects/bigsky.software/building-hypermedia-systems/images/screenshot_hyperview_swipe_delete.png" alt="screenshot hyperview swipe delete">
</div>
<div class="title">Figure 21. Delete from swipe button</div>
</div>
<div class="paragraph">
<p>Notice that the action buttons are able to support any type of behavior action, from <code>push</code> to <code>alert</code>.
If we wanted to, we could have the action buttons trigger our custom actions, like <code>open-phone</code> and <code>open-email</code>.
Custom components and actions can be mixed freely with the standard components and actions that come standard with the Hyperview framework.
This makes the extensions to the Hyperview client feel like first-class features.</p>
</div>
<div class="paragraph">
<p>In fact, I&#8217;ll let you in on a secret.
Within the Hyperview client, standard components and actions are implemented the same way as custom components and actions!
The rendering code does not treat <code>&lt;view&gt;</code> differently from <code>&lt;swipe:row&gt;</code>.
The behavior code does not treat <code>alert</code> differently from <code>open-phone</code>.
They are both implemented using the same techniques described in this section.
Standard components and actions are just the ones that are universally needed by all mobile apps.
But they are just the starting point.
Most mobile apps will require some extensions to the Hyperview client to deliver a great user experience.
Extensions evolve the client from being a generic &#8220;Hyperview client&#8221;, to being a purpose-built client for your app.
And importantly, this evolution preserves the Hypermedia, server-driven architecture and all of its benefits.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_3">14.4. Conclusion</h3>
<div class="ulist">
<ul>
<li>
<p>With custom components and behaviors, Hyperview apps can do anything a native app can do.</p>
</li>
<li>
<p>Support for system actions (like SMS and email) can be added with a Hyperview behavior action.</p>
</li>
<li>
<p>Support for high-level UIs (like confirmation toasts) can also be added with a Hyperview behavior action.</p>
</li>
<li>
<p>Support for customized screen elements (like swipeable items in lists) can be added with Hyperview custom components.</p>
</li>
<li>
<p>The standard behaviors and components that come with the Hyperview client are implemented the same way as custom behavior actions and components.</p>
</li>
<li>
<p>By customizing the Hyperview client, developers can build a mobile app that suits their specific needs while retaining the benefits of a thin-client, hypermedia architecture.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="_conclusion_4" class="sect0">Conclusion</h1>
<div class="sect1">
<h2 id="_conclusion_5">15. Conclusion</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_hypermedia_reconsidered">Hypermedia Reconsidered</h3>
<div class="paragraph">
<p>We hope that in this book we have managed to convince you that hypermedia, rather than being a &#8220;legacy&#8221; technology
or a technology only appropriate for &#8220;documents&#8221; of links, text and pictures, is, in fact, a powerful technology for
building <em>applications</em>.  In this book you have seen how to build sophisticated user interfaces for both the web, with htmx,
and for a mobile application, using Hyperview, using hypermedia as a core underlying application technology.</p>
</div>
<div class="paragraph">
<p>Focusing in on the web, in particular, many developers today view the links and forms of &#8220;plain&#8221; HTML as bygone tools
from a less sophisticated age.  And, in some ways, they are right: there were definite usability issues with the
original web.  However, as we discovered while building Contact.app, by simply addressing four core limitations of
HTML:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By making any element capable of issuing an HTTP request</p>
</li>
<li>
<p>By making any event capable of triggering an HTTP event</p>
</li>
<li>
<p>By making all the different types of HTTP methods available</p>
</li>
<li>
<p>By making it possible to target any element in the DOM for replacement</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We were able to build user interfaces that many developers would assume require a significant amount of client-side
JavaScript, but using only hypermedia concepts.</p>
</div>
<div class="paragraph">
<p>The Hypermedia Driven Application approach is not right for every application (after all, no approach is right for
<em>every</em> application) but, for many applications, the increased flexibility and simplicity of hypermedia can be a huge
benefit.  And, even if your application wouldn&#8217;t benefit from this approach, it is at least worthwhile to <em>understand</em>
the approach, its strengths and weaknesses, and how it differs from the approach you are taking.  The original web
grew faster than any distributed system in history, and it is worth understanding the underlying technologies that
made that growth possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pausing_and_reflecting">15.1. Pausing, And Reflecting</h3>
<div class="paragraph">
<p>The JavaScript community and, by extension, the web development community is famously chaotic, with new frameworks and
technologies emerging monthly, and sometimes even <em>weekly</em>.  It can be exhausting to keep up with the latest and
greatest technologies that are coming out, and, at the same time, terrifying that we <em>won&#8217;t</em> keep up with them and
be left behind in our career.</p>
</div>
<div class="paragraph">
<p>This is not a fear without foundation: there are many senior software engineers that have seen their career peter out
because they picked a technology to specialize in that, fairly or not, did not thrive.  The web development world tends
to be young, with many companies favoring young developers over older developers who &#8220;haven&#8217;t kept up.&#8221;</p>
</div>
<div class="paragraph">
<p>We shouldn&#8217;t sugar-coat these realities of our industry.  On the other hand, we also shouldn&#8217;t ignore the downside that
these realities create.  It creates a high-pressure environment where everyone is watching for &#8220;the new new&#8221; thing, that
is, for the latest and greatest technology that is going to change everything.  It creates pressure to <em>claim</em> that your
technology is going to change everything, if you are trying to get attention.  It tends to favor <em>sophistication</em> over
<em>simplicity</em>.  People are scared to ask &#8220;Is this too complex?&#8221; because it sounds an awful lot like &#8220;I&#8217;m not smart enough
to understand this.&#8221;</p>
</div>
<div class="paragraph">
<p>The software industry has tended, especially in web development, to lean far more towards innovating, rather than
understanding the technologies of the past and building on them or within them.  We tend to look ahead for new, genius
solutions, rather than looking backwards to older ideas.  This is understandable: the technology world is necessarily
a forward-looking industry.</p>
</div>
<div class="paragraph">
<p>On the other hand, there have been a lot of great ideas in the past, many of which have been discarded.  We are old enough
to have seen hypermedia come and go as the &#8220;new new&#8221; idea.  It was a little shocking to us to see it discarded so cavalierly
by the industry.  Fortunately, the concepts are still sitting there, waiting to be discovered and reinvigorated by
a new generation of web developers.  The original, RESTful architecture of the web, when looked at with fresh eyes,
can address many of the problems today&#8217;s web developers are facing.</p>
</div>
<div class="paragraph">
<p>Perhaps, following Mark Twain&#8217;s advice, it is time to pause and reflect.  Perhaps, for a few quiet moments, we can
put the endless swirl of the &#8220;new new&#8221; aside, look back on where the web came from, and learn.</p>
</div>
<div class="paragraph">
<p>Perhaps it&#8217;s time to give hypermedia a chance.</p>
</div>
<div class="paragraph">
<p>We hope you will.</p>
</div>
</div>
</div>
</div>
    <script>
    document.querySelectorAll('pre code').forEach(code => 
        code.innerHTML = code.innerHTML.split('\n')
            .map(line => '<div class="codeline" style="padding-inline-start: '+/^ */.exec(line)[0].length+'ch;">'+line.trimStart()+"</div>")
            .join(''))
    document.querySelectorAll('a:not(.bare, .footnote)').forEach(a =>
        a.insertAdjacentHTML('beforeend', '<span class=footnote>'+a.href+'</span>')) 
    </script>
    </body>