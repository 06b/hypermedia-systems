= Hypermedia In Action
:chapter: 5
:sectnums:
:figure-caption: Figure {chapter}.
:listing-caption: Listing {chapter}.
:table-caption: Table {chapter}.
:sectnumoffset: 2
// line above:  :sectnumoffset: 5  (chapter# minus 1)
:leveloffset: 1
:sourcedir: ../code/src
:source-language:

= Hyperview: A Mobile Hypermedia

In this chapter, we will:

* Discuss shortcomings with the current state of mobile app development
* Explain how to address those problem with a Hypermedia architecture using Hyperview
* Rewriting our contacts app as a native mobile app
* Showing how one backend can serve multiple Hypermedia formats to support both web and mobile apps

== State of mobile app development

In web development, you deliver JS,HTML,CSS,JSON on-demand to a standard web browser. This is not the case with a native mobile app.

With native mobile apps, you compile code into an executable binary targeting the operating system (Android or iOS).
This binary gets uploaded and approved through app stores controlled by Google and Apple.
When you install or update an app, you're downloading the binary and running the code directly on your device's OS.
In this way, mobile apps have a lot in common with old-school desktop apps for Mac or Windows.

There is one important difference between old-school desktop apps and today's mobile apps.
These days, almost all mobile apps are "networked".
By networked, I mean the app needs to read and write data over the Internet to implement core functionality.
What's the easiest way to make a mobile app networked?
Well, the app stores already require developer to write & distribute code that runs on the user's device.
So why not have that frontend code make requests to a backend, and update the UI based on the response?

Developers are naturally led into a SPA-like pattern for developing mobile apps:

- The frontend on the mobile device, runs code to create and update the UI
- The backend is an API, called by the frontend

Just like with SPAs on the web, this architecture has a big downside: the app's logic gets spread across the frontend and backend.
Sometimes, logic needs to be duplicated (like to validate form data).
Other times, the frontend and backend each implement one part of the app's overall logic.
To understand what the app does, a developer needs to trace interactions between two very different codebases.

There's another downside which affects mobile apps more than SPAs: API churn.
Remember, the app stores control how your app gets distributed and updated.
Users can even control if and when they get updated versions of your app.
As a mobile developer, you can't assume that every user will be on the latest version of your app. 
Your frontend code gets fragmented across many versions, and now your backend needs to support all of them.


== Hypermedia for Mobile Apps
We’ve seen that the hypermedia architecture can address the problems of SPAs on the web.
But can hypermedia work for mobile apps as well?
The answer is yes!

Just like on the web, we can use Hypermedia formats on mobile to let the backend serve as the engine of app state.
All of the logic is controlled from the backend, rather than being spread between two codebases.
Hypermedia architecture also solves the annoying problem of API churn on mobile apps.
Since the backend server a Hypermedia response containing both data and actions, there's no way for the data and UI to get out of sync.
No more worries about backwards compatibility or maintaining multiple API versions.

So how can you use Hypermedia for your mobile app?
There are two approaches employing hypermedia to build & ship native mobile apps today:

- Web views, which wraps the trusty web platform in a mobile app shell
- Hyperview, a new hypermedia format designed specifically for mobile apps


=== Web views
The simplest way to use hypermedia on mobile is to make a web app!
Both Android and iOS SDKs provide "web views": ways to embed a chromeless web browser in a native app.
Tools like Apache Cordova make it easy to wrap an existing web app

build native apps around these web views. You provide your web app's UR

If you already have a responsive web app, you can have a native app for "free".
Sounds too good to be true, right?

Of course, there is a fundamental limitation with this approach.
The web and native mobile apps are different platforms, with different UX conventions.
HTML doesn't natively support common UI patterns of mobile apps.
The biggest disconnect is around navigation.
On the web, navigation is page-based, with one page replacing another and the browser providing back/forward buttons to navigate the page history.
On mobile, navigation is more complex, and tuned for the physicality of gesture-based interactions.

- To drill down, screens slide on top of each other, forming stacks of screens.
- A nav bar at the bottom of the app allows switching between various stacks of screens.
- Modals slide up from the bottom of the app, covering the other stacks and the nav bar.
- Unlike with web pages, all of these screens are still present in memory, rendered and updating based on app state.

The navigation architecture is a big difference between mobile and web platforms, but it's not the only one.
There are other UX patterns that are native on mobile, and not natively present on web:

- pull-to-refresh to refresh content in a screen
- horizontal swipe on UI elements to reveal actions
- sectioned lists with sticky headers

The web platform has no way to natively implement the UX of mobile app navigation.
Of course, these interactions can be simulated with JS libraries.
But these libraries will never have the same feel and performance as native gestures.
And using these libraries means we typically need to embrace a JS-heavy SPA architecture.
This puts us back at square 1!
We wanted to avoid using the typical SPA architecture of native mobile app development, so we turned to a Web view.
The web view allows us to use good-old hypermedia-based HTML.
But to get the desired look & feel of a mobile app, we end up building a SPA in JS.

Many mobile apps on iOS and Android are implemented as web views, and they work perfectly fine.
If you already have a responsive web app, perhaps wrapping it in a Web view and distributing it through app stores is an easy proposition.
I tend to think "let the web be the web", and "let mobile be mobile".
Your responsive web app already works perfectly fine through the mobile device's web browser.
Does it need to be in the app store too?
Progressive web app support has come a long way on iOS and Android.
Users can "install" your web app to their home screen, to launch it with a single click.

To build a hypermedia-based mobile app that feels and acts native, HTML isn't going to cut it.
We need a format designed to represent the interactions and patterns of native mobile apps.
That's exactly what Hyperview does.


=== Designing a Modern Hypermedia

We're used to thinking of HTML and the Web as the one and only Hypermedia architecture.
But that can lead us to conflate the design decisions of the Web with those of the Hypermedia architecture.
To design a mobile Hypermedia, it's important to untangle Hypermedia from the Web.
That way, we can thoughtfully choose which features to embrace, and which ones to eschew.

One of the defining characteristics of the web is its open nature.
On the web:

- Anyone can create a website (Hypermedia content)
- Anyone can link to anyone else's website
- Users can access websites through any web browser (Hypermedia client)

So Hypermedia on the Web is shaped by the fact that the Web is an open platform.
Users are comfortable using one web browser to access infinite content.
But as I described at the beginning of the chapter, that's not the experience using native mobile apps.
Apple and Google maintain strict control over their platforms.
Users expect mobile apps to be focused in their scope, not portals to a world of experiences.
This has ramifications for how we design a mobile app Hypermedia.
We don't need to design with the constraint of openness.
Instead, we need to assume a closed system, where an app developer controls both the server and client.
I call it the single-app browser.

==== The Format
Design goals:

* The format should feel familiar to HTML users.
  * Easy to pick up.
  * Use the same server side techniques that work for HTML (templating engines)
* Support common mobile patterns.
* Build in ideas from htmx. Decouple actions from triggers. Allow partial updates to screens
* Extensibility. Don't try to cover every use case.

==== The Client
* There’s one more problem with implementing our own Hypermedia.


Leaving the HTML ecosystem
create a new Hypermedia format, we nee

* Yes! However, the mindset needs to be slightly different:
   * On web, other companies provide the hypermedia client in the form of a web browser (Chrome, Safari, Firefox, etc). As a developer, you only need to worry about your HDA backend.
   * On mobile, there is no universal hypermedia client for native apps. But we can build mobile app as a thin hypermedia client that talks only to our backend.
   * But it’s a lot of work to build a hypermedia client, define the data format, etc.

* That’s where Hyperview comes in. It’s a framework that provides:
   * A pre-defined hypermedia format for defining mobile apps called HXML
   * A hypermedia client for HXML that can be bundled into your mobile app binary to render the HDA
   * Extension points to extend HXML and the client to support unique features your app may need.

* With Hyperview, we can use all the same server-side techniques we use to build Hypermedia-driven web apps.
* Hyperview has learned from htmx, a lot of the ideas are built in.
* One backend can be used to serve both apps!


== Introduction to HXML
* HTML is the most popular hypermedia format. We wanted someone familiar with HTML to feel comfortable with HXML.
   * Start with XML format. Gives us familiar syntax, and it is by nature extensible.
   * Basic building blocks: view, text, list, image, inputs
      * <Show basic example>
   * Point of extensibility, developers can create their own
      * <Show example of custom element)
* When it comes to interactions, that’s where HXML starts to diverge from HTML
   * HTML has two primary ways of interaction:
      * Click a link: GET request to load a new page
      * Click a form submit button: POST (usually) request to load a new page
   * These ways of interaction are not enough to build rich UIs. Interactions (clicks, form submits) are tightly coupled to a single action (request a new page).
   * htmx (and Intercooler before it) broke that paradigm:
      * Interactions and actions are decoupled via triggers
      * Actions can modify the current page, not just request a new page
   * This allows a wide range of new possibilities to build rich HDAs.
* HXML builds in this idea of triggers, actions and targets into the spec itself. Collectively, we refer to these as behaviors.
   * Navigation behaviors, equivalent to links in HTML.
      * Can push new screen onto a stack, or open as a modal
      * <Show navigation example>
      * Can submit a form to update a fragment
      * <Show form submission example>
* HXML takes it further:
   * A user interaction can trigger multiple behaviors, causing multiple actions
      * <Show example>
   * Actions do not necessarily cause HTTP requests, they can be used for local interactions
      * <Show example of triggering share sheet or dialog>
   * Actions are extensible, developers can create their own
      * <Show example of custom behavior>


== Building a Contacts Mobile App With Hyperview
* HDAs can easily target multiple Hypermedia formats
* Our contacts app can easily become a native mobile app with Hyperview!

=== Basics
   * Add support for returning either HTML or XML based on request
   * Create base layout templates
   * Set up a demo Hyperview client (using Expo)
* Contacts screen:
   * Convert to <list> and <items>
   * Add behavior to open details
   * Pull to refresh
   * Add infinite scroll
* Contact view:
   * Show data and buttons to edit/delete
   * Edit button: replace data with form
      * On submit: show spinner, then go back
   * Delete button: show spinner, then go back
   * Problem: Contacts screen is not updated!
      * Solution: add event dispatch, contacts screen listens to updates


=== Extending Hyperview
* Problem: how to show a toast confirming the action?
   * Remember, no scripting to add functionality
   * Need to extend Hyperview with a toast component
   * Find a RN library, show how to wrap it as custom component.

* Problem: we want to call/email our contacts.
  * Remember, no scripting to add functionality
  * Need to extend Hyperview with behaviors for sms, call, email
  * Find a RN library, show how to wrap it as custom behaviors.

* With custom components and behaviors, we can do almost anything a native app can do.
* Note how we cleanly extend the client:
  * HXML remains pure XML, no scripts
  * We've essentially added features to the Hyperview "browser" that we need


== One Backend, Multiple Hypermedias
* We turned out simple Contacts app into a native mobile app
  * mostly, we changed templates from HTML to HXML
* But the app doesn't work on the web anymore.
* Can we use the same backend for both a rich web app and a native mobile app?
* Yes! The same backend logic can be used for both, we just need to respond with HTML or HXML based on the client.
* There are a couple of relevant approaches.
* The important thing is to detect whether the client speaks HTML or HXML.
  * Luckily, this is what the HTTP Accept header is for!
  * HV client uses two headers: one for full docs, and one for fragments
* Using the Accept header, we know if the client is a web browser of mobile app using Hyperview, and we can respond with HTML or HXML.
* But what's the best way to organize our code? Two approaches to consider with different tradeoffs:

* Approach 1: share the same view, but select template based on header
  * easiest approach, minor changes
  * works well if the interactions on both platforms is the same
  * may not be the best approach if the two platforms have different behaviors

* Approach 2: share the same model logic, but create separate views
  * some duplication required to parse requests
  * the context can be uniquely crafted for the given platform


== Summary
